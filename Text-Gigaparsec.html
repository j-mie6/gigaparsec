<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Gigaparsec</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">gigaparsec</span><ul class="links" id="page-menu"><li><a href="src/Text.Gigaparsec.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>Jamie Willis, Gigaparsec Maintainers</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Gigaparsec</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">The <code>Parsec</code> type</a></li><li><a href="#g:2">Primitive Combinators</a></li><li><a href="#g:3">Consumptionless Parsers</a></li><li><a href="#g:4">Result Changing Combinators</a></li><li><a href="#g:5">Sequencing Combinators</a></li><li><a href="#g:6">Branching Combinators</a></li><li><a href="#g:7">Selective Combinators</a></li><li><a href="#g:8">Filtering Combinators</a></li><li><a href="#g:9">Folding Combinators</a><ul><li><a href="#g:10">The <code>many</code> Combinators</a></li><li><a href="#g:11">The <code>some</code> Combinators</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains the core combinators and parser type: all parsers will require something from
within!</p><p><em>Since: 0.1.0.0</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Parsec">Parsec</a> a</li><li class="src short"><span class="keyword">data</span> <a href="#t:Result">Result</a> e a<ul class="subs"><li>= <a href="#v:Success">Success</a> a</li><li>| <a href="#v:Failure">Failure</a> e</li></ul></li><li class="src short"><a href="#v:result">result</a> :: (e -&gt; b) -&gt; (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; b</li><li class="src short"><a href="#v:parse">parse</a> :: <a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a> err =&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> err a</li><li class="src short"><a href="#v:parseFromFile">parseFromFile</a> :: <a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a> err =&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:FilePath" title="Prelude">FilePath</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> err a)</li><li class="src short"><a href="#v:parseRepl">parseRepl</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> a =&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ()</li><li class="src short"><a href="#v:atomic">atomic</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:lookAhead">lookAhead</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:notFollowedBy">notFollowedBy</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:eof">eof</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:unit">unit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:pure">pure</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; a -&gt; f a</li><li class="src short"><a href="#v:empty">empty</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a</li><li class="src short"><a href="#v:-36--62-">($&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:-60--36--62-">(&lt;$&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:-60--36-">(&lt;$)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; a -&gt; f b -&gt; f a</li><li class="src short"><a href="#v:void">void</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; f a -&gt; f ()</li><li class="src short"><a href="#v:-60--126--62-">(&lt;~&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (a, b)</li><li class="src short"><a href="#v:-60-:-62-">(&lt;:&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a] -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:liftA2">liftA2</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</li><li class="src short"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f b -&gt; f b</li><li class="src short"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f b -&gt; f a</li><li class="src short"><a href="#v:-60--42--42--62-">(&lt;**&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b</li><li class="src short"><a href="#v:-60--43--62-">(&lt;+&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)</li><li class="src short"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f a -&gt; f a</li><li class="src short"><a href="#v:select">select</a> :: <a href="https://hackage.haskell.org/package/selective-0.7.0.1/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> f =&gt; f (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; f (a -&gt; b) -&gt; f b</li><li class="src short"><a href="#v:branch">branch</a> :: <a href="https://hackage.haskell.org/package/selective-0.7.0.1/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> f =&gt; f (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; f (a -&gt; c) -&gt; f (b -&gt; c) -&gt; f c</li><li class="src short"><a href="#v:filterS">filterS</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:mapMaybeS">mapMaybeS</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:many">many</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f [a]</li><li class="src short"><a href="#v:manyl">manyl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:manyr">manyr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:manyMap">manyMap</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; (a -&gt; m) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m</li><li class="src short"><a href="#v:some">some</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f [a]</li><li class="src short"><a href="#v:somel">somel</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:somer">somer</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:someMap">someMap</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> s =&gt; (a -&gt; s) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> s</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>The <code>Parsec</code> type</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Parsec" class="def">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.html#Parsec" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></p><div class="doc"><p>This type represents parsers as a first-class value.</p><p>Values of this type are constructed using the library's combinators, to build
up a final <code><a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></code> value that can be passed to <code><a href="Text-Gigaparsec.html#v:parse" title="Text.Gigaparsec">parse</a></code> or one
of the similar functions. This is implemented internally similar to other
libraries like <code class="inline-code">parsec</code> and <code class="inline-code">gigaparsec</code>.</p><p><em>Since: 0.1.0.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Parsec">Instances</h4><details id="i:Parsec" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Alternative:1"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-138" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc"><p><em>Since: 0.1.0.0</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parsec:Alternative:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a] <a href="#v:many" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Applicative:2"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-70" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc"><p><em>Since: 0.1.0.0</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parsec:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Functor:3"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-67" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc"><p><em>Since: 0.1.0.0</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parsec:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Monad:4"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-117" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc"><p><em>Since: 0.1.0.0</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parsec:Monad:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; (a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Selective:5"></span> <a href="https://hackage.haskell.org/package/selective-0.7.0.1/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-94" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc"><p><em>Since: 0.1.0.0</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parsec:Selective:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:select">select</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:select" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Monoid:6"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m)</span> <a href="src/Text.Gigaparsec.Internal.html#line-214" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc"><p><em>Since: 0.1.0.0</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parsec:Monoid:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m] -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Semigroup:7"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> (<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m)</span> <a href="src/Text.Gigaparsec.Internal.html#line-207" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc"><p><em>Since: 0.1.0.0</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parsec:Semigroup:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Result" class="def">Result</a> e a <a href="src/Text.Gigaparsec.html#Result" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></p><div class="doc"><p>Similar to <code class="inline-code">Either</code>, this type represents whether a parser has failed or not.</p><p>This is chosen instead of <code class="inline-code">Either</code> to be more specific about the naming.</p><p><em>Since: 0.1.0.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Success" class="def">Success</a> a</td><td class="doc"><p>The parser succeeded with a result of type <code class="inline-code">a</code>.</p></td></tr><tr><td class="src"><a id="v:Failure" class="def">Failure</a> e</td><td class="doc"><p>The parser failed with an error of type <code class="inline-code">e</code>.</p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Result">Instances</h4><details id="i:Result" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Result:Generic:1"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Generic" title="GHC.Generics">Generic</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span> <a href="src/Text.Gigaparsec.html#line-149" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Result:Generic:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:if:Rep_Result:Rep:1"></span> <span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:if:Rep_Result:Rep:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a) = <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:D1" title="GHC.Generics">D1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaData" title="GHC.Generics">MetaData</a> &quot;Result&quot; &quot;Text.Gigaparsec&quot; &quot;gigaparsec-0.3.1.0-inplace&quot; '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> &quot;Success&quot; '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rec0" title="GHC.Generics">Rec0</a> a)) <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t::-43-:" title="GHC.Generics">:+:</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> &quot;Failure&quot; '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rec0" title="GHC.Generics">Rec0</a> e)))</div></details></td></tr></table></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:from">from</a> :: <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a) x <a href="#v:from" class="selflink">#</a></p><p class="src"><a href="#v:to">to</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a) x -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a <a href="#v:to" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Result:Show:2"></span> (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> a, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> e) =&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span> <a href="src/Text.Gigaparsec.html#line-149" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Result:Show:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Result:Eq:3"></span> (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> e) =&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span> <a href="src/Text.Gigaparsec.html#line-149" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Result:Eq:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Result:Rep:4"></span> <span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span> <a href="src/Text.Gigaparsec.html#line-149" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Result:Rep:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a) = <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:D1" title="GHC.Generics">D1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaData" title="GHC.Generics">MetaData</a> &quot;Result&quot; &quot;Text.Gigaparsec&quot; &quot;gigaparsec-0.3.1.0-inplace&quot; '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> &quot;Success&quot; '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rec0" title="GHC.Generics">Rec0</a> a)) <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t::-43-:" title="GHC.Generics">:+:</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> &quot;Failure&quot; '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Exts.html#t:Symbol" title="GHC.Exts">Symbol</a>) '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/GHC-Generics.html#t:Rec0" title="GHC.Generics">Rec0</a> e)))</div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:result" class="def">result</a> <a href="src/Text.Gigaparsec.html#result" class="link">Source</a> <a href="#v:result" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (e -&gt; b)</td><td class="doc"><p><code class="inline-code">failure</code>, the function that handles the failure case.</p></td></tr><tr><td class="src">-&gt; (a -&gt; b)</td><td class="doc"><p><code class="inline-code">success</code>, the function that handles the successful case.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a</td><td class="doc"><p><code class="inline-code">result</code>, the parse result to process.</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p>applies either <code class="inline-code">failure</code> or <code class="inline-code">success</code> to the <code class="inline-code">result</code>, depending on
 whether or not it is successful.</p></td></tr></table></div><div class="doc"><p>A fold for the <code><a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a></code> type.</p><p>This functions like the <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#v:either" title="Data.Either">either</a></code> function does for <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code>.</p><p><em>Since: 0.2.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:parse" class="def">parse</a> <a href="src/Text.Gigaparsec.html#parse" class="link">Source</a> <a href="#v:parse" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a> err</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser to execute</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>the input to parse</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> err a</td><td class="doc"><p>result of the parse, either an error or result</p></td></tr></table></div><div class="doc"><p>Runs a parser against some input.</p><p>Given a parser, some input, and a way of producing parse errors of a desired
type (via <code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a></code>), this function runs a parser to produce either a
successful result or an error. Note that the <code class="inline-code">err</code> type parameter is first,
which allows for <code class="inline-code">parse @String</code> to make use of the defaultly formated <code class="inline-code">String</code>
error messages. This may not be required if it is clear from context. To make
this process nicer within GHCi, consider using <code><a href="Text-Gigaparsec.html#v:parseRepl" title="Text.Gigaparsec">parseRepl</a></code>.</p><p><em>Since: 0.2.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:parseFromFile" class="def">parseFromFile</a> <a href="src/Text.Gigaparsec.html#parseFromFile" class="link">Source</a> <a href="#v:parseFromFile" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a> err</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser to execute</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:FilePath" title="Prelude">FilePath</a></td><td class="doc"><p>the file to source the input from</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> err a)</td><td class="doc"><p>the result of the parse, error or otherwise</p></td></tr></table></div><div class="doc"><p>Runs a parser against some input obtained from a given file.</p><p>Given a parser, a filename, and a way of producing parse errors of a desired
type (via <code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a></code>), this function runs a parser to produce either a
successful result or an error. First, input is collected by reading the file,
and then the result is returned within <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a></code>; the filename is forwarded on to
the <code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a></code>, which may mean it forms part of the generated error messages.</p><p>Note that the <code class="inline-code">err</code> type parameter is first,
which allows for <code class="inline-code">parseFromFile @String</code> to make use of the defaultly formated <code class="inline-code">String</code>
error messages. This may not be required if it is clear from context.</p><p><em>Since: 0.2.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:parseRepl" class="def">parseRepl</a> <a href="src/Text.Gigaparsec.html#parseRepl" class="link">Source</a> <a href="#v:parseRepl" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the parser to execute.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p><code class="inline-code">input</code>, the input to parse.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a> ()</td><td class="doc"><p>An <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:IO" title="Prelude">IO</a></code> action which parses <code class="inline-code">input</code> with <code class="inline-code">p</code>, 
 and prints the result to the terminal.</p></td></tr></table></div><div class="doc"><p>Runs a parser against some input, pretty-printing the result to the terminal.</p><p>Compared, with <code><a href="Text-Gigaparsec.html#v:parse" title="Text.Gigaparsec">parse</a></code>, this function will always generate error messages as
strings and will print them nicely to the terminal (on multiple lines). If the
parser succeeds, the result will also be printed to the terminal. This is useful
for playing around with parsers in GHCi, seeing the results more clearly.</p><p><em>Since: 0.2.0.0</em></p></div></div><a href="#g:2" id="g:2"><h1>Primitive Combinators</h1></a><div class="doc"><p>These combinators are specific to parser combinators. In one way or another, they influence
 how a parser consumes input, or under what conditions a parser does or does not fail. These are
 really important for most practical parsing considerations, although lookAhead is much less
 well used.</p></div><div class="top"><p class="src"><a id="v:atomic" class="def">atomic</a> <a href="src/Text.Gigaparsec.html#atomic" class="link">Source</a> <a href="#v:atomic" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser, <code class="inline-code">p</code>, to execute, if it fails, it will not have consumed input.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that tries <code class="inline-code">p</code>, but never consumes input if it fails.</p></td></tr></table></div><div class="doc"><p>This combinator parses its argument <code class="inline-code">p</code>, but rolls back any consumed input on failure.</p><p>If the parser <code class="inline-code">p</code> succeeds, then <code class="inline-code">atomic p</code> has no effect. However, if <code class="inline-code">p</code> failed,
then any input that it consumed is rolled back. This has two uses: it ensures that
the parser <code class="inline-code">p</code> is all-or-nothing when consuming input, and it allows for
parsers that consume input to backtrack when they fail (with <code><a href="Text-Gigaparsec.html#v:-60--124--62-" title="Text.Gigaparsec">(&lt;|&gt;)</a></code>). It should be
used for the latter purpose sparingly, however, since excessive backtracking in a
parser can result in much lower efficiency.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:atomic0">Examples</h4><details id="ch:atomic0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (string &quot;abc&quot; &lt;|&gt; string &quot;abd&quot;) &quot;abd&quot;
</code></strong>Failure .. -- first parser consumed a, so no backtrack
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (atomic (string &quot;abc&quot;) &lt;|&gt; string &quot;abd&quot;) &quot;abd&quot;
</code></strong>Success &quot;abd&quot; -- first parser does not consume input on failure now
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:lookAhead" class="def">lookAhead</a> <a href="src/Text.Gigaparsec.html#lookAhead" class="link">Source</a> <a href="#v:lookAhead" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser, <code class="inline-code">p</code>, to execute</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that parses <code class="inline-code">p</code> and never consumes input if it succeeds.</p></td></tr></table></div><div class="doc"><p>This combinator parses its argument <code class="inline-code">p</code>, but does not consume input if it succeeds.</p><p>If the parser <code class="inline-code">p</code> succeeds, then <code class="inline-code">lookAhead p</code> will roll back any input consumed
whilst parsing <code class="inline-code">p</code>. If <code class="inline-code">p</code> fails, however, then the whole combinator fails and
any input consumed <strong>remains consumed</strong>. If this behaviour is not desirable,
consider pairing <code><a href="Text-Gigaparsec.html#v:lookAhead" title="Text.Gigaparsec">lookAhead</a></code> with <code><a href="Text-Gigaparsec.html#v:atomic" title="Text.Gigaparsec">atomic</a></code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:lookAhead0">Examples</h4><details id="ch:lookAhead0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (lookAhead (string &quot;aaa&quot;) *&gt; string &quot;aaa&quot;) &quot;aaa&quot;
</code></strong>Success &quot;aaa&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (lookAhead (string &quot;abc&quot;) &lt;|&gt; string &quot;abd&quot; &quot;abd&quot;
</code></strong>Failure .. -- lookAhead does not roll back input consumed on failure
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:notFollowedBy" class="def">notFollowedBy</a> <a href="src/Text.Gigaparsec.html#notFollowedBy" class="link">Source</a> <a href="#v:notFollowedBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser, <code class="inline-code">p</code>, to execute, it must fail in order for this combinator to succeed.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p>a parser which fails when <code class="inline-code">p</code> succeeds and succeeds otherwise, never consuming input.</p></td></tr></table></div><div class="doc"><p>This combinator parses its argument <code class="inline-code">p</code>, and succeeds when <code class="inline-code">p</code> fails and vice-versa, never consuming
input.</p><p>If the parser <code class="inline-code">p</code> succeeds, then <code class="inline-code">notFollowedBy p</code> will fail, consuming no input.
Otherwise, should <code class="inline-code">p</code> fail, then <code class="inline-code">notFollowedBy p</code> will succeed, consuming no input
and returning <code class="inline-code">()</code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:notFollowedBy0">Examples</h4><details id="ch:notFollowedBy0"><summary class="hide-when-js-enabled">Expand</summary><p>One use for this combinator is to allow for &quot;longest-match&quot; behaviour.
For instance, keywords are normally only considered keywords if they are not
part of some larger valid identifier (i.e. the keyword &quot;if&quot; should not parse
successfully given &quot;ifp&quot;). This can be accomplished as follows:</p><pre>keyword :: String -&gt; Parsec ()
keyword kw = atomic $ string kw *&gt; notFollowedBy letterOrDigit</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:eof" class="def">eof</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.html#eof" class="link">Source</a> <a href="#v:eof" class="selflink">#</a></p><div class="doc"><p>This parser only succeeds at the end of the input.</p><p>Equivalent to `notFollowedBy(item)`.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:eof0">Examples</h4><details id="ch:eof0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse eof &quot;a&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse eof &quot;&quot;
</code></strong>Success ()
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:3" id="g:3"><h1>Consumptionless Parsers</h1></a><div class="doc"><p>These combinators and parsers do not consume input: they are the most primitive ways of
 producing successes and failures with the minimal possible effect on the parse. They are,
 however, reasonably useful; in particular, <code><a href="Text-Gigaparsec.html#v:pure" title="Text.Gigaparsec">pure</a></code> and <code><a href="Text-Gigaparsec.html#v:unit" title="Text.Gigaparsec">unit</a></code> can be put to good use in
 injecting results into a parser without needing to consume anything, or mapping another parser.</p></div><div class="top"><p class="src"><a id="v:unit" class="def">unit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.html#unit" class="link">Source</a> <a href="#v:unit" class="selflink">#</a></p><div class="doc"><p>This parser produces <code class="inline-code">()</code> without having any other effect.</p><p>When this parser is ran, no input is required, nor consumed, and the given value will always be
successfully returned. It has no other effect on the state of the parser.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:pure" class="def">pure</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; a -&gt; f a <a href="#v:pure" class="selflink">#</a></p><div class="doc"><p>Lift a value into the Structure.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:pure0">Examples</h4><details id="ch:pure0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>pure 1 :: Maybe Int
</code></strong>Just 1
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>pure 'z' :: [Char]
</code></strong>&quot;z&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>pure (pure &quot;:D&quot;) :: Maybe [String]
</code></strong>Just [&quot;:D&quot;]
</pre></details></div></div><div class="top"><p class="src"><a id="v:empty" class="def">empty</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a <a href="#v:empty" class="selflink">#</a></p><div class="doc"><p>The identity of <code><a href="Text-Gigaparsec.html#v:-60--124--62-" title="Text.Gigaparsec">&lt;|&gt;</a></code></p><pre>empty &lt;|&gt; a     == a
a     &lt;|&gt; empty == a</pre></div></div><a href="#g:4" id="g:4"><h1>Result Changing Combinators</h1></a><div class="doc"><p>These combinators change the result of the parser they are called on into a value of a
 different type. This new result value may or may not be derived from the previous result.</p></div><div class="top"><p class="src"><a id="v:-36--62-" class="def">($&gt;)</a> <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/Text.Gigaparsec.html#%24%3E" class="link">Source</a> <a href="#v:-36--62-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the parser to run, whose result is ignored.</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p><code class="inline-code">x</code>, the value to return</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p>a parser that runs <code class="inline-code">p</code>, but returns the value <code class="inline-code">x</code>.</p></td></tr></table></div><div class="doc"><p>This combinator, pronounced &quot;as&quot;, replaces the result of the given parser, ignoring the old result.</p><p>Similar to <code class="inline-code">(<a href="$">$</a>)</code>, except the old result of the given parser is not required to
compute the new result. This is useful when the result is a constant value (or function!).
Functionally the same as <code class="inline-code">p *&gt; pure x</code> or <code class="inline-code">const x <a href="$">$</a> p</code>.</p><p><em>In <a href="https://j-mie6.github.io/parsley/">scala parsley</a>, this combinator is known as </em><code class="inline-code">#&gt;</code><em> or </em>'<code class="inline-code">as</code>'.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-36--62-0">Examples</h4><details id="ch:-36--62-0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (string &quot;true&quot; $&gt; true) &quot;true&quot;
</code></strong>Success true
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:-60--36--62-" class="def">(&lt;$&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--36--62-" class="selflink">#</a></p><div class="doc"><p>An infix synonym for <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#v:fmap" title="Control.Monad">fmap</a></code>.</p><p>The name of this operator is an allusion to <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:-36-" title="Prelude">$</a></code>.
 Note the similarities between their types:</p><pre> ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</pre><p>Whereas <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:-36-" title="Prelude">$</a></code> is function application, <code><a href="Text-Gigaparsec.html#v:-60--36--62-" title="Text.Gigaparsec">&lt;$&gt;</a></code> is function
 application lifted over a <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a></code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--36--62-0">Examples</h4><details id="ch:-60--36--62-0"><summary class="hide-when-js-enabled">Expand</summary><p>Convert from a <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Maybe" title="Data.Maybe">Maybe</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code> to a <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Maybe" title="Data.Maybe">Maybe</a></code>
 <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#v:String" title="Data.String">String</a></code></code> using <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:show" title="Prelude">show</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>show &lt;$&gt; Nothing
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>show &lt;$&gt; Just 3
</code></strong>Just &quot;3&quot;
</pre><p>Convert from an <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#v:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code> to an
 <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#v:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#v:String" title="Data.String">String</a></code> using <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:show" title="Prelude">show</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>show &lt;$&gt; Left 17
</code></strong>Left 17
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>show &lt;$&gt; Right 17
</code></strong>Right &quot;17&quot;
</pre><p>Double each element of a list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(*2) &lt;$&gt; [1,2,3]
</code></strong>[2,4,6]
</pre><p>Apply <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#v:even" title="Prelude">even</a></code> to the second element of a pair:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>even &lt;$&gt; (2,2)
</code></strong>(2,True)
</pre></details></div></div><div class="top"><p class="src"><a id="v:-60--36-" class="def">(&lt;$)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; a -&gt; f b -&gt; f a <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--36-" class="selflink">#</a></p><div class="doc"><p>Replace all locations in the input with the same value.
 The default definition is <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#v:fmap" title="Control.Monad">fmap</a></code> . <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Function.html#v:const" title="Data.Function">const</a></code></code>, but this may be
 overridden with a more efficient version.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--36-0">Examples</h4><details id="ch:-60--36-0"><summary class="hide-when-js-enabled">Expand</summary><p>Perform a computation with <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> and replace the result with a
 constant value if it is <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>'a' &lt;$ Just 2
</code></strong>Just 'a'
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>'a' &lt;$ Nothing
</code></strong>Nothing
</pre></details></div></div><div class="top"><p class="src"><a id="v:void" class="def">void</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#t:Functor" title="Control.Monad">Functor</a> f =&gt; f a -&gt; f () <a href="#v:void" class="selflink">#</a></p><div class="doc"><p><code class="inline-code"><code><a href="Text-Gigaparsec.html#v:void" title="Text.Gigaparsec">void</a></code> value</code> discards or ignores the result of evaluation, such
 as the return value of an <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/System-IO.html#v:IO" title="System.IO">IO</a></code> action.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:void0">Examples</h4><details id="ch:void0"><summary class="hide-when-js-enabled">Expand</summary><p>Replace the contents of a <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Maybe" title="Data.Maybe">Maybe</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code> with unit:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void Nothing
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void (Just 3)
</code></strong>Just ()
</pre><p>Replace the contents of an <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#v:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code>
 with unit, resulting in an <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#v:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code> <code class="inline-code">()</code></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void (Left 8675309)
</code></strong>Left 8675309
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void (Right 8675309)
</code></strong>Right ()
</pre><p>Replace every element of a list with unit:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void [1,2,3]
</code></strong>[(),(),()]
</pre><p>Replace the second element of a pair with unit:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void (1,2)
</code></strong>(1,())
</pre><p>Discard the result of an <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/System-IO.html#v:IO" title="System.IO">IO</a></code> action:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mapM print [1,2]
</code></strong>1
2
[(),()]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void $ mapM print [1,2]
</code></strong>1
2
</pre></details></div></div><a href="#g:5" id="g:5"><h1>Sequencing Combinators</h1></a><div class="doc"><p>These combinators all combine two parsers in sequence. The first argument of the combinator
 will be executed first, then the second argument second. The results of both parsers are
 combined in some way (depending on the individual combinator). If one of the parsers fails, the
 combinator as a whole fails.</p></div><div class="top"><p class="src"><a id="v:-60--126--62-" class="def">(&lt;~&gt;)</a> <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/Text.Gigaparsec.html#%3C~%3E" class="link">Source</a> <a href="#v:-60--126--62-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the first parser to run.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p><code class="inline-code">q</code>, the second parser to run.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (a, b)</td><td class="doc"><p>a parser that runs <code class="inline-code">p</code> and then <code class="inline-code">q</code>, and pairs their results.</p></td></tr></table></div><div class="doc"><p>This combinator, pronounced &quot;zip&quot;, first parses <code class="inline-code">p</code> then parses <code class="inline-code">q</code>: 
if both succeed the result of <code class="inline-code">p</code> is paired with that of <code class="inline-code">q</code>.</p><p>First, runs <code class="inline-code">p</code>, yielding <code class="inline-code">x</code> on success, then runs <code class="inline-code">q</code>, yielding <code class="inline-code">y</code> on success. 
If both are successful then <code class="inline-code">(x, y)</code> is returned. 
If either fail then the entire combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--126--62-0">Examples</h4><details id="ch:-60--126--62-0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>p = char 'a' &lt;~&gt; char 'b'
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse p &quot;ab&quot;
</code></strong>Success ('a', 'b')
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse p &quot;b&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse p &quot;a&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:-60-:-62-" class="def">(&lt;:&gt;)</a> <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/Text.Gigaparsec.html#%3C%3A%3E" class="link">Source</a> <a href="#v:-60-:-62-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the first parser to run</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p><code class="inline-code">q</code>, the second parser to run</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that runs <code class="inline-code">p</code> and then <code class="inline-code">q</code>, 
 and prepends the result of the former onto that of the latter.</p></td></tr></table></div><div class="doc"><p>This combinator, pronounced &quot;cons&quot;, first parses <code class="inline-code">p</code> and then <code class="inline-code">ps</code>: if both succeed the result of this
parser is prepended onto the result of <code class="inline-code">ps</code>.</p><p>First, runs <code class="inline-code">p</code>, yielding <code class="inline-code">x</code> on success, then runs <code class="inline-code">ps</code>, yielding <code class="inline-code">xs</code> on success. 
If both are successful then <code class="inline-code">x : xs</code> is returned. 
If either fail then the entire combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60-:-62-0">Examples</h4><details id="ch:-60-:-62-0"><summary class="hide-when-js-enabled">Expand</summary><pre>some p = p &lt;:&gt; many(p)</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:-60--42--62-" class="def">(&lt;*&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--42--62-" class="selflink">#</a></p><div class="doc"><p>Sequential application.</p><p>A few functors support an implementation of <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code> that is more
 efficient than the default one.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--42--62-0">Example</h4><details id="ch:-60--42--62-0"><summary class="hide-when-js-enabled">Expand</summary><p>Used in combination with <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">(&lt;$&gt;)</a></code></code>, <code class="inline-code"><code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">(&lt;*&gt;)</a></code></code> can be used to build a record.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>produceFoo :: Applicative f =&gt; f Foo
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>produceBar :: Applicative f =&gt; f Bar
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>produceBaz :: Applicative f =&gt; f Baz
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mkState :: Applicative f =&gt; f MyState
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
</code></strong></pre></details></div></div><div class="top"><p class="src"><a id="v:liftA2" class="def">liftA2</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c <a href="#v:liftA2" class="selflink">#</a></p><div class="doc"><p>Lift a binary function to actions.</p><p>Some functors support an implementation of <code><a href="Text-Gigaparsec.html#v:liftA2" title="Text.Gigaparsec">liftA2</a></code> that is more
 efficient than the default one. In particular, if <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#v:fmap" title="Control.Monad">fmap</a></code> is an
 expensive operation, it is likely better to use <code><a href="Text-Gigaparsec.html#v:liftA2" title="Text.Gigaparsec">liftA2</a></code> than to
 <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#v:fmap" title="Control.Monad">fmap</a></code> over the structure and then use <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code>.</p><p>This became a typeclass method in 4.10.0.0. Prior to that, it was
 a function defined in terms of <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Monad.html#v:fmap" title="Control.Monad">fmap</a></code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:liftA20">Example</h4><details id="ch:liftA20"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>liftA2 (,) (Just 3) (Just 5)
</code></strong>Just (3,5)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>liftA2 (+) [1, 2, 3] [4, 5, 6]
</code></strong>[5,6,7,6,7,8,7,8,9]
</pre></details></div></div><div class="top"><p class="src"><a id="v:-42--62-" class="def">(*&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f b -&gt; f b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-42--62-" class="selflink">#</a></p><div class="doc"><p>Sequence actions, discarding the value of the first argument.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-42--62-0">Examples</h4><details id="ch:-42--62-0"><summary class="hide-when-js-enabled">Expand</summary><p>If used in conjunction with the Applicative instance for <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code>,
 you can chain Maybe computations, with a possible &quot;early return&quot;
 in case of <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 2 *&gt; Just 3
</code></strong>Just 3
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Nothing *&gt; Just 3
</code></strong>Nothing
</pre><p>Of course a more interesting use case would be to have effectful
 computations instead of just returning pure values.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Char
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import GHC.Internal.Text.ParserCombinators.ReadP
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = string &quot;my name is &quot; *&gt; munch1 isAlpha &lt;* eof
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>readP_to_S p &quot;my name is Simon&quot;
</code></strong>[(&quot;Simon&quot;,&quot;&quot;)]
</pre></details></div></div><div class="top"><p class="src"><a id="v:-60--42-" class="def">(&lt;*)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f b -&gt; f a <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--42-" class="selflink">#</a></p><div class="doc"><p>Sequence actions, discarding the value of the second argument.</p></div></div><div class="top"><p class="src"><a id="v:-60--42--42--62-" class="def">(&lt;**&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--42--42--62-" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code> with the types of the arguments reversed. It differs from
 <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Function.html#v:flip" title="Data.Function">flip</a></code> <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">(&lt;*&gt;)</a></code></code> in that the effects are resolved in the order the arguments are
 presented.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--42--42--62-0">Examples</h4><details id="ch:-60--42--42--62-0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(&lt;**&gt;) (print 1) (id &lt;$ print 2)
</code></strong>1
2
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>flip (&lt;*&gt;) (print 1) (id &lt;$ print 2)
</code></strong>2
1
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ZipList [4, 5, 6] &lt;**&gt; ZipList [(+1), (*2), (/3)]
</code></strong>ZipList {getZipList = [5.0,10.0,2.0]}
</pre></details></div></div><a href="#g:6" id="g:6"><h1>Branching Combinators</h1></a><div class="doc"><p>These combinators allow for parsing one alternative or another. All of these combinators are
 <em>left-biased</em>, which means that the left-hand side of the combinator is tried first: the
 right-hand side of the combinator will only be tried when the left-hand one failed (and did not
 consume input in the process).</p></div><div class="top"><p class="src"><a id="v:-60--43--62-" class="def">(&lt;+&gt;)</a> <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="src/Text.Gigaparsec.html#%3C%2B%3E" class="link">Source</a> <a href="#v:-60--43--62-" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the first parser to run</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p><code class="inline-code">q</code>, the parser to run if <code class="inline-code">p</code> fails without consuming input</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)</td><td class="doc"><p>a parser which either parses <code class="inline-code">p</code>, or <code class="inline-code">q</code>, projecting their 
 results into an <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code>.</p></td></tr></table></div><div class="doc"><p>This combinator, pronounced &quot;sum&quot;, wraps the given parser's result in <code class="inline-code">Left</code> if it succeeds, and parses <code class="inline-code">q</code> if it failed <strong>without</strong> consuming input,
wrapping the result in <code class="inline-code">Right</code>.</p><p>If the given parser <code class="inline-code">p</code> is successful, then its result is wrapped up using <code class="inline-code">Left</code> and no further action is taken.
Otherwise, if <code class="inline-code">p</code> fails <strong>without</strong> consuming input, then <code class="inline-code">q</code> is parsed instead and its result is
wrapped up using <code class="inline-code">Right</code>.
If <code class="inline-code">p</code> fails having consumed input, this combinator fails.
This is functionally equivalent to <code class="inline-code">Left <a href="$">$</a> p <a href="|">|</a> Right <a href="$">$</a> q</code>.</p><p>The reason for this behaviour is that it prevents space leaks and improves error messages. 
If this behaviour is not desired, use <code class="inline-code">atomic p</code> to rollback any input consumed on failure.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--43--62-0">Examples</h4><details id="ch:-60--43--62-0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>p = string &quot;abc&quot; &lt;+&gt; char &quot;xyz&quot;
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse p &quot;abc&quot;
</code></strong>Success (Left &quot;abc&quot;)
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse p &quot;xyz&quot;
</code></strong>Success (Right &quot;xyz&quot;)
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse p &quot;ab&quot;
</code></strong>Failure .. -- first parser consumed an 'a'!
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:-60--124--62-" class="def">(&lt;|&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f a -&gt; f a <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="#v:-60--124--62-" class="selflink">#</a></p><div class="doc"><p>An associative binary operation</p></div></div><a href="#g:7" id="g:7"><h1>Selective Combinators</h1></a><div class="doc"><p>These combinators will decide which branch to take next based on the result of another parser.
 This differs from combinators like <code><a href="Text-Gigaparsec.html#v:-60--124--62-" title="Text.Gigaparsec">(&lt;|&gt;)</a></code> which make decisions based on the success/failure of
 a parser: here the result of a <em>successful</em> parse will direct which option is done.</p></div><div class="top"><p class="src"><a id="v:select" class="def">select</a> :: <a href="https://hackage.haskell.org/package/selective-0.7.0.1/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> f =&gt; f (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; f (a -&gt; b) -&gt; f b <a href="#v:select" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:branch" class="def">branch</a> :: <a href="https://hackage.haskell.org/package/selective-0.7.0.1/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> f =&gt; f (<a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; f (a -&gt; c) -&gt; f (b -&gt; c) -&gt; f c <a href="#v:branch" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Text-Gigaparsec.html#v:branch" title="Text.Gigaparsec">branch</a></code> function is a natural generalisation of <code><a href="Text-Gigaparsec.html#v:select" title="Text.Gigaparsec">select</a></code>: instead of
 skipping an unnecessary effect, it chooses which of the two given effectful
 functions to apply to a given argument; the other effect is unnecessary. It
 is possible to implement <code><a href="Text-Gigaparsec.html#v:branch" title="Text.Gigaparsec">branch</a></code> in terms of <code><a href="Text-Gigaparsec.html#v:select" title="Text.Gigaparsec">select</a></code>, which is a good
 puzzle (give it a try!).</p><p>We can also implement <code><a href="Text-Gigaparsec.html#v:select" title="Text.Gigaparsec">select</a></code> via <code><a href="Text-Gigaparsec.html#v:branch" title="Text.Gigaparsec">branch</a></code>:</p><pre>selectB :: Selective f =&gt; f (Either a b) -&gt; f (a -&gt; b) -&gt; f b
selectB x y = branch x y (pure id)
</pre></div></div><a href="#g:8" id="g:8"><h1>Filtering Combinators</h1></a><div class="doc"><p>These combinators perform filtering on the results of a parser. This means that, given the
 result of a parser, they will perform some function on that result, and the success of that
 function effects whether or not the parser fails.</p></div><div class="top"><p class="src"><a id="v:filterS" class="def">filterS</a> <a href="src/Text.Gigaparsec.html#filterS" class="link">Source</a> <a href="#v:filterS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>the predicate that is tested against the parser result.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser to filter, <code class="inline-code">p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that returns the result of <code class="inline-code">p</code> if it passes the predicate.</p></td></tr></table></div><div class="doc"><p>This combinator filters the result of the given parser <code class="inline-code">p</code> using the given predicate, 
succeeding only if the predicate returns <code class="inline-code">True</code>.</p><p>First, parse <code class="inline-code">p</code>. 
If it succeeds then take its result <code class="inline-code">x</code> and apply it to the predicate <code class="inline-code">pred</code>. 
If <code class="inline-code">pred x</code> is true, then return <code class="inline-code">x</code>. 
Otherwise, the combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:filterS0">Examples</h4><details id="ch:filterS0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>keywords = Set.fromList [&quot;if&quot;, &quot;then&quot;, &quot;else&quot;]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>identifier = filterS (\v -&gt; not (Set.member v keywords)) (some letter)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse identifier &quot;hello&quot;
</code></strong>Success &quot;hello&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse identifier &quot;if&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.2.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapMaybeS" class="def">mapMaybeS</a> <a href="src/Text.Gigaparsec.html#mapMaybeS" class="link">Source</a> <a href="#v:mapMaybeS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</td><td class="doc"><p>the function used to both filter the result of <code class="inline-code">p</code> and transform it.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser to filter, <code class="inline-code">p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p>a parser that returns the result of <code class="inline-code">p</code> applied to <code class="inline-code">f</code>, if it yields a value.</p></td></tr></table></div><div class="doc"><p>This combinator applies a function <code class="inline-code">f</code> to the result of the given parser <code class="inline-code">p</code>: 
if it returns a <code class="inline-code">Just y</code>, <code class="inline-code">y</code> is returned, otherwise this combinator fails.</p><p>First, parse <code class="inline-code">p</code>. If it succeeds, apply the function <code class="inline-code">f</code> to the result <code class="inline-code">x</code>. If
<code class="inline-code">f x</code> returns <code class="inline-code">Just y</code>, return <code class="inline-code">y</code>. If <code class="inline-code">f x</code> returns <code class="inline-code">Nothing</code>, or <code class="inline-code">p</code> failed
then this combinator fails. Is a more efficient way of performing a <code class="inline-code">filterS</code> and <code class="inline-code">fmap</code>
at the same time.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:mapMaybeS0">Examples</h4><details id="ch:mapMaybeS0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>int = ...
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>safeDiv = mapMaybeS (\(x, y) -&gt; if y /= 0 then Just (div x y) else Nothing) (int &lt;~&gt; (char ' ' *&gt; int))
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse safeDiv &quot;7 0&quot;
</code></strong>Failure .. -- y cannot be 0!
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse safeDiv &quot;10 2&quot;
</code></strong>Success 5
</pre></details><p><em>Since: 0.2.2.0</em></p></div></div><a href="#g:9" id="g:9"><h1>Folding Combinators</h1></a><div class="doc"><p>These combinators repeatedly execute a parser (at least zero or one times depending on the
  -- specific combinator) until it fails. The results of the successes are then combined together
  -- using a folding function. An initial value for the accumulation may be given (for the folds),
  -- or the first successful result is the initial accumulator (for the reduces). These are
  -- implemented efficiently and do not need to construct any intermediate list with which to store
  -- the results.</p></div><a href="#g:10" id="g:10"><h2>The <code>many</code> Combinators</h2></a><div class="doc"><p>The <code><a href="Text-Gigaparsec.html#v:many" title="Text.Gigaparsec">many</a></code> combinators will repeatedly parse a given parser zero or more times, and collect each result in a list.</p></div><div class="top"><p class="src"><a id="v:many" class="def">many</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f [a] <a href="#v:many" class="selflink">#</a></p><div class="doc"><p>Zero or more.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:many0">Examples</h4><details id="ch:many0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>many (putStr &quot;la&quot;)
</code></strong>lalalalalalalalala... * goes on forever *
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>many Nothing
</code></strong>Just []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 5 &lt;$&gt; many (Just 1)
</code></strong>* hangs forever *
</pre><p>Note that this function can be used with Parsers based on
 Applicatives. In that case <code class="inline-code">many parser</code> will attempt to
 parse <code class="inline-code">parser</code> zero or more times until it fails.</p></details></div></div><div class="top"><p class="src"><a id="v:manyl" class="def">manyl</a> <a href="src/Text.Gigaparsec.html#manyl" class="link">Source</a> <a href="#v:manyl" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; a -&gt; b)</td><td class="doc"><p><code class="inline-code">f</code>, function to apply to each value produced by <code class="inline-code">p</code> starting at the left.</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p><code class="inline-code">k</code>, the initial value to feed into the reduction</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the parser to repeatedly run zero or more times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p>a parser which parses <code class="inline-code">p</code> many times and folds the results together with <code class="inline-code">f</code> and <code class="inline-code">k</code> left-associatively.</p></td></tr></table></div><div class="doc"><p>This combinator will parse the given parser <strong>zero</strong> or more times combining the results with the function <code class="inline-code">f</code> and base value <code class="inline-code">k</code> from the left.</p><p>The given parser <code class="inline-code">p</code> will continue to be parsed until it fails having <strong>not consumed</strong> input.
All of the results generated by the successful parses are then combined in a left-to-right
fashion using the function <code class="inline-code">f</code>: the left-most value provided to <code class="inline-code">f</code> is the value <code class="inline-code">k</code>.</p><p>If <code class="inline-code">p</code> does fail at any point having consumed input, this combinator will fail.</p><p><em>Since: 0.3.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:manyr" class="def">manyr</a> <a href="src/Text.Gigaparsec.Internal.html#manyr" class="link">Source</a> <a href="#v:manyr" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; b -&gt; b)</td><td class="doc"><p><code class="inline-code">f</code>, function to apply to each value produced by <code class="inline-code">p</code> starting at the right.</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p><code class="inline-code">k</code>, the value to use when this parser no longer succeeds.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the parser to repeatedly run zero or more times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p>a parser which parses <code class="inline-code">p</code> many times and folds the results together with <code class="inline-code">f</code> and <code class="inline-code">k</code> right-associatively.</p></td></tr></table></div><div class="doc"><p>This combinator will parse the given parser <code class="inline-code">p</code> <strong>zero</strong> or more times,
combining the results with the function <code class="inline-code">f</code> and base value <code class="inline-code">k</code> from the right.</p><p><code class="inline-code">p</code> will continue to be parsed until it fails having <strong>not consumed</strong> input.
All of the results generated by the successful parses are then combined in a right-to-left
fashion using the function <code class="inline-code">f</code>: the right-most value provided to <code class="inline-code">f</code> is the value <code class="inline-code">k</code>.
If this parser does fail at any point having consumed input, this combinator will fail.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:manyr0">Examples</h4><details id="ch:manyr0"><summary class="hide-when-js-enabled">Expand</summary><pre>many = manyr (:) []</pre></details><p><em>Since: 0.3.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:manyMap" class="def">manyMap</a> <a href="src/Text.Gigaparsec.html#manyMap" class="link">Source</a> <a href="#v:manyMap" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; m)</td><td class="doc"><p><code class="inline-code">f</code>, injection function for parser results into a monoid</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, parser to execute multiple times</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m</td><td class="doc"><p>a parser that repeatedly parses <code class="inline-code">p</code>, converting each result to an <code class="inline-code">s</code> with <code class="inline-code">f</code>,
 ^ collecting the results together using <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a></code>.</p></td></tr></table></div><div class="doc"><p>This combinator acts like the <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Foldable.html#v:foldMap" title="Data.Foldable">foldMap</a></code> function but with a parser.</p><p>The parser <code class="inline-code">manyMap f p</code>, will parse <code class="inline-code">p</code> <strong>zero</strong> or more times, then
adapt each result with the function <code class="inline-code">f</code> to produce a bunch of values
in some <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a></code> <code class="inline-code">m</code>. These values are then combined together to form a
single value; if <code class="inline-code">p</code> could not be parsed, it will return the <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#v:mempty" title="Data.Monoid">mempty</a></code>
for <code class="inline-code">m</code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:manyMap0">Examples</h4><details id="ch:manyMap0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (manyMap Set.singleton item) &quot;aaaab&quot;
</code></strong>Success (Set.fromList ['a', 'b'])
</pre></details><p><em>Since: 0.2.2.0</em></p></div></div><a href="#g:11" id="g:11"><h2>The <code>some</code> Combinators</h2></a><div class="doc"><p>The <code><a href="Text-Gigaparsec.html#v:some" title="Text.Gigaparsec">some</a></code> combinators will repeatedly parse a given parser one or more times, and collect each result in a list.
    If successful, the list returned by these combinators is always non-empty.</p><p><em>See also:</em> <a href="Text-Gigaparsec-Combinator-NonEmpty.html">Text.Gigaparsec.Combinator.NonEmpty</a> for variants of these combinators that return a <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-List-NonEmpty.html#v:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a></code> list.</p></div><div class="top"><p class="src"><a id="v:some" class="def">some</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f [a] <a href="#v:some" class="selflink">#</a></p><div class="doc"><p>One or more.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:some0">Examples</h4><details id="ch:some0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>some (putStr &quot;la&quot;)
</code></strong>lalalalalalalalala... * goes on forever *
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>some Nothing
</code></strong>nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>take 5 &lt;$&gt; some (Just 1)
</code></strong>* hangs forever *
</pre><p>Note that this function can be used with Parsers based on
 Applicatives. In that case <code class="inline-code">some parser</code> will attempt to
 parse <code class="inline-code">parser</code> one or more times until it fails.</p></details></div></div><div class="top"><p class="src"><a id="v:somel" class="def">somel</a> <a href="src/Text.Gigaparsec.html#somel" class="link">Source</a> <a href="#v:somel" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (b -&gt; a -&gt; b)</td><td class="doc"><p><code class="inline-code">f</code>, the function to apply to each value produced by <code class="inline-code">p</code>, starting from the left.</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p><code class="inline-code">k</code>, the initial value to feed into the reduction.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code> the parser to run at least once.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p>a parser which parses <code class="inline-code">p</code> at least once, and folds the results together with <code class="inline-code">f</code> and <code class="inline-code">k</code> left-associatively.</p></td></tr></table></div><div class="doc"><p>This combinator will parse the given parser <strong>one</strong> or more times combining the results with the function <code class="inline-code">f</code> and base value <code class="inline-code">k</code> from the left.</p><p>The given parser <code class="inline-code">p</code> will continue to be parsed until it fails having <strong>not consumed</strong> input.
All of the results generated by the successful parses are then combined in a left-to-right
fashion using the function <code class="inline-code">f</code>: the left-most value provided to <code class="inline-code">f</code> is the value <code class="inline-code">k</code>.
If <code class="inline-code">p</code> fails at any point having consumed input, this combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:somel0">Examples</h4><details id="ch:somel0"><summary class="hide-when-js-enabled">Expand</summary><pre>natural = somel (\x d -&gt; x * 10 + digitToInt d) 0 digit</pre></details><p><em>Since: 0.3.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:somer" class="def">somer</a> <a href="src/Text.Gigaparsec.Internal.html#somer" class="link">Source</a> <a href="#v:somer" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (a -&gt; b -&gt; b)</td><td class="doc"><p>function to apply to each value produced by this parser, starting at the right.</p></td></tr><tr><td class="src">-&gt; b</td><td class="doc"><p><code class="inline-code">k</code>, the value to use when this parser no longer succeeds.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the parser to repeatedly run one or more times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p>a parser which parses <code class="inline-code">p</code> some times and folds the results together with <code class="inline-code">f</code> and <code class="inline-code">k</code> right-associatively.</p></td></tr></table></div><div class="doc"><p>This combinator will parse the given parser <code class="inline-code">p</code> <strong>one</strong> or more times,
combining the results with the function <code class="inline-code">f</code> and base value <code class="inline-code">k</code> from the right.</p><p><code class="inline-code">p</code> will continue to be parsed until it fails having <strong>not consumed</strong> input.
All of the results generated by the successful parses are then combined in a right-to-left
fashion using the function <code class="inline-code">f</code>: the right-most value provided to <code class="inline-code">f</code> is the value <code class="inline-code">k</code>.
If this parser does fail at any point having consumed input, this combinator will fail.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:somer0">Examples</h4><details id="ch:somer0"><summary class="hide-when-js-enabled">Expand</summary><pre>some = somer (:) []</pre></details><p><em>Since: 0.3.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:someMap" class="def">someMap</a> <a href="src/Text.Gigaparsec.html#someMap" class="link">Source</a> <a href="#v:someMap" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> s</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s)</td><td class="doc"><p><code class="inline-code">f</code>, the injection function for parser results into a monoid</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code class="inline-code">p</code>, the parser to execute multiple times</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> s</td><td class="doc"><p>a parser that parses <code class="inline-code">p</code> at least once, converting each result to an <code class="inline-code">s</code> with <code class="inline-code">f</code>,
 ^ collecting the results together using <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Monoid.html#v:-60--62-" title="Data.Monoid">&lt;&gt;</a></code>.</p></td></tr></table></div><div class="doc"><p>This combinator acts like the <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Foldable.html#v:foldMap" title="Data.Foldable">foldMap</a></code> function but with a parser.</p><p>The parser <code class="inline-code">manyMap f p</code>, will parse <code class="inline-code">p</code> <strong>one</strong> or more times, then
adapt each result with the function <code class="inline-code">f</code> to produce a bunch of values
in some <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a></code> <code class="inline-code">s</code>. These values are then combined together to form a
single value.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:someMap0">Examples</h4><details id="ch:someMap0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (someMap Max item) &quot;bdcjb&quot;
</code></strong>Success (Max 'j')
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (someMap Min item) &quot;bdcjb&quot;
</code></strong>Success (Max 'b')
</pre></details><p><em>Since: 0.2.2.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>