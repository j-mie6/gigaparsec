<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Gigaparsec</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">gigaparsec-0.2.1.0: Refreshed parsec-style library for compatiblity with Scala parsley</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Text.Gigaparsec.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>Jamie Willis, Gigaparsec Maintainers</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Gigaparsec</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Primitive Combinators</a></li><li><a href="#g:2">Consumptionless Parsers</a><ul><li><a href="#g:3">Re-exported from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html">Control.Applicative</a></a></li></ul></li><li><a href="#g:4">Result Changing Combinators</a><ul><li><a href="#g:5">Re-exported from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html">Data.Functor</a></a></li></ul></li><li><a href="#g:6">Sequencing Combinators</a><ul><li><a href="#g:7">Re-exported from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html">Control.Applicative</a></a></li></ul></li><li><a href="#g:8">Branching Combinators</a><ul><li><a href="#g:9">Re-exported from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html">Control.Applicative</a></a></li></ul></li><li><a href="#g:10">Selective Combinators</a><ul><li><a href="#g:11">Re-exported from <a href="https://hackage.haskell.org/package/selective-0.7/docs/Control-Selective.html">Control.Selective</a></a></li></ul></li><li><a href="#g:12">Filtering Combinators</a></li><li><a href="#g:13">Folding Combinators</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This object contains the core combinators and parser type: all parsers will require something from
within!</p><p>TODO: what is inside it?</p><p><em>Since: 0.1.0.0</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Parsec">Parsec</a> a</li><li class="src short"><span class="keyword">data</span> <a href="#t:Result">Result</a> e a<ul class="subs"><li>= <a href="#v:Success">Success</a> a</li><li>| <a href="#v:Failure">Failure</a> e</li></ul></li><li class="src short"><a href="#v:result">result</a> :: (e -&gt; b) -&gt; (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; b</li><li class="src short"><a href="#v:parse">parse</a> :: <span class="keyword">forall</span> err a. <a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a> err =&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> err a</li><li class="src short"><a href="#v:parseFromFile">parseFromFile</a> :: <span class="keyword">forall</span> err a. <a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a> err =&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> err a)</li><li class="src short"><a href="#v:parseRepl">parseRepl</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</li><li class="src short"><a href="#v:atomic">atomic</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:lookAhead">lookAhead</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:notFollowedBy">notFollowedBy</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:eof">eof</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:unit">unit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:pure">pure</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; a -&gt; f a</li><li class="src short"><a href="#v:empty">empty</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a</li><li class="src short"><a href="#v:-36--62-">($&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:-60--36--62-">(&lt;$&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:-60--36-">(&lt;$)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; a -&gt; f b -&gt; f a</li><li class="src short"><a href="#v:void">void</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; f a -&gt; f ()</li><li class="src short"><a href="#v:-60--126--62-">(&lt;~&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (a, b)</li><li class="src short"><a href="#v:-60-:-62-">(&lt;:&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a] -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</li><li class="src short"><a href="#v:liftA2">liftA2</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</li><li class="src short"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f b -&gt; f b</li><li class="src short"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f b -&gt; f a</li><li class="src short"><a href="#v:-60--42--42--62-">(&lt;**&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b</li><li class="src short"><a href="#v:-60--43--62-">(&lt;+&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)</li><li class="src short"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f a -&gt; f a</li><li class="src short"><a href="#v:select">select</a> :: <a href="https://hackage.haskell.org/package/selective-0.7/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> f =&gt; f (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; f (a -&gt; b) -&gt; f b</li><li class="src short"><a href="#v:branch">branch</a> :: <a href="https://hackage.haskell.org/package/selective-0.7/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> f =&gt; f (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; f (a -&gt; c) -&gt; f (b -&gt; c) -&gt; f c</li><li class="src short"><a href="#v:many">many</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f [a]</li><li class="src short"><a href="#v:some">some</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f [a]</li><li class="src short"><a href="#v:manyl">manyl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:manyr">manyr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:somel">somel</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:somer">somer</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Parsec" class="def">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.html#Parsec" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></p><div class="doc"><p>This type represents parsers as a first-class value.</p><p>Values of this type are constructed using the library's combinators, to build
up a final <code><a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></code> value that can be passed to <code><a href="Text-Gigaparsec.html#v:parse" title="Text.Gigaparsec">parse</a></code> or one
of the similar functions. This is implemented internally similar to other
libraries like <code>parsec</code> and <code>gigaparsec</code>.</p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Parsec">Instances</h4><details id="i:Parsec" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Alternative:1"></span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-132" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parsec:Alternative:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a] <a href="#v:many" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Applicative:2"></span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-67" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parsec:Applicative:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Functor:3"></span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-65" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parsec:Functor:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Monad:4"></span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-112" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parsec:Monad:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; (a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Selective:5"></span> <a href="https://hackage.haskell.org/package/selective-0.7/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a></span> <a href="src/Text.Gigaparsec.Internal.html#line-90" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parsec:Selective:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:select">select</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="#v:select" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Monoid:6"></span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m)</span> <a href="src/Text.Gigaparsec.Internal.html#line-172" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parsec:Monoid:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m] -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parsec:Semigroup:7"></span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Semigroup" title="Prelude">Semigroup</a> (<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m)</span> <a href="src/Text.Gigaparsec.Internal.html#line-166" class="link">Source</a> <a href="#t:Parsec" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parsec:Semigroup:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal.html">Text.Gigaparsec.Internal</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> m <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Result" class="def">Result</a> e a <a href="src/Text.Gigaparsec.html#Result" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></p><div class="doc"><p>Similar to <code>Either</code>, this type represents whether a parser has failed or not.</p><p>This is chosen instead of <code>Either</code> to be more specific about the naming.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Success" class="def">Success</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Failure" class="def">Failure</a> e</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Result">Instances</h4><details id="i:Result" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Result:Generic:1"></span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:Generic" title="GHC.Generics">Generic</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span> <a href="src/Text.Gigaparsec.html#line-110" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Result:Generic:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a) :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> <a href="#t:Rep" class="selflink">#</a></p></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:from">from</a> :: <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a) x <a href="#v:from" class="selflink">#</a></p><p class="src"><a href="#v:to">to</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a) x -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a <a href="#v:to" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Result:Show:2"></span> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a, <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> e) =&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span> <a href="src/Text.Gigaparsec.html#line-110" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Result:Show:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a] -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Result:Eq:3"></span> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> e) =&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span> <a href="src/Text.Gigaparsec.html#line-110" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Result:Eq:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Result:Rep:4"></span> <span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a)</span> <a href="src/Text.Gigaparsec.html#line-110" class="link">Source</a> <a href="#t:Result" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Result:Rep:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec.html">Text.Gigaparsec</a></p> <div class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:Rep" title="GHC.Generics">Rep</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a) = <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:D1" title="GHC.Generics">D1</a> ('<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:MetaData" title="GHC.Generics">MetaData</a> &quot;Result&quot; &quot;Text.Gigaparsec&quot; &quot;gigaparsec-0.2.1.0-inplace&quot; '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> &quot;Success&quot; '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-TypeLits.html#t:Symbol" title="GHC.TypeLits">Symbol</a>) '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:Rec0" title="GHC.Generics">Rec0</a> a)) <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t::-43-:" title="GHC.Generics">:+:</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:C1" title="GHC.Generics">C1</a> ('<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:MetaCons" title="GHC.Generics">MetaCons</a> &quot;Failure&quot; '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:PrefixI" title="GHC.Generics">PrefixI</a> '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a>) (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:S1" title="GHC.Generics">S1</a> ('<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:MetaSel" title="GHC.Generics">MetaSel</a> ('<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-TypeLits.html#t:Symbol" title="GHC.TypeLits">Symbol</a>) '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:NoSourceUnpackedness" title="GHC.Generics">NoSourceUnpackedness</a> '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:NoSourceStrictness" title="GHC.Generics">NoSourceStrictness</a> '<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#v:DecidedLazy" title="GHC.Generics">DecidedLazy</a>) (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/GHC-Generics.html#t:Rec0" title="GHC.Generics">Rec0</a> e)))</div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:result" class="def">result</a> :: (e -&gt; b) -&gt; (a -&gt; b) -&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> e a -&gt; b <a href="src/Text.Gigaparsec.html#result" class="link">Source</a> <a href="#v:result" class="selflink">#</a></p><div class="doc"><p>A fold for the <code><a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a></code> type.</p><p>This functions like the <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#v:either" title="Data.Either">either</a></code> function does for <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code>.</p><p><em>Since: 0.2.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:parse" class="def">parse</a> <a href="src/Text.Gigaparsec.html#parse" class="link">Source</a> <a href="#v:parse" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> err a. <a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a> err</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser to execute</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>the input to parse</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> err a</td><td class="doc"><p>result of the parse, either an error or result</p></td></tr></table></div><div class="doc"><p>Runs a parser against some input.</p><p>Given a parser, some input, and a way of producing parse errors of a desired
type (via <code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a></code>), this function runs a parser to produce either a
successful result or an error. Note that the <code>err</code> type parameter is first,
which allows for <code>parse @String</code> to make use of the defaultly formated <code>String</code>
error messages. This may not be required if it is clear from context. To make
this process nicer within GHCi, consider using <code><a href="Text-Gigaparsec.html#v:parseRepl" title="Text.Gigaparsec">parseRepl</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:parseFromFile" class="def">parseFromFile</a> <a href="src/Text.Gigaparsec.html#parseFromFile" class="link">Source</a> <a href="#v:parseFromFile" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> err a. <a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a> err</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser to execute</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#t:FilePath" title="System.IO">FilePath</a></td><td class="doc"><p>the file to source the input from</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> (<a href="Text-Gigaparsec.html#t:Result" title="Text.Gigaparsec">Result</a> err a)</td><td class="doc"><p>the result of the parse, error or otherwise</p></td></tr></table></div><div class="doc"><p>Runs a parser against some input obtained from a given file.</p><p>Given a parser, a filename, and a way of producing parse errors of a desired
type (via <code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a></code>), this function runs a parser to produce either a
successful result or an error. First, input is collected by reading the file,
and then the result is returned within <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></code>; the filename is forwarded on to
the <code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#t:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a></code>, which may mean it forms part of the generated error messages.</p><p>Note that the <code>err</code> type parameter is first,
which allows for <code>parseFromFile @String</code> to make use of the defaultly formated <code>String</code>
error messages. This may not be required if it is clear from context.</p><p><em>Since: 0.2.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:parseRepl" class="def">parseRepl</a> <a href="src/Text.Gigaparsec.html#parseRepl" class="link">Source</a> <a href="#v:parseRepl" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser to execute</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>the input to parse</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Runs a parser against some input, pretty-printing the result to the terminal.</p><p>Compared, with <code><a href="Text-Gigaparsec.html#v:parse" title="Text.Gigaparsec">parse</a></code>, this function will always generate error messages as
strings and will print them nicely to the terminal (on multiple lines). If the
parser succeeds, the result will also be printed to the terminal. This is useful
for playing around with parsers in GHCi, seeing the results more clearly.</p><p><em>Since: 0.2.0.0</em></p></div></div><a href="#g:1" id="g:1"><h1>Primitive Combinators</h1></a><div class="doc"><p>These combinators are specific to parser combinators. In one way or another, they influence
 how a parser consumes input, or under what conditions a parser does or does not fail. These are
 really important for most practical parsing considerations, although lookAhead is much less
 well used.</p></div><div class="top"><p class="src"><a id="v:atomic" class="def">atomic</a> <a href="src/Text.Gigaparsec.html#atomic" class="link">Source</a> <a href="#v:atomic" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser, <code>p</code>, to execute, if it fails, it will not have consumed input.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that tries <code>p</code>, but never consumes input if it fails.</p></td></tr></table></div><div class="doc"><p>This combinator parses its argument <code>p</code>, but rolls back any consumed input on failure.</p><p>If the parser <code>p</code> succeeds, then <code>atomic p</code> has no effect. However, if <code>p</code> failed,
then any input that it consumed is rolled back. This has two uses: it ensures that
the parser <code>p</code> is all-or-nothing when consuming input, and it allows for
parsers that consume input to backtrack when they fail (with <code><a href="Text-Gigaparsec.html#v:-60--124--62-" title="Text.Gigaparsec">(&lt;|&gt;)</a></code>). It should be
used for the latter purpose sparingly, however, since excessive backtracking in a
parser can result in much lower efficiency.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (string &quot;abc&quot; &lt;|&gt; string &quot;abd&quot;) &quot;abd&quot;
</code></strong>Failure .. -- first parser consumed a, so no backtrack
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (atomic (string &quot;abc&quot;) &lt;|&gt; string &quot;abd&quot;) &quot;abd&quot;
</code></strong>Success &quot;abd&quot; -- first parser does not consume input on failure now
</pre><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:lookAhead" class="def">lookAhead</a> <a href="src/Text.Gigaparsec.html#lookAhead" class="link">Source</a> <a href="#v:lookAhead" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser, <code>p</code>, to execute</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that parses <code>p</code> and never consumes input if it succeeds.</p></td></tr></table></div><div class="doc"><p>This combinator parses its argument <code>p</code>, but does not consume input if it succeeds.</p><p>If the parser <code>p</code> succeeds, then <code>lookAhead p</code> will roll back any input consumed
whilst parsing <code>p</code>. If <code>p</code> fails, however, then the whole combinator fails and
any input consumed <strong>remains consumed</strong>. If this behaviour is not desirable,
consider pairing <code><a href="Text-Gigaparsec.html#v:lookAhead" title="Text.Gigaparsec">lookAhead</a></code> with <code><a href="Text-Gigaparsec.html#v:atomic" title="Text.Gigaparsec">atomic</a></code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:lookAhead0">Examples</h4><details id="ch:lookAhead0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (lookAhead (string &quot;aaa&quot;) *&gt; string &quot;aaa&quot;) &quot;aaa&quot;
</code></strong>Success &quot;aaa&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse (lookAhead (string &quot;abc&quot;) &lt;|&gt; string &quot;abd&quot; &quot;abd&quot;
</code></strong>Failure .. -- lookAhead does not roll back input consumed on failure
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:notFollowedBy" class="def">notFollowedBy</a> <a href="src/Text.Gigaparsec.html#notFollowedBy" class="link">Source</a> <a href="#v:notFollowedBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser, <code>p</code>, to execute, it must fail in order for this combinator to succeed.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p>a parser which fails when <code>p</code> succeeds and succeeds otherwise, never consuming input.</p></td></tr></table></div><div class="doc"><p>This combinator parses its argument <code>p</code>, and succeeds when <code>p</code> fails and vice-versa, never consuming
input.</p><p>If the parser <code>p</code> succeeds, then <code>notFollowedBy p</code> will fail, consuming no input.
Otherwise, should <code>p</code> fail, then <code>notFollowedBy p</code> will succeed, consuming no input
and returning <code>()</code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:notFollowedBy0">Examples</h4><details id="ch:notFollowedBy0"><summary class="hide-when-js-enabled">Expand</summary><p>One use for this combinator is to allow for &quot;longest-match&quot; behaviour.
For instance, keywords are normally only considered keywords if they are not
part of some larger valid identifier (i.e. the keyword &quot;if&quot; should not parse
successfully given &quot;ifp&quot;). This can be accomplished as follows:</p><pre>keyword :: String -&gt; Parsec ()
keyword kw = atomic $ string kw *&gt; notFollowedBy letterOrDigit
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:eof" class="def">eof</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.html#eof" class="link">Source</a> <a href="#v:eof" class="selflink">#</a></p></div><a href="#g:2" id="g:2"><h1>Consumptionless Parsers</h1></a><div class="doc"><p>These combinators and parsers do not consume input: they are the most primitive ways of
 producing successes and failures with the minimal possible effect on the parse. They are,
 however, reasonably useful; in particular, <code><a href="Text-Gigaparsec.html#v:pure" title="Text.Gigaparsec">pure</a></code> and <code><a href="Text-Gigaparsec.html#v:unit" title="Text.Gigaparsec">unit</a></code> can be put to good use in
 injecting results into a parser without needing to consume anything, or mapping another parser.</p></div><div class="top"><p class="src"><a id="v:unit" class="def">unit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.html#unit" class="link">Source</a> <a href="#v:unit" class="selflink">#</a></p><div class="doc"><p>This parser produces <code>()</code> without having any other effect.</p><p>When this parser is ran, no input is required, nor consumed, and the given value will always be
successfully returned. It has no other effect on the state of the parser.</p><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:3" id="g:3"><h3>Re-exported from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html">Control.Applicative</a></h3></a><div class="top"><p class="src"><a id="v:pure" class="def">pure</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; a -&gt; f a <a href="#v:pure" class="selflink">#</a></p><div class="doc"><p>Lift a value.</p></div></div><div class="top"><p class="src"><a id="v:empty" class="def">empty</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a <a href="#v:empty" class="selflink">#</a></p><div class="doc"><p>The identity of <code><a href="Text-Gigaparsec.html#v:-60--124--62-" title="Text.Gigaparsec">&lt;|&gt;</a></code></p></div></div><a href="#g:4" id="g:4"><h1>Result Changing Combinators</h1></a><div class="doc"><p>These combinators change the result of the parser they are called on into a value of a
 different type. This new result value may or may not be derived from the previous result.</p></div><div class="top"><p class="src"><a id="v:-36--62-" class="def">($&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/Text.Gigaparsec.html#%24%3E" class="link">Source</a> <a href="#v:-36--62-" class="selflink">#</a></p></div><a href="#g:5" id="g:5"><h3>Re-exported from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html">Data.Functor</a></h3></a><div class="top"><p class="src"><a id="v:-60--36--62-" class="def">(&lt;$&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--36--62-" class="selflink">#</a></p><div class="doc"><p>An infix synonym for <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code>.</p><p>The name of this operator is an allusion to <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:-36-" title="Prelude">$</a></code>.
 Note the similarities between their types:</p><pre> ($)  ::              (a -&gt; b) -&gt;   a -&gt;   b
(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</pre><p>Whereas <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:-36-" title="Prelude">$</a></code> is function application, <code><a href="Text-Gigaparsec.html#v:-60--36--62-" title="Text.Gigaparsec">&lt;$&gt;</a></code> is function
 application lifted over a <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a></code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--36--62-0">Examples</h4><details id="ch:-60--36--62-0"><summary class="hide-when-js-enabled">Expand</summary><p>Convert from a <code><code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#v:Maybe" title="Data.Maybe">Maybe</a></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code> to a <code><code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#v:Maybe" title="Data.Maybe">Maybe</a></code>
 <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-String.html#v:String" title="Data.String">String</a></code></code> using <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:show" title="Prelude">show</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>show &lt;$&gt; Nothing
</code></strong>Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>show &lt;$&gt; Just 3
</code></strong>Just &quot;3&quot;
</pre><p>Convert from an <code><code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#v:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code> to an
 <code><code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#v:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-String.html#v:String" title="Data.String">String</a></code> using <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:show" title="Prelude">show</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>show &lt;$&gt; Left 17
</code></strong>Left 17
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>show &lt;$&gt; Right 17
</code></strong>Right &quot;17&quot;
</pre><p>Double each element of a list:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>(*2) &lt;$&gt; [1,2,3]
</code></strong>[2,4,6]
</pre><p>Apply <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Prelude.html#v:even" title="Prelude">even</a></code> to the second element of a pair:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>even &lt;$&gt; (2,2)
</code></strong>(2,True)
</pre></details></div></div><div class="top"><p class="src"><a id="v:-60--36-" class="def">(&lt;$)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; a -&gt; f b -&gt; f a <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--36-" class="selflink">#</a></p><div class="doc"><p>Replace all locations in the input with the same value.
 The default definition is <code><code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code> . <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Function.html#v:const" title="Data.Function">const</a></code></code>, but this may be
 overridden with a more efficient version.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--36-0">Examples</h4><details id="ch:-60--36-0"><summary class="hide-when-js-enabled">Expand</summary><p>Perform a computation with <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> and replace the result with a
 constant value if it is <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>'a' &lt;$ Just 2
</code></strong>Just 'a'
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>'a' &lt;$ Nothing
</code></strong>Nothing
</pre></details></div></div><div class="top"><p class="src"><a id="v:void" class="def">void</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; f a -&gt; f () <a href="#v:void" class="selflink">#</a></p><div class="doc"><p><code><code><a href="Text-Gigaparsec.html#v:void" title="Text.Gigaparsec">void</a></code> value</code> discards or ignores the result of evaluation, such
 as the return value of an <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#v:IO" title="System.IO">IO</a></code> action.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:void0">Examples</h4><details id="ch:void0"><summary class="hide-when-js-enabled">Expand</summary><p>Replace the contents of a <code><code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#v:Maybe" title="Data.Maybe">Maybe</a></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code> with unit:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void Nothing
</code></strong>Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void (Just 3)
</code></strong>Just ()
</pre><p>Replace the contents of an <code><code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#v:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code></code>
 with unit, resulting in an <code><code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#v:Either" title="Data.Either">Either</a></code> <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#v:Int" title="Data.Int">Int</a></code> <code>()</code></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void (Left 8675309)
</code></strong>Left 8675309
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void (Right 8675309)
</code></strong>Right ()
</pre><p>Replace every element of a list with unit:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void [1,2,3]
</code></strong>[(),(),()]
</pre><p>Replace the second element of a pair with unit:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void (1,2)
</code></strong>(1,())
</pre><p>Discard the result of an <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/System-IO.html#v:IO" title="System.IO">IO</a></code> action:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mapM print [1,2]
</code></strong>1
2
[(),()]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>void $ mapM print [1,2]
</code></strong>1
2
</pre></details></div></div><a href="#g:6" id="g:6"><h1>Sequencing Combinators</h1></a><div class="doc"><p>These combinators all combine two parsers in sequence. The first argument of the combinator
 will be executed first, then the second argument second. The results of both parsers are
 combined in some way (depending on the individual combinator). If one of the parsers fails, the
 combinator as a whole fails.</p></div><div class="top"><p class="src"><a id="v:-60--126--62-" class="def">(&lt;~&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (a, b) <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/Text.Gigaparsec.html#%3C~%3E" class="link">Source</a> <a href="#v:-60--126--62-" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:-60-:-62-" class="def">(&lt;:&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a] -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a] <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="src/Text.Gigaparsec.html#%3C%3A%3E" class="link">Source</a> <a href="#v:-60-:-62-" class="selflink">#</a></p></div><a href="#g:7" id="g:7"><h3>Re-exported from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html">Control.Applicative</a></h3></a><div class="top"><p class="src"><a id="v:-60--42--62-" class="def">(&lt;*&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--42--62-" class="selflink">#</a></p><div class="doc"><p>Sequential application.</p><p>A few functors support an implementation of <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code> that is more
 efficient than the default one.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-60--42--62-0">Example</h4><details id="ch:-60--42--62-0"><summary class="hide-when-js-enabled">Expand</summary><p>Used in combination with <code>(<code>&lt;$&gt;</code>)</code>, <code>(<code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code>)</code> can be used to build a record.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>data MyState = MyState {arg1 :: Foo, arg2 :: Bar, arg3 :: Baz}
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>produceFoo :: Applicative f =&gt; f Foo
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>produceBar :: Applicative f =&gt; f Bar
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>produceBaz :: Applicative f =&gt; f Baz
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mkState :: Applicative f =&gt; f MyState
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>mkState = MyState &lt;$&gt; produceFoo &lt;*&gt; produceBar &lt;*&gt; produceBaz
</code></strong></pre></details></div></div><div class="top"><p class="src"><a id="v:liftA2" class="def">liftA2</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c <a href="#v:liftA2" class="selflink">#</a></p><div class="doc"><p>Lift a binary function to actions.</p><p>Some functors support an implementation of <code><a href="Text-Gigaparsec.html#v:liftA2" title="Text.Gigaparsec">liftA2</a></code> that is more
 efficient than the default one. In particular, if <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code> is an
 expensive operation, it is likely better to use <code><a href="Text-Gigaparsec.html#v:liftA2" title="Text.Gigaparsec">liftA2</a></code> than to
 <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code> over the structure and then use <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code>.</p><p>This became a typeclass method in 4.10.0.0. Prior to that, it was
 a function defined in terms of <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:liftA20">Example</h4><details id="ch:liftA20"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>liftA2 (,) (Just 3) (Just 5)
</code></strong>Just (3,5)
</pre></details></div></div><div class="top"><p class="src"><a id="v:-42--62-" class="def">(*&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f b -&gt; f b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-42--62-" class="selflink">#</a></p><div class="doc"><p>Sequence actions, discarding the value of the first argument.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:-42--62-0">Examples</h4><details id="ch:-42--62-0"><summary class="hide-when-js-enabled">Expand</summary><p>If used in conjunction with the Applicative instance for <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code>,
 you can chain Maybe computations, with a possible &quot;early return&quot;
 in case of <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Just 2 *&gt; Just 3
</code></strong>Just 3
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>Nothing *&gt; Just 3
</code></strong>Nothing
</pre><p>Of course a more interesting use case would be to have effectful
 computations instead of just returning pure values.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Data.Char
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>import Text.ParserCombinators.ReadP
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = string &quot;my name is &quot; *&gt; munch1 isAlpha &lt;* eof
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>readP_to_S p &quot;my name is Simon&quot;
</code></strong>[(&quot;Simon&quot;,&quot;&quot;)]
</pre></details></div></div><div class="top"><p class="src"><a id="v:-60--42-" class="def">(&lt;*)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f b -&gt; f a <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--42-" class="selflink">#</a></p><div class="doc"><p>Sequence actions, discarding the value of the second argument.</p></div></div><div class="top"><p class="src"><a id="v:-60--42--42--62-" class="def">(&lt;**&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b <span class="fixity">infixl 4</span><span class="rightedge"></span> <a href="#v:-60--42--42--62-" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="Text-Gigaparsec.html#v:-60--42--62-" title="Text.Gigaparsec">&lt;*&gt;</a></code> with the arguments reversed.</p></div></div><a href="#g:8" id="g:8"><h1>Branching Combinators</h1></a><div class="doc"><p>These combinators allow for parsing one alternative or another. All of these combinators are
 <em>left-biased</em>, which means that the left-hand side of the combinator is tried first: the
 right-hand side of the combinator will only be tried when the left-hand one failed (and did not
 consume input in the process).</p></div><div class="top"><p class="src"><a id="v:-60--43--62-" class="def">(&lt;+&gt;)</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="src/Text.Gigaparsec.html#%3C%2B%3E" class="link">Source</a> <a href="#v:-60--43--62-" class="selflink">#</a></p></div><a href="#g:9" id="g:9"><h3>Re-exported from <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html">Control.Applicative</a></h3></a><div class="top"><p class="src"><a id="v:-60--124--62-" class="def">(&lt;|&gt;)</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f a -&gt; f a <span class="fixity">infixl 3</span><span class="rightedge"></span> <a href="#v:-60--124--62-" class="selflink">#</a></p><div class="doc"><p>An associative binary operation</p></div></div><a href="#g:10" id="g:10"><h1>Selective Combinators</h1></a><div class="doc"><p>These combinators will decide which branch to take next based on the result of another parser.
 This differs from combinators like <code><a href="Text-Gigaparsec.html#v:-60--124--62-" title="Text.Gigaparsec">(&lt;|&gt;)</a></code> which make decisions based on the success/failure of
 a parser: here the result of a <em>successful</em> parse will direct which option is done.</p></div><a href="#g:11" id="g:11"><h3>Re-exported from <a href="https://hackage.haskell.org/package/selective-0.7/docs/Control-Selective.html">Control.Selective</a></h3></a><div class="top"><p class="src"><a id="v:select" class="def">select</a> :: <a href="https://hackage.haskell.org/package/selective-0.7/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> f =&gt; f (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; f (a -&gt; b) -&gt; f b <a href="#v:select" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:branch" class="def">branch</a> :: <a href="https://hackage.haskell.org/package/selective-0.7/docs/Control-Selective.html#t:Selective" title="Control.Selective">Selective</a> f =&gt; f (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; f (a -&gt; c) -&gt; f (b -&gt; c) -&gt; f c <a href="#v:branch" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Text-Gigaparsec.html#v:branch" title="Text.Gigaparsec">branch</a></code> function is a natural generalisation of <code><a href="Text-Gigaparsec.html#v:select" title="Text.Gigaparsec">select</a></code>: instead of
 skipping an unnecessary effect, it chooses which of the two given effectful
 functions to apply to a given argument; the other effect is unnecessary. It
 is possible to implement <code><a href="Text-Gigaparsec.html#v:branch" title="Text.Gigaparsec">branch</a></code> in terms of <code><a href="Text-Gigaparsec.html#v:select" title="Text.Gigaparsec">select</a></code>, which is a good
 puzzle (give it a try!).</p><p>We can also implement <code><a href="Text-Gigaparsec.html#v:select" title="Text.Gigaparsec">select</a></code> via <code><a href="Text-Gigaparsec.html#v:branch" title="Text.Gigaparsec">branch</a></code>:</p><pre>selectB :: Selective f =&gt; f (Either a b) -&gt; f (a -&gt; b) -&gt; f b
selectB x y = branch x y (pure id)
</pre></div></div><a href="#g:12" id="g:12"><h1>Filtering Combinators</h1></a><div class="doc"><p>These combinators perform filtering on the results of a parser. This means that, given the
 result of a parser, they will perform some function on that result, and the success of that
 function effects whether or not the parser fails.</p></div><a href="#g:13" id="g:13"><h1>Folding Combinators</h1></a><div class="doc"><p>These combinators repeatedly execute a parser (at least zero or one times depending on the
 specific combinator) until it fails. The results of the successes are then combined together
 using a folding function. An initial value for the accumulation may be given (for the folds),
 or the first successful result is the initial accumulator (for the reduces). These are
 implemented efficiently and do not need to construct any intermediate list with which to store
 the results.</p></div><div class="top"><p class="src"><a id="v:many" class="def">many</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f [a] <a href="#v:many" class="selflink">#</a></p><div class="doc"><p>Zero or more.</p></div></div><div class="top"><p class="src"><a id="v:some" class="def">some</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> f =&gt; f a -&gt; f [a] <a href="#v:some" class="selflink">#</a></p><div class="doc"><p>One or more.</p></div></div><div class="top"><p class="src"><a id="v:manyl" class="def">manyl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="src/Text.Gigaparsec.html#manyl" class="link">Source</a> <a href="#v:manyl" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:manyr" class="def">manyr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="src/Text.Gigaparsec.Internal.html#manyr" class="link">Source</a> <a href="#v:manyr" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:somel" class="def">somel</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="src/Text.Gigaparsec.html#somel" class="link">Source</a> <a href="#v:somel" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:somer" class="def">somer</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b <a href="src/Text.Gigaparsec.Internal.html#somer" class="link">Source</a> <a href="#v:somer" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>