<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Gigaparsec.Token.Lexer</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">gigaparsec</span><ul class="links" id="page-menu"><li><a href="src/Text.Gigaparsec.Token.Lexer.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>Jamie Willis, Gigaparsec Maintainers</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Gigaparsec.Token.Lexer</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Lexing</a></li><li><a href="#g:2">Lexemes and Non-Lexemes</a><ul><li><a href="#g:3">Lexemes</a></li><li><a href="#g:4">Non-Lexemes</a></li><li><a href="#g:5">Fully and Space</a></li><li><a href="#g:6"><code>Lexeme</code> Fields</a></li></ul></li><li><a href="#g:7">Symbolic Tokens</a></li><li><a href="#g:8">Name Tokens</a></li><li><a href="#g:9">Numeric Tokens</a><ul><li><a href="#g:10">Integer Parsers</a><ul><li><a href="#g:11">Fixed-Base Parsers</a></li><li><a href="#g:12">Fixed-Width Numeric Tokens</a><ul><li><a href="#g:13">Decimal Tokens</a></li><li><a href="#g:14">Hexadecimal Tokens</a></li><li><a href="#g:15">Octal Tokens</a></li><li><a href="#g:16">Binary Tokens</a></li></ul></li></ul></li></ul></li><li><a href="#g:17">Textual Tokens</a><ul><li><a href="#g:18">String Parsers</a></li><li><a href="#g:19">Character Parsers</a></li></ul></li><li><a href="#g:20">Whitespace and Comments</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides a large selection of functionality concerned with lexing.</p><p>In traditional compilers, lexing and parsing are two largely separate processes;
lexing turns raw input into a series of tokens, and parsing then processes these tokens.
Parser combinators, on the other hand, are often implemented to deal directly with the input stream.</p><p>Nonetheless, a lexer abstraction may be achieved by defining a core set of <em>lexing</em> combinators that convert input to tokens,
and then defining the <em>parsing</em> combinators in terms of these.
The parsers defined using <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code> construct these <em>lexing</em> combinators, which creates a clear and logical separation from the rest of the parser.</p><p>It is possible that some of the implementations of parsers found within this class may have been hand-optimised for performance:
care will have been taken to ensure these implementations precisely match the semantics of the originals.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Lexer">Lexer</a></li><li class="src short"><a href="#v:mkLexer">mkLexer</a> :: <a href="Text-Gigaparsec-Token-Descriptions.html#t:LexicalDesc" title="Text.Gigaparsec.Token.Descriptions">LexicalDesc</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></li><li class="src short"><a href="#v:mkLexerWithErrorConfig">mkLexerWithErrorConfig</a> :: <a href="Text-Gigaparsec-Token-Descriptions.html#t:LexicalDesc" title="Text.Gigaparsec.Token.Descriptions">LexicalDesc</a> -&gt; <a href="Text-Gigaparsec-Token-Errors.html#t:ErrorConfig" title="Text.Gigaparsec.Token.Errors">ErrorConfig</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></li><li class="src short"><a href="#v:lexeme">lexeme</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a></li><li class="src short"><a href="#v:nonlexeme">nonlexeme</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a></li><li class="src short"><a href="#v:fully">fully</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a> -&gt; <span class="keyword">forall</span> a. <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:space">space</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Lexeme">Lexeme</a></li><li class="src short"><a href="#v:apply">apply</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <span class="keyword">forall</span> a. <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:sym">sym</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:symbol">symbol</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Symbol" title="Text.Gigaparsec.Token.Lexer">Symbol</a></li><li class="src short"><a href="#v:names">names</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Symbol">Symbol</a></li><li class="src short"><a href="#v:softKeyword">softKeyword</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Symbol" title="Text.Gigaparsec.Token.Lexer">Symbol</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:softOperator">softOperator</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Symbol" title="Text.Gigaparsec.Token.Lexer">Symbol</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><span class="keyword">data</span> <a href="#t:Names">Names</a></li><li class="src short"><a href="#v:identifier">identifier</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:identifier-39-">identifier'</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> -&gt; <a href="Text-Gigaparsec-Token-Descriptions.html#t:CharPredicate" title="Text.Gigaparsec.Token.Descriptions">CharPredicate</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:userDefinedOperator">userDefinedOperator</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:userDefinedOperator-39-">userDefinedOperator'</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> -&gt; <a href="Text-Gigaparsec-Token-Descriptions.html#t:CharPredicate" title="Text.Gigaparsec.Token.Descriptions">CharPredicate</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CanHoldSigned">CanHoldSigned</a> = CanHoldSigned</li><li class="src short"><span class="keyword">type</span> <a href="#t:CanHoldUnsigned">CanHoldUnsigned</a> = CanHoldUnsigned</li><li class="src short"><span class="keyword">data</span> <a href="#t:IntegerParsers">IntegerParsers</a> (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>)</li><li class="src short"><a href="#v:integer">integer</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> CanHoldSigned</li><li class="src short"><a href="#v:natural">natural</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> CanHoldUnsigned</li><li class="src short"><a href="#v:decimal">decimal</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li class="src short"><a href="#v:hexadecimal">hexadecimal</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li class="src short"><a href="#v:octal">octal</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li class="src short"><a href="#v:binary">binary</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></li><li class="src short"><a href="#v:decimal8">decimal8</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B8" title="Text.Gigaparsec.Token.Errors">B8</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:decimal16">decimal16</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B16" title="Text.Gigaparsec.Token.Errors">B16</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:decimal32">decimal32</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B32" title="Text.Gigaparsec.Token.Errors">B32</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:decimal64">decimal64</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B64" title="Text.Gigaparsec.Token.Errors">B64</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:hexadecimal8">hexadecimal8</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B8" title="Text.Gigaparsec.Token.Errors">B8</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:hexadecimal16">hexadecimal16</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B16" title="Text.Gigaparsec.Token.Errors">B16</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:hexadecimal32">hexadecimal32</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B32" title="Text.Gigaparsec.Token.Errors">B32</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:hexadecimal64">hexadecimal64</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B64" title="Text.Gigaparsec.Token.Errors">B64</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:octal8">octal8</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B8" title="Text.Gigaparsec.Token.Errors">B8</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:octal16">octal16</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B16" title="Text.Gigaparsec.Token.Errors">B16</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:octal32">octal32</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B32" title="Text.Gigaparsec.Token.Errors">B32</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:octal64">octal64</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B64" title="Text.Gigaparsec.Token.Errors">B64</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:binary8">binary8</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B8" title="Text.Gigaparsec.Token.Errors">B8</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:binary16">binary16</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B16" title="Text.Gigaparsec.Token.Errors">B16</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:binary32">binary32</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B32" title="Text.Gigaparsec.Token.Errors">B32</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:binary64">binary64</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B64" title="Text.Gigaparsec.Token.Errors">B64</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><span class="keyword">data</span> <a href="#t:TextParsers">TextParsers</a> t</li><li class="src short"><a href="#v:ascii">ascii</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> t -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> t</li><li class="src short"><a href="#v:unicode">unicode</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> t -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> t</li><li class="src short"><a href="#v:latin1">latin1</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> t -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> t</li><li class="src short"><a href="#v:stringLiteral">stringLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:rawStringLiteral">rawStringLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:multiStringLiteral">multiStringLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:rawMultiStringLiteral">rawMultiStringLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:charLiteral">charLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Space">Space</a></li><li class="src short"><a href="#v:skipComments">skipComments</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:whiteSpace">whiteSpace</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:alter">alter</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> -&gt; <span class="keyword">forall</span> a. <a href="Text-Gigaparsec-Token-Descriptions.html#t:CharPredicate" title="Text.Gigaparsec.Token.Descriptions">CharPredicate</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:initSpace">initSpace</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h2>Lexing</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Lexer" class="def">Lexer</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#Lexer" class="link">Source</a> <a href="#t:Lexer" class="selflink">#</a></p><div class="doc"><p>A lexer describes how to transform the input string into a series of tokens.</p></div></div><div class="top"><p class="src"><a id="v:mkLexer" class="def">mkLexer</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#mkLexer" class="link">Source</a> <a href="#v:mkLexer" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec-Token-Descriptions.html#t:LexicalDesc" title="Text.Gigaparsec.Token.Descriptions">LexicalDesc</a></td><td class="doc"><p>The description of the lexical structure of the language.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></td><td class="doc"><p>A lexer which can convert the input stream into a series of lexemes.</p></td></tr></table></div><div class="doc"><p>Create a <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code> with a given description for the lexical structure of the language.</p></div></div><div class="top"><p class="src"><a id="v:mkLexerWithErrorConfig" class="def">mkLexerWithErrorConfig</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#mkLexerWithErrorConfig" class="link">Source</a> <a href="#v:mkLexerWithErrorConfig" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec-Token-Descriptions.html#t:LexicalDesc" title="Text.Gigaparsec.Token.Descriptions">LexicalDesc</a></td><td class="doc"><p>The description of the lexical structure of the language.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Token-Errors.html#t:ErrorConfig" title="Text.Gigaparsec.Token.Errors">ErrorConfig</a></td><td class="doc"><p>The description of how to process errors during lexing.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></td><td class="doc"><p>A lexer which can convert the input stream into a series of lexemes.</p></td></tr></table></div><div class="doc"><p>Create a <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code> with a given description for the lexical structure of the language, 
which reports errors according to the given error config.</p></div></div><a href="#g:2" id="g:2"><h2>Lexemes and Non-Lexemes</h2></a><div class="doc"><p>A key distinction in lexers is between lexemes and non-lexemes:</p><ul><li><code><a href="Text-Gigaparsec-Token-Lexer.html#v:lexeme" title="Text.Gigaparsec.Token.Lexer">lexeme</a></code> consumes whitespace.
    It should be used by a wider parser, to ensure whitespace is handled uniformly.
    The output of <code><a href="Text-Gigaparsec-Token-Lexer.html#v:lexeme" title="Text.Gigaparsec.Token.Lexer">lexeme</a></code> can be considered a <em>token</em> as provided by traditional lexers, and can be used by the parser.</li><li><code><a href="Text-Gigaparsec-Token-Lexer.html#v:nonlexeme" title="Text.Gigaparsec.Token.Lexer">nonlexeme</a></code> does not consume whitespace.
    It should be used to define further composite tokens or in special circumstances where whitespace should not be consumed.
    One may consider the output of <code><a href="Text-Gigaparsec-Token-Lexer.html#v:nonlexeme" title="Text.Gigaparsec.Token.Lexer">nonlexeme</a></code> to still be in the <em>lexing</em> stage of parsing, and not necessarily a valid token.</li></ul></div><a href="#g:3" id="g:3"><h3>Lexemes</h3></a><div class="doc"><p>Ideally, a wider parser should not be concerned with handling whitespace,
    as it is responsible for dealing with a stream of tokens.
    With parser combinators, however, it is usually not the case that there is a separate distinction between the parsing phase and the lexing phase.
    That said, it is good practice to establish a logical separation between the two worlds.
    As such, <code><a href="Text-Gigaparsec-Token-Lexer.html#v:lexeme" title="Text.Gigaparsec.Token.Lexer">lexeme</a></code> contains parsers that parse tokens, and these are whitespace-aware.
    This means that whitespace will be consumed after any of these parsers are parsed.
    It is not required that whitespace be present.</p></div><div class="top"><p class="src"><a id="v:lexeme" class="def">lexeme</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#lexeme" class="link">Source</a> <a href="#v:lexeme" class="selflink">#</a></p><div class="doc"><p>This contains parsers for tokens treated as &quot;words&quot;, 
 such that whitespace will be consumed after each token has been parsed.</p></div></div><a href="#g:4" id="g:4"><h3>Non-Lexemes</h3></a><div class="doc"><p>Whilst the functionality in lexeme is strongly recommended for wider use in a parser, the functionality here may be useful for more specialised use-cases.
    In particular, these may for the building blocks for more complex tokens (where whitespace is not allowed between them, say),
    in which case these compound tokens can be turned into lexemes manually.</p><p>For example, the lexer does not have configuration for trailing specifiers on numeric literals (like, 1024L in Scala, say):
    the desired numeric literal parser could be extended with this functionality before whitespace is consumed by using the variant found in this object.</p><p>These tokens can also be used for lexical extraction,
    which can be performed by the ErrorBuilder typeclass:
    this can be used to try and extract tokens from the input stream when an error happens,
    to provide a more informative error.
    In this case, it is desirable to not consume whitespace after the token to keep
    the error tight and precise.</p></div><div class="top"><p class="src"><a id="v:nonlexeme" class="def">nonlexeme</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#nonlexeme" class="link">Source</a> <a href="#v:nonlexeme" class="selflink">#</a></p><div class="doc"><p>This contains parsers for tokens that do not give any special treatment to whitespace.</p></div></div><a href="#g:5" id="g:5"><h3>Fully and Space</h3></a><div class="top"><p class="src"><a id="v:fully" class="def">fully</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a> -&gt; <span class="keyword">forall</span> a. <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#fully" class="link">Source</a> <a href="#v:fully" class="selflink">#</a></p><div class="doc"><p>This combinator ensures a parser fully parses all available input, and consumes whitespace at the start.</p></div></div><div class="top"><p class="src"><a id="v:space" class="def">space</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#space" class="link">Source</a> <a href="#v:space" class="selflink">#</a></p><div class="doc"><p>This contains parsers that directly treat whitespace.</p></div></div><a href="#g:6" id="g:6"><h3><code>Lexeme</code> Fields</h3></a><div class="doc"><p>Despite their differences, lexemes and non-lexemes share a lot of common functionality.
    The type <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a></code> describes both lexemes and non-lexemes, so that this common functionality may be exploited.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Lexeme" class="def">Lexeme</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#Lexeme" class="link">Source</a> <a href="#t:Lexeme" class="selflink">#</a></p><div class="doc"><p>A <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a></code> is a collection of parsers for handling various tokens (such as symbols and names), where either all or none of the parsers consume whitespace.</p></div></div><div class="doc"><p>Lexemes and Non-Lexemes are described by these common fields.</p></div><div class="top"><p class="src"><a id="v:apply" class="def">apply</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <span class="keyword">forall</span> a. <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#apply" class="link">Source</a> <a href="#v:apply" class="selflink">#</a></p><div class="doc"><p>This turns a non-lexeme parser into a lexeme one by ensuring whitespace is consumed after the parser.</p></div></div><div class="top"><p class="src"><a id="v:sym" class="def">sym</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#sym" class="link">Source</a> <a href="#v:sym" class="selflink">#</a></p><div class="doc"><p>Parse the given string.</p></div></div><div class="top"><p class="src"><a id="v:symbol" class="def">symbol</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Symbol" title="Text.Gigaparsec.Token.Lexer">Symbol</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#symbol" class="link">Source</a> <a href="#v:symbol" class="selflink">#</a></p><div class="doc"><p>This contains lexing functionality relevant to the parsing of atomic symbols.</p></div></div><div class="top"><p class="src"><a id="v:names" class="def">names</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#names" class="link">Source</a> <a href="#v:names" class="selflink">#</a></p><div class="doc"><p>This contains lexing functionality relevant to the parsing of names, which include operators or identifiers.
 The parsing of names is mostly concerned with finding the longest valid name that is not a reserved name, 
 such as a hard keyword or a special operator.</p></div></div><a href="#g:7" id="g:7"><h2>Symbolic Tokens</h2></a><div class="doc"><p>The <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Symbol" title="Text.Gigaparsec.Token.Lexer">Symbol</a></code> interface handles the parsing of symbolic tokens, such as keywords.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Symbol" class="def">Symbol</a> <a href="src/Text.Gigaparsec.Internal.Token.Symbol.html#Symbol" class="link">Source</a> <a href="#t:Symbol" class="selflink">#</a></p><div class="doc"><p>This contains lexing functionality relevant to the parsing of atomic symbols.</p><p>Symbols are characterised by their &quot;unitness&quot;, that is, every parser inside returns Unit. 
This is because they all parse a specific known entity, and, as such, the result of the parse is irrelevant. 
These can be things such as reserved names, or small symbols like parentheses. </p><p>This type also contains a means of creating new symbols as well as implicit conversions 
to allow for Haskell's string literals (with <code class="inline-code">OverloadedStringLiterals</code> enabled) to serve as symbols within a parser.</p></div></div><div class="top"><p class="src"><a id="v:softKeyword" class="def">softKeyword</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Symbol" title="Text.Gigaparsec.Token.Lexer">Symbol</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.Internal.Token.Symbol.html#softKeyword" class="link">Source</a> <a href="#v:softKeyword" class="selflink">#</a></p><div class="doc"><p>This combinator parses a given soft keyword atomically: 
  the keyword is only valid if it is not followed directly by a character 
  which would make it a larger valid identifier.</p><p>Soft keywords are keywords that are only reserved within certain contexts. 
  The <code><a href="Text-Gigaparsec-Token-Lexer.html#v:apply" title="Text.Gigaparsec.Token.Lexer">apply</a></code> combinator handles so-called hard keywords automatically, 
  as the given string is checked to see what class of symbol it might belong to.
  However, soft keywords are not included in this set, 
  as they are not always reserved in all situations. 
  As such, when a soft keyword does need to be parsed, 
  this combinator should be used to do it explicitly. 
  Care should be taken to ensure that soft keywords take
  parsing priority over identifiers when they do occur.</p></div></div><div class="top"><p class="src"><a id="v:softOperator" class="def">softOperator</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Symbol" title="Text.Gigaparsec.Token.Lexer">Symbol</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.Internal.Token.Symbol.html#softOperator" class="link">Source</a> <a href="#v:softOperator" class="selflink">#</a></p><div class="doc"><p>This combinator parses a given soft operator atomically:
  the operator is only valid if it is not followed directly by a character which 
  would make it a larger valid operator (reserved or otherwise).</p><p>Soft operators are operators that are only reserved within certain contexts. 
  The apply combinator handles so-called hard operators automatically, 
  as the given string is checked to see what class of symbol it might belong to. 
  However, soft operators are not included in this set, 
  as they are not always reserved in all situations.
  As such, when a soft operator does need to be parsed, 
  this combinator should be used to do it explicitly.</p></div></div><a href="#g:8" id="g:8"><h2>Name Tokens</h2></a><div class="doc"><p>The <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a></code> interface handles the parsing of identifiers and operators.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Names" class="def">Names</a> <a href="src/Text.Gigaparsec.Internal.Token.Names.html#Names" class="link">Source</a> <a href="#t:Names" class="selflink">#</a></p><div class="doc"><p>This class defines a uniform interface for defining parsers for user-defined names 
(identifiers and operators), independent of how whitespace should be handled after the name.</p><p>The parsing of names is mostly concerned with finding the longest valid name that is not a reserved name, 
such as a hard keyword or a special operator.</p></div></div><div class="top"><p class="src"><a id="v:identifier" class="def">identifier</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Names.html#identifier" class="link">Source</a> <a href="#v:identifier" class="selflink">#</a></p><div class="doc"><p>Parse an identifier based on the given <code><a href="Text-Gigaparsec-Token-Descriptions.html#t:NameDesc" title="Text.Gigaparsec.Token.Descriptions">NameDesc</a></code> predicates <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:identifierStart" title="Text.Gigaparsec.Token.Descriptions">identifierStart</a></code> and <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:identifierLetter" title="Text.Gigaparsec.Token.Descriptions">identifierLetter</a></code>.
  The <code><a href="Text-Gigaparsec-Token-Descriptions.html#t:NameDesc" title="Text.Gigaparsec.Token.Descriptions">NameDesc</a></code> is provided by <code>mkNames</code>.</p><p>Capable of handling unicode characters if the configuration permits.
  If hard keywords are specified by the configuration, this parser is not permitted to parse them.</p></div></div><div class="top"><p class="src"><a id="v:identifier-39-" class="def">identifier'</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> -&gt; <a href="Text-Gigaparsec-Token-Descriptions.html#t:CharPredicate" title="Text.Gigaparsec.Token.Descriptions">CharPredicate</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Names.html#identifier%27" class="link">Source</a> <a href="#v:identifier-39-" class="selflink">#</a></p><div class="doc"><p>Parse an identifier whose start satisfies the given predicate, and subseqeunt letters satisfy <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:identifierLetter" title="Text.Gigaparsec.Token.Descriptions">identifierLetter</a></code> in the given <code><a href="Text-Gigaparsec-Token-Descriptions.html#t:NameDesc" title="Text.Gigaparsec.Token.Descriptions">NameDesc</a></code>.
  The <code><a href="Text-Gigaparsec-Token-Descriptions.html#t:NameDesc" title="Text.Gigaparsec.Token.Descriptions">NameDesc</a></code> is provided by <code>mkNames</code>.</p><p>Behaves as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:identifier" title="Text.Gigaparsec.Token.Lexer">identifier</a></code>, then ensures the first character matches the given predicate.
  Thus, <code><a href="Text-Gigaparsec-Token-Lexer.html#v:identifier-39-" title="Text.Gigaparsec.Token.Lexer">identifier'</a></code> can only <em>refine</em> the output of <code><a href="Text-Gigaparsec-Token-Lexer.html#v:identifier" title="Text.Gigaparsec.Token.Lexer">identifier</a></code>;
  if <code><a href="Text-Gigaparsec-Token-Lexer.html#v:identifier" title="Text.Gigaparsec.Token.Lexer">identifier</a></code> fails due to the first character, then so will <code><a href="Text-Gigaparsec-Token-Lexer.html#v:identifier-39-" title="Text.Gigaparsec.Token.Lexer">identifier'</a></code>, 
  even if this character passes the supplied predicate.</p><p>Capable of handling unicode characters if the configuration permits.
  If hard keywords are specified by the configuration, this parser is not permitted to parse them.</p></div></div><div class="top"><p class="src"><a id="v:userDefinedOperator" class="def">userDefinedOperator</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Names.html#userDefinedOperator" class="link">Source</a> <a href="#v:userDefinedOperator" class="selflink">#</a></p><div class="doc"><p>Parse a user-defined operator based on the given <code><a href="Text-Gigaparsec-Token-Descriptions.html#t:SymbolDesc" title="Text.Gigaparsec.Token.Descriptions">SymbolDesc</a></code> predicates <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:operatorStart" title="Text.Gigaparsec.Token.Descriptions">operatorStart</a></code> and <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:operatorLetter" title="Text.Gigaparsec.Token.Descriptions">operatorLetter</a></code>.
  The <code><a href="Text-Gigaparsec-Token-Descriptions.html#t:SymbolDesc" title="Text.Gigaparsec.Token.Descriptions">SymbolDesc</a></code> is provided by <code>mkNames</code>.</p><p>Capable of handling unicode characters if the configuration permits. 
  If hard operators are specified by the configuration, this parser is not permitted to parse them.</p></div></div><div class="top"><p class="src"><a id="v:userDefinedOperator-39-" class="def">userDefinedOperator'</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Names" title="Text.Gigaparsec.Token.Lexer">Names</a> -&gt; <a href="Text-Gigaparsec-Token-Descriptions.html#t:CharPredicate" title="Text.Gigaparsec.Token.Descriptions">CharPredicate</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Names.html#userDefinedOperator%27" class="link">Source</a> <a href="#v:userDefinedOperator-39-" class="selflink">#</a></p><div class="doc"><p>Parse a user-defined operator whose first character satisfies the given predicate,
  and subsequent characters satisfying <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:operatorLetter" title="Text.Gigaparsec.Token.Descriptions">operatorLetter</a></code> in the given <code><a href="Text-Gigaparsec-Token-Descriptions.html#t:SymbolDesc" title="Text.Gigaparsec.Token.Descriptions">SymbolDesc</a></code>.
  The <code><a href="Text-Gigaparsec-Token-Descriptions.html#t:SymbolDesc" title="Text.Gigaparsec.Token.Descriptions">SymbolDesc</a></code> is provided by <code>mkNames</code>.</p><p>Behaves as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:userDefinedOperator" title="Text.Gigaparsec.Token.Lexer">userDefinedOperator</a></code>, then ensures the first character matches the given predicate.
  Thus, <code><a href="Text-Gigaparsec-Token-Lexer.html#v:userDefinedOperator-39-" title="Text.Gigaparsec.Token.Lexer">userDefinedOperator'</a></code> can only <em>refine</em> the output of <code><a href="Text-Gigaparsec-Token-Lexer.html#v:userDefinedOperator" title="Text.Gigaparsec.Token.Lexer">userDefinedOperator</a></code>;
  if <code><a href="Text-Gigaparsec-Token-Lexer.html#v:userDefinedOperator" title="Text.Gigaparsec.Token.Lexer">userDefinedOperator</a></code> fails due to the first character, then so will <code><a href="Text-Gigaparsec-Token-Lexer.html#v:userDefinedOperator-39-" title="Text.Gigaparsec.Token.Lexer">userDefinedOperator'</a></code>, 
  even if this character passes the supplied predicate.</p><p>Capable of handling unicode characters if the configuration permits. 
  If hard operators are specified by the configuration, this parser is not permitted to parse them.</p></div></div><a href="#g:9" id="g:9"><h2>Numeric Tokens</h2></a><div class="doc"><p>These types and combinators parse numeric literals, such as integers and reals.</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:CanHoldSigned" class="def">CanHoldSigned</a> = CanHoldSigned <a href="src/Text.Gigaparsec.Token.Lexer.html#CanHoldSigned" class="link">Source</a> <a href="#t:CanHoldSigned" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:CanHoldUnsigned" class="def">CanHoldUnsigned</a> = CanHoldUnsigned <a href="src/Text.Gigaparsec.Token.Lexer.html#CanHoldUnsigned" class="link">Source</a> <a href="#t:CanHoldUnsigned" class="selflink">#</a></p></div><a href="#g:10" id="g:10"><h3>Integer Parsers</h3></a><div class="doc"><p><code><a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a></code> handles integer parsing (signed and unsigned).
    This is mainly used by the combinators <code><a href="Text-Gigaparsec-Token-Lexer.html#v:integer" title="Text.Gigaparsec.Token.Lexer">integer</a></code> and <code><a href="Text-Gigaparsec-Token-Lexer.html#v:natural" title="Text.Gigaparsec.Token.Lexer">natural</a></code>.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:IntegerParsers" class="def">IntegerParsers</a> (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>) <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#IntegerParsers" class="link">Source</a> <a href="#t:IntegerParsers" class="selflink">#</a></p><div class="doc"><p>A uniform interface for defining parsers for integer literals, 
independent of how whitespace should be handled after the literal 
or whether the literal should allow for negative numbers.</p></div></div><div class="top"><p class="src"><a id="v:integer" class="def">integer</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> CanHoldSigned <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#integer" class="link">Source</a> <a href="#v:integer" class="selflink">#</a></p><div class="doc"><p>This is a collection of parsers concerned with handling signed integer literals.</p><p>Signed integer literals are an extension of unsigned integer literals which may be prefixed by a sign.</p></div></div><div class="top"><p class="src"><a id="v:natural" class="def">natural</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> CanHoldUnsigned <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#natural" class="link">Source</a> <a href="#v:natural" class="selflink">#</a></p><div class="doc"><p>A collection of parsers concerned with handling unsigned (positive) integer literals.</p></div></div><a href="#g:11" id="g:11"><h4>Fixed-Base Parsers</h4></a><div class="top"><p class="src"><a id="v:decimal" class="def">decimal</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#decimal" class="link">Source</a> <a href="#v:decimal" class="selflink">#</a></p><div class="doc"><p>Parse a single integer literal in decimal form (base 10).</p></div></div><div class="top"><p class="src"><a id="v:hexadecimal" class="def">hexadecimal</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#hexadecimal" class="link">Source</a> <a href="#v:hexadecimal" class="selflink">#</a></p><div class="doc"><p>Parse a single integer literal in hexadecimal form (base 16).</p></div></div><div class="top"><p class="src"><a id="v:octal" class="def">octal</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#octal" class="link">Source</a> <a href="#v:octal" class="selflink">#</a></p><div class="doc"><p>Parse a single integer literal in octal form (base 8).</p></div></div><div class="top"><p class="src"><a id="v:binary" class="def">binary</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#binary" class="link">Source</a> <a href="#v:binary" class="selflink">#</a></p><div class="doc"><p>Parse a single integer literal in binary form (base 2).</p></div></div><a href="#g:12" id="g:12"><h4>Fixed-Width Numeric Tokens</h4></a><div class="doc"><p>These combinators tokenize numbers that must be within specific bit-widths.
    The possible bit-widths are provided by <code><a href="Text-Gigaparsec-Internal-Token-BitBounds.html#v:Bits" title="Text.Gigaparsec.Internal.Token.BitBounds">Bits</a></code>.</p></div><a href="#g:13" id="g:13"><h4>Decimal Tokens</h4></a><div class="top"><p class="src"><a id="v:decimal8" class="def">decimal8</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B8" title="Text.Gigaparsec.Token.Errors">B8</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#decimal8" class="link">Source</a> <a href="#v:decimal8" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:decimal" title="Text.Gigaparsec.Token.Lexer">decimal</a></code> except it ensures that the resulting value is a valid 8-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:decimal16" class="def">decimal16</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B16" title="Text.Gigaparsec.Token.Errors">B16</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#decimal16" class="link">Source</a> <a href="#v:decimal16" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:decimal" title="Text.Gigaparsec.Token.Lexer">decimal</a></code> except it ensures that the resulting value is a valid 16-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:decimal32" class="def">decimal32</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B32" title="Text.Gigaparsec.Token.Errors">B32</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#decimal32" class="link">Source</a> <a href="#v:decimal32" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:decimal" title="Text.Gigaparsec.Token.Lexer">decimal</a></code> except it ensures that the resulting value is a valid 32-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:decimal64" class="def">decimal64</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B64" title="Text.Gigaparsec.Token.Errors">B64</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#decimal64" class="link">Source</a> <a href="#v:decimal64" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:decimal" title="Text.Gigaparsec.Token.Lexer">decimal</a></code> except it ensures that the resulting value is a valid 64-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><a href="#g:14" id="g:14"><h4>Hexadecimal Tokens</h4></a><div class="top"><p class="src"><a id="v:hexadecimal8" class="def">hexadecimal8</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B8" title="Text.Gigaparsec.Token.Errors">B8</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#hexadecimal8" class="link">Source</a> <a href="#v:hexadecimal8" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:hexadecimal" title="Text.Gigaparsec.Token.Lexer">hexadecimal</a></code> except it ensures that the resulting value is a valid 8-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:hexadecimal16" class="def">hexadecimal16</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B16" title="Text.Gigaparsec.Token.Errors">B16</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#hexadecimal16" class="link">Source</a> <a href="#v:hexadecimal16" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:hexadecimal" title="Text.Gigaparsec.Token.Lexer">hexadecimal</a></code> except it ensures that the resulting value is a valid 16-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:hexadecimal32" class="def">hexadecimal32</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B32" title="Text.Gigaparsec.Token.Errors">B32</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#hexadecimal32" class="link">Source</a> <a href="#v:hexadecimal32" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:hexadecimal" title="Text.Gigaparsec.Token.Lexer">hexadecimal</a></code> except it ensures that the resulting value is a valid 32-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:hexadecimal64" class="def">hexadecimal64</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B64" title="Text.Gigaparsec.Token.Errors">B64</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#hexadecimal64" class="link">Source</a> <a href="#v:hexadecimal64" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:hexadecimal" title="Text.Gigaparsec.Token.Lexer">hexadecimal</a></code> except it ensures that the resulting value is a valid 64-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><a href="#g:15" id="g:15"><h4>Octal Tokens</h4></a><div class="top"><p class="src"><a id="v:octal8" class="def">octal8</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B8" title="Text.Gigaparsec.Token.Errors">B8</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#octal8" class="link">Source</a> <a href="#v:octal8" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:octal" title="Text.Gigaparsec.Token.Lexer">octal</a></code> except it ensures that the resulting value is a valid 8-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:octal16" class="def">octal16</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B16" title="Text.Gigaparsec.Token.Errors">B16</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#octal16" class="link">Source</a> <a href="#v:octal16" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:octal" title="Text.Gigaparsec.Token.Lexer">octal</a></code> except it ensures that the resulting value is a valid 16-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:octal32" class="def">octal32</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B32" title="Text.Gigaparsec.Token.Errors">B32</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#octal32" class="link">Source</a> <a href="#v:octal32" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:octal" title="Text.Gigaparsec.Token.Lexer">octal</a></code> except it ensures that the resulting value is a valid 32-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:octal64" class="def">octal64</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B64" title="Text.Gigaparsec.Token.Errors">B64</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#octal64" class="link">Source</a> <a href="#v:octal64" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:octal" title="Text.Gigaparsec.Token.Lexer">octal</a></code> except it ensures that the resulting value is a valid 64-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><a href="#g:16" id="g:16"><h4>Binary Tokens</h4></a><div class="top"><p class="src"><a id="v:binary8" class="def">binary8</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B8" title="Text.Gigaparsec.Token.Errors">B8</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#binary8" class="link">Source</a> <a href="#v:binary8" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:binary" title="Text.Gigaparsec.Token.Lexer">binary</a></code> except it ensures that the resulting value is a valid 8-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:binary16" class="def">binary16</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B16" title="Text.Gigaparsec.Token.Errors">B16</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#binary16" class="link">Source</a> <a href="#v:binary16" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:binary" title="Text.Gigaparsec.Token.Lexer">binary</a></code> except it ensures that the resulting value is a valid 16-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:binary32" class="def">binary32</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B32" title="Text.Gigaparsec.Token.Errors">B32</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#binary32" class="link">Source</a> <a href="#v:binary32" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:binary" title="Text.Gigaparsec.Token.Lexer">binary</a></code> except it ensures that the resulting value is a valid 32-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><div class="top"><p class="src"><a id="v:binary64" class="def">binary64</a> :: <span class="keyword">forall</span> a (canHold :: <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Kind.html#t:Constraint" title="Data.Kind">Constraint</a>). canHold '<a href="Text-Gigaparsec-Token-Errors.html#v:B64" title="Text.Gigaparsec.Token.Errors">B64</a> a =&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:IntegerParsers" title="Text.Gigaparsec.Token.Lexer">IntegerParsers</a> canHold -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Numeric.html#binary64" class="link">Source</a> <a href="#v:binary64" class="selflink">#</a></p><div class="doc"><p>This parser behaves the same as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:binary" title="Text.Gigaparsec.Token.Lexer">binary</a></code> except it ensures that the resulting value is a valid 64-bit number.</p><p>The resulting number will be converted to the given type <code class="inline-code">a</code>, which must be able to losslessly store the parsed value; 
this is enforced by the <code class="inline-code">canHold</code> constraint on the type. 
This accounts for unsignedness when necessary.</p></div></div><a href="#g:17" id="g:17"><h2>Textual Tokens</h2></a><div class="doc"><p>The <code><a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a></code> interface handles the parsing of string and character literals.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:TextParsers" class="def">TextParsers</a> t <a href="src/Text.Gigaparsec.Internal.Token.Text.html#TextParsers" class="link">Source</a> <a href="#t:TextParsers" class="selflink">#</a></p><div class="doc"><p>This type defines a uniform interface for defining parsers for textual literals, independent of how whitespace should be handled after the literal.</p><p>The type of these literals is determined by the parameter <code class="inline-code">t</code>.</p></div></div><div class="top"><p class="src"><a id="v:ascii" class="def">ascii</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> t -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> t <a href="src/Text.Gigaparsec.Internal.Token.Text.html#ascii" class="link">Source</a> <a href="#v:ascii" class="selflink">#</a></p><div class="doc"><p>Parses a single <code class="inline-code">t</code>-literal, which may contain any graphic ASCII character. 
    These are characters with ordinals in range 0 to 127 inclusive. </p><p>It may also contain escape sequences, but only those which result in ASCII characters.</p></div></div><div class="top"><p class="src"><a id="v:unicode" class="def">unicode</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> t -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> t <a href="src/Text.Gigaparsec.Internal.Token.Text.html#unicode" class="link">Source</a> <a href="#v:unicode" class="selflink">#</a></p><div class="doc"><p>Parses a single <code class="inline-code">t</code>-literal, which may contain any unicode graphic character 
    as defined by up to two UTF-16 codepoints.</p><p>It may also contain escape sequences.</p></div></div><div class="top"><p class="src"><a id="v:latin1" class="def">latin1</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> t -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> t <a href="src/Text.Gigaparsec.Internal.Token.Text.html#latin1" class="link">Source</a> <a href="#v:latin1" class="selflink">#</a></p><div class="doc"><p>Parses a single <code class="inline-code">t</code>-literal, which may contain any graphic extended ASCII character. 
    These are characters with ordinals in range 0 to 255 inclusive. </p><p>It may also contain escape sequences, but only those which result in extended ASCII characters.</p></div></div><a href="#g:18" id="g:18"><h3>String Parsers</h3></a><div class="doc"><p>A <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code> provides the following <code><a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a></code> for string literals.</p></div><div class="top"><p class="src"><a id="v:stringLiteral" class="def">stringLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#stringLiteral" class="link">Source</a> <a href="#v:stringLiteral" class="selflink">#</a></p><div class="doc"><p>A collection of parsers concerned with handling single-line string literals.</p><p>String literals are generally described by the <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:TextDesc" title="Text.Gigaparsec.Token.Descriptions">TextDesc</a></code> fields:</p><ul><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:stringEnds" title="Text.Gigaparsec.Token.Descriptions">stringEnds</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:graphicCharacter" title="Text.Gigaparsec.Token.Descriptions">graphicCharacter</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:escapeSequences" title="Text.Gigaparsec.Token.Descriptions">escapeSequences</a></code></li></ul></div></div><div class="top"><p class="src"><a id="v:rawStringLiteral" class="def">rawStringLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#rawStringLiteral" class="link">Source</a> <a href="#v:rawStringLiteral" class="selflink">#</a></p><div class="doc"><p>A collection of parsers concerned with handling single-line string literals, <em>without</em> handling any escape sequences:
      this includes literal-end characters and the escape prefix (often <code class="inline-code">&quot;</code> and <code class="inline-code">\</code> respectively).</p><p>String literals are generally described by the <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:TextDesc" title="Text.Gigaparsec.Token.Descriptions">TextDesc</a></code> fields:</p><ul><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:stringEnds" title="Text.Gigaparsec.Token.Descriptions">stringEnds</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:graphicCharacter" title="Text.Gigaparsec.Token.Descriptions">graphicCharacter</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:escapeSequences" title="Text.Gigaparsec.Token.Descriptions">escapeSequences</a></code></li></ul></div></div><div class="top"><p class="src"><a id="v:multiStringLiteral" class="def">multiStringLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#multiStringLiteral" class="link">Source</a> <a href="#v:multiStringLiteral" class="selflink">#</a></p><div class="doc"><p>A collection of parsers concerned with handling multi-line string literals.</p><p>Multi-string literals are generally described by the <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:TextDesc" title="Text.Gigaparsec.Token.Descriptions">TextDesc</a></code> fields:</p><ul><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:multiStringEnds" title="Text.Gigaparsec.Token.Descriptions">multiStringEnds</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:graphicCharacter" title="Text.Gigaparsec.Token.Descriptions">graphicCharacter</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:escapeSequences" title="Text.Gigaparsec.Token.Descriptions">escapeSequences</a></code></li></ul></div></div><div class="top"><p class="src"><a id="v:rawMultiStringLiteral" class="def">rawMultiStringLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#rawMultiStringLiteral" class="link">Source</a> <a href="#v:rawMultiStringLiteral" class="selflink">#</a></p><div class="doc"><p>A collection of parsers concerned with handling multi-line string literals, <em>without</em> handling any escape sequences:
      this includes literal-end characters and the escape prefix (often <code class="inline-code">&quot;</code> and <code class="inline-code">\</code> respectively).</p><p>Multi-string literals are generally described by the <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:TextDesc" title="Text.Gigaparsec.Token.Descriptions">TextDesc</a></code> fields:</p><ul><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:multiStringEnds" title="Text.Gigaparsec.Token.Descriptions">multiStringEnds</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:graphicCharacter" title="Text.Gigaparsec.Token.Descriptions">graphicCharacter</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:escapeSequences" title="Text.Gigaparsec.Token.Descriptions">escapeSequences</a></code></li></ul></div></div><a href="#g:19" id="g:19"><h3>Character Parsers</h3></a><div class="doc"><p>A <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code> provides the following <code><a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a></code> for character literals.</p></div><div class="top"><p class="src"><a id="v:charLiteral" class="def">charLiteral</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Lexeme" title="Text.Gigaparsec.Token.Lexer">Lexeme</a> -&gt; <a href="Text-Gigaparsec-Token-Lexer.html#t:TextParsers" title="Text.Gigaparsec.Token.Lexer">TextParsers</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#charLiteral" class="link">Source</a> <a href="#v:charLiteral" class="selflink">#</a></p><div class="doc"><p>A collection of parsers concerned with handling character literals.</p><p>Charcter literals are generally described by the <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:TextDesc" title="Text.Gigaparsec.Token.Descriptions">TextDesc</a></code> fields:</p><ul><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:characterLiteralEnd" title="Text.Gigaparsec.Token.Descriptions">characterLiteralEnd</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:graphicCharacter" title="Text.Gigaparsec.Token.Descriptions">graphicCharacter</a></code></li><li><code><a href="Text-Gigaparsec-Token-Descriptions.html#v:escapeSequences" title="Text.Gigaparsec.Token.Descriptions">escapeSequences</a></code></li></ul></div></div><a href="#g:20" id="g:20"><h2>Whitespace and Comments</h2></a><div class="doc"><p><code><a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a></code> and its fields are concerned with special treatment of whitespace itself.</p><p>Most of the time, the functionality herein will not be required,
    as <code><a href="Text-Gigaparsec-Token-Lexer.html#v:lexeme" title="Text.Gigaparsec.Token.Lexer">lexeme</a></code> and <code><a href="Text-Gigaparsec-Token-Lexer.html#v:fully" title="Text.Gigaparsec.Token.Lexer">fully</a></code> will consistently handle whitespace.</p><p>However, whitespace <em>is</em> significant in some languages, like Python and Haskell,
    in which case <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a></code> provides a way to control how whitespace is consumed.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Space" class="def">Space</a> <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#Space" class="link">Source</a> <a href="#t:Space" class="selflink">#</a></p><div class="doc"><p>This type is concerned with special treatment of whitespace.</p><p>For the vast majority of cases, the functionality within this object shouldn't be needed, 
as whitespace is consistently handled by lexeme and fully. 
However, for grammars where whitespace is significant (like indentation-sensitive languages), 
this object provides some more fine-grained control over how whitespace is consumed by the parsers within lexeme.</p></div></div><div class="top"><p class="src"><a id="v:skipComments" class="def">skipComments</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#skipComments" class="link">Source</a> <a href="#v:skipComments" class="selflink">#</a></p><div class="doc"><p>Skips zero or more comments.</p><p>The implementation of this combinator does not vary with <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:whiteSpaceIsContextDependent" title="Text.Gigaparsec.Token.Descriptions">whiteSpaceIsContextDependent</a></code>. 
  It will use the hide combinator as to not appear as a valid alternative in an error message: 
  adding a comment is often legal, 
  but not a useful solution for how to make the input syntactically valid.</p></div></div><div class="top"><p class="src"><a id="v:whiteSpace" class="def">whiteSpace</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#whiteSpace" class="link">Source</a> <a href="#v:whiteSpace" class="selflink">#</a></p><div class="doc"><p>Skips zero or more (insignificant) whitespace characters as well as comments.</p><p>The implementation of this parser depends on whether <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:whiteSpaceIsContextDependent" title="Text.Gigaparsec.Token.Descriptions">whiteSpaceIsContextDependent</a></code> is true: 
  when it is, this parser may change based on the use of the alter combinator. </p><p>This parser will always use the hide combinator as to not appear as a valid alternative in an error message: 
  it's likely always the case whitespace can be added at any given time, but that doesn't make it a useful suggestion unless it is significant.</p></div></div><div class="top"><p class="src"><a id="v:alter" class="def">alter</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> -&gt; <span class="keyword">forall</span> a. <a href="Text-Gigaparsec-Token-Descriptions.html#t:CharPredicate" title="Text.Gigaparsec.Token.Descriptions">CharPredicate</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#alter" class="link">Source</a> <a href="#v:alter" class="selflink">#</a></p><div class="doc"><p>This combinator changes how lexemes parse whitespace for the duration of a given parser.</p><p>So long as <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:whiteSpaceIsContextDependent" title="Text.Gigaparsec.Token.Descriptions">whiteSpaceIsContextDependent</a></code> is true, 
  this combinator will be able to locally change the definition of whitespace during the given parser.</p><h3 class="subheading details-toggle-control details-toggle" data-details-id="ch:alter0">Examples</h3><details id="ch:alter0"><summary class="hide-when-js-enabled">Expand</summary><ul><li>In indentation sensitive languages, the indentation sensitivity is often ignored within parentheses or braces. 
  In these cases, 
  <code class="inline-code">parens (alter withNewLine p)</code> 
  would allow unrestricted newlines within parentheses.</li></ul></details></div></div><div class="top"><p class="src"><a id="v:initSpace" class="def">initSpace</a> :: <a href="Text-Gigaparsec-Token-Lexer.html#t:Space" title="Text.Gigaparsec.Token.Lexer">Space</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.Internal.Token.Lexer.html#initSpace" class="link">Source</a> <a href="#v:initSpace" class="selflink">#</a></p><div class="doc"><p>This parser initialises the whitespace used by the lexer when <code><a href="Text-Gigaparsec-Token-Descriptions.html#v:whiteSpaceIsContextDependent" title="Text.Gigaparsec.Token.Descriptions">whiteSpaceIsContextDependent</a></code> is true.</p><p>The whitespace is set to the implementation given by the lexical description.
  This parser must be used, by fully or otherwise, 
  as the first thing the global parser does or an UnfilledRegisterException will occur.</p><p>See <code><a href="Text-Gigaparsec-Token-Lexer.html#v:alter" title="Text.Gigaparsec.Token.Lexer">alter</a></code> for how to change whitespace during a parse.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>