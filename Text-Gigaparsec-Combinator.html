<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Gigaparsec.Combinator</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">gigaparsec-0.2.1.0: Refreshed parsec-style library for compatiblity with Scala parsley</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Text.Gigaparsec.Combinator.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>Jamie Willis, Gigaparsec Maintainers</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Gigaparsec.Combinator</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Iterative Combinators</a></li><li><a href="#g:2">Optional Parsing Combinators</a></li><li><a href="#g:3">Separated Values Combinators</a></li><li><a href="#g:4">Multiple Branching/Sequencing Combinators</a></li><li><a href="#g:5">Range Combinators</a></li><li><a href="#g:6">Selective Combinators</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains a huge number of pre-made combinators that are very useful for a variety of purposes.</p><p>In particular, it contains combinators for: performing a parser iteratively, collecting all the results;
querying whether or not any input is left; optionally performing parsers; parsing delimited constructions;
handling multiple possible alternatives or parsers to sequence; handling more complex conditional execution;
and more.</p><p><em>Since: 0.1.0.0</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:manyN">manyN</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:skipMany">skipMany</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:skipSome">skipSome</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:skipManyN">skipManyN</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:count">count</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:count1">count1</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:manyTill">manyTill</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> end -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:someTill">someTill</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> end -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:option">option</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:optional">optional</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:optionalAs">optionalAs</a> :: b -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</li><li class="src short"><a href="#v:decide">decide</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:fromMaybeS">fromMaybeS</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:sepBy">sepBy</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:sepBy1">sepBy1</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:sepEndBy">sepEndBy</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:sepEndBy1">sepEndBy1</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:endBy">endBy</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:endBy1">endBy1</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:choice">choice</a> :: [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a] -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:sequence">sequence</a> :: (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> t, <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t (m a) -&gt; m (t a)</li><li class="src short"><a href="#v:traverse">traverse</a> :: (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> t, <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)</li><li class="src short"><a href="#v:skip">skip</a> :: [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a] -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:exactly">exactly</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:range">range</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</li><li class="src short"><a href="#v:range_">range_</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:countRange">countRange</a> :: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:ifS">ifS</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:whenS">whenS</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:guardS">guardS</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:whileS">whileS</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Iterative Combinators</h1></a><div class="doc"><p>These combinators all execute a given parser an unbounded number of times, until either it fails, or another
 parser succeeds, depending on the combinator. Depending on the combinator, all of the results produced by the
 repeated execution of the parser may be returned in a <code>[]</code>. These are almost essential for any practical parsing
 task.</p></div><div class="top"><p class="src"><a id="v:manyN" class="def">manyN</a> <a href="src/Text.Gigaparsec.Combinator.html#manyN" class="link">Source</a> <a href="#v:manyN" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>the minimum number of <code>p</code>s required, <code>n</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser <code>p</code> to execute multiple times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> until it fails, returning the list of all the successful results.</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses a given parser <strong><code>n</code></strong> or more times, collecting the results into a list.</p><p>Parses a given parser, <code>p</code>, repeatedly until it fails. If <code>p</code> failed having consumed input,
this combinator fails. Otherwise when <code>p</code> fails <strong>without consuming input</strong>, this combinator
will return all of the results, <code>x1</code> through <code>xm</code> (with <code>m &gt;= n</code>), in a list: <code>[x1, .., xm]</code>.
If <code>p</code> was not successful at least <code>n</code> times, this combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:manyN0">Examples</h4><details id="ch:manyN0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = manyN 2 (string &quot;ab&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abababab&quot;
</code></strong>Success [&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;aba&quot;
</code></strong>Failure ..
</pre></details><h4>Notes</h4><ul><li><code>many p == many 0 p</code> and <code>some p == many 1 p</code>.</li></ul><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:skipMany" class="def">skipMany</a> <a href="src/Text.Gigaparsec.Combinator.html#skipMany" class="link">Source</a> <a href="#v:skipMany" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser <code>p</code> to execute multiple times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p>a parser that parses <code>p</code> until it fails, returning unit.</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses a given parser <strong>zero</strong> or more times, ignoring the results.</p><p>Parses a given parser, <code>p</code>, repeatedly until it fails. If <code>p</code> failed having consumed input,
this combinator fails. Otherwise when <code>p</code> fails <strong>without consuming input</strong>, this combinator
will succeed.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:skipMany0">Examples</h4><details id="ch:skipMany0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = skipMany (string &quot;ab&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abababab&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;aba&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:skipSome" class="def">skipSome</a> <a href="src/Text.Gigaparsec.Combinator.html#skipSome" class="link">Source</a> <a href="#v:skipSome" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to execute multiple times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p>a parser that parses <code>p</code> until it fails, returning unit.</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses a given parser <strong>one</strong> or more times, ignoring the results.</p><p>Parses a given parser, <code>p</code>, repeatedly until it fails. If <code>p</code> failed having consumed input,
this combinator fails. Otherwise when <code>p</code> fails <strong>without consuming input</strong>, this combinator
will succeed. The parser <code>p</code> must succeed at least once.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:skipSome0">Examples</h4><details id="ch:skipSome0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = skipSome (string &quot;ab&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abababab&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;aba&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:skipManyN" class="def">skipManyN</a> <a href="src/Text.Gigaparsec.Combinator.html#skipManyN" class="link">Source</a> <a href="#v:skipManyN" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p><code>n</code>, the minimum number of times to execute.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to execute multiple times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p>a parser that parses <code>p</code> until it fails, returning unit.</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses a given parser <strong><code>n</code></strong> or more times, ignoring the results.</p><p>Parses a given parser, <code>p</code>, repeatedly until it fails. If <code>p</code> failed having consumed input,
this combinator fails. Otherwise when <code>p</code> fails <strong>without consuming input</strong>, this combinator
will succeed. The parser <code>p</code> must succeed at least <code>n</code> times.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:skipManyN0">Examples</h4><details id="ch:skipManyN0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = skipManyN 2 (string &quot;ab&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abababab&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;aba&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:count" class="def">count</a> <a href="src/Text.Gigaparsec.Combinator.html#count" class="link">Source</a> <a href="#v:count" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to execute multiple times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>the number of times <code>p</code> successfully parses</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses a given parser <strong>zero</strong> or more times, returning how many times it succeeded.</p><p>Parses a given parser, <code>p</code>, repeatedly until it fails. If <code>p</code> failed having consumed input,
this combinator fails. Otherwise when <code>p</code> fails <strong>without consuming input</strong>, this combinator
will succeed. The number of times <code>p</code> succeeded is returned as the result.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:count0">Examples</h4><details id="ch:count0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = count (string &quot;ab&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Success 0
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Success 1
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abababab&quot;
</code></strong>Success 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;aba&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:count1" class="def">count1</a> <a href="src/Text.Gigaparsec.Combinator.html#count1" class="link">Source</a> <a href="#v:count1" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to execute multiple times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>the number of times <code>p</code> successfully parses</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses a given parser <strong>one</strong> or more times, returning how many times it succeeded.</p><p>Parses a given parser, <code>p</code>, repeatedly until it fails. If <code>p</code> failed having consumed input,
this combinator fails. Otherwise when <code>p</code> fails <strong>without consuming input</strong>, this combinator
will succeed. The parser <code>p</code> must succeed at least once. The number of times <code>p</code> succeeded is returned as the result.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:count10">Examples</h4><details id="ch:count10"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = count1 (string &quot;ab&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Success 1
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abababab&quot;
</code></strong>Success 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;aba&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:manyTill" class="def">manyTill</a> <a href="src/Text.Gigaparsec.Combinator.html#manyTill" class="link">Source</a> <a href="#v:manyTill" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to execute multiple times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> end</td><td class="doc"><p><code>end</code>, the parser that stops the parsing of <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> until <code>end</code> succeeds, returning the list of all the successful results.</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses a given parser <strong>zero</strong> or more times, until the <code>end</code> parser succeeds, collecting the results into a list.</p><p>First tries to parse <code>end</code>, if it fails <strong>without consuming input</strong>, then parses <code>p</code>, which must succeed. This repeats until <code>end</code> succeeds.
When <code>end</code> does succeed, this combinator will return all of the results generated by <code>p</code>, <code>x1</code> through <code>xn</code> (with <code>n &gt;= 0</code>), in a
list: <code>[x1, .., xn]</code>. If <code>end</code> could be parsed immediately, the empty list is returned.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:manyTill0">Examples</h4><details id="ch:manyTill0"><summary class="hide-when-js-enabled">Expand</summary><p>This can be useful for scanning comments:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let comment = string &quot;--&quot; *&gt; manyUntil item endOfLine
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;--hello world&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;--hello world\n&quot;
</code></strong>Success ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;--\n&quot;
</code></strong>Success Nil
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:someTill" class="def">someTill</a> <a href="src/Text.Gigaparsec.Combinator.html#someTill" class="link">Source</a> <a href="#v:someTill" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to execute multiple times.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> end</td><td class="doc"><p><code>end</code>, the parser that stops the parsing of <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> until <code>end</code> succeeds, returning the list of all the successful results.</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses a given parser <strong>one</strong> or more times, until the <code>end</code> parser succeeds, collecting the results into a list.</p><p>First ensures that trying to parse <code>end</code> fails, then tries to parse <code>p</code>. If it succeed then it will repeatedly: try to parse <code>end</code>, if it fails
<strong>without consuming input</strong>, then parses <code>p</code>, which must succeed. When <code>end</code> does succeed, this combinator will return all of the results
generated by <code>p</code>, <code>x1</code> through <code>xn</code> (with <code>n &gt;= 1</code>), in a list: <code>[x1, .., xn]</code>. The parser <code>p</code> must succeed at least once
before <code>end</code> succeeds.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:someTill0">Examples</h4><details id="ch:someTill0"><summary class="hide-when-js-enabled">Expand</summary><p>This can be useful for scanning comments:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let comment = string &quot;--&quot; *&gt; someUntil item endOfLine
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;--hello world&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;--hello world\n&quot;
</code></strong>Success ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;--\n&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;--a\n&quot;
</code></strong>Success ['a']
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:2" id="g:2"><h1>Optional Parsing Combinators</h1></a><div class="doc"><p>These combinators allow for the <em>possible</em> parsing of some parser. If the parser succeeds, that is ok
 so long as it <strong>did not consume input</strong>. Be aware that the result of the success may be replaced with
 these combinators, with the exception of &quot;option&quot;, which still preserves the result.</p></div><div class="top"><p class="src"><a id="v:option" class="def">option</a> <a href="src/Text.Gigaparsec.Combinator.html#option" class="link">Source</a> <a href="#v:option" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser <code>p</code> to try to parse</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This combinator tries to parse <code>p</code>, wrapping its result in a <code>Just</code> if it succeeds, or returns <code>Nothing</code> if it fails.</p><p>Tries to parse <code>p</code>. If <code>p</code> succeeded, producing <code>x</code>, then <code>Just x</code> is returned. Otherwise, if <code>p</code> failed
<strong>without consuming input</strong>, then <code>Nothing</code> is returned instead.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:option0">Examples</h4><details id="ch:option0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = option (string &quot;abc&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Success Nothing
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success (Just &quot;abc&quot;)
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:optional" class="def">optional</a> <a href="src/Text.Gigaparsec.Combinator.html#optional" class="link">Source</a> <a href="#v:optional" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser <code>p</code> to try to parse.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This combinator will parse <code>p</code> if possible, otherwise will do nothing.</p><p>Tries to parse <code>p</code>. If <code>p</code> succeeds, or fails <strong>without consuming input</strong> then this combinator is successful. Otherwise, if <code>p</code> failed
having consumed input, this combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:optional0">Examples</h4><details id="ch:optional0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = optional (string &quot;abc&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:optionalAs" class="def">optionalAs</a> <a href="src/Text.Gigaparsec.Combinator.html#optionalAs" class="link">Source</a> <a href="#v:optionalAs" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: b</td><td class="doc"><p>the value <code>x</code> to return regardless of how <code>p</code> performs.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>the parser <code>p</code> to try to parse.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> b</td><td class="doc"><p>a parser that tries to parse <code>p</code>, returning <code>x</code> regardless of success or failure.</p></td></tr></table></div><div class="doc"><p>This combinator will parse <code>p</code> if possible, otherwise will do nothing.</p><p>Tries to parse <code>p</code>. If <code>p</code> succeeds, or fails <strong>without consuming input</strong> then this combinator is successful and returns <code>x</code>. Otherwise,
if <code>p</code> failed having consumed input, this combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:optionalAs0">Examples</h4><details id="ch:optionalAs0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = optionalAs 7 (string &quot;abc&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Success 7
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success 7
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:decide" class="def">decide</a> <a href="src/Text.Gigaparsec.Combinator.html#decide" class="link">Source</a> <a href="#v:decide" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</td><td class="doc"><p>the parser <code>p</code> to parse and extract the result from.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that tries to extract the result from <code>p</code>.</p></td></tr></table></div><div class="doc"><p>This combinator can eliminate an <code>Maybe</code> from the result of the parser <code>p</code>.</p><p>First parse <code>p</code>, if it succeeds returning <code>Just x</code>, then return <code>x</code>. However,
if <code>p</code> fails, or returned <code>Nothing</code>, then this combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:decide0">Examples</h4><details id="ch:decide0"><summary class="hide-when-js-enabled">Expand</summary><pre>decide (option p) = p</pre></details></div></div><div class="top"><p class="src"><a id="v:fromMaybeS" class="def">fromMaybeS</a> <a href="src/Text.Gigaparsec.Combinator.html#fromMaybeS" class="link">Source</a> <a href="#v:fromMaybeS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser to execute when <code>p</code> returns <code>Nothing</code>, to provide a value of type <code>a</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</td><td class="doc"><p>the first parser <code>p</code>, which returns an <code>Maybe</code> to eliminate.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that either just parses <code>p</code> or both <code>p</code> and <code>q</code> in order to return an <code>a</code>.</p></td></tr></table></div><div class="doc"><p>This combinator parses <code>q</code> depending only if <code>p</code> returns a <code>Nothing</code>.</p><p>First parses <code>p</code>. If <code>p</code> returned <code>Just x</code>, then <code>x</code> is returned.
Otherwise, if <code>p</code> returned <code>Nothing</code> then <code>q</code> is parsed, producing <code>y</code>,
and <code>y</code> is returned. If <code>p</code> or <code>q</code> fails, the combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:fromMaybeS0">Examples</h4><details id="ch:fromMaybeS0"><summary class="hide-when-js-enabled">Expand</summary><p>fromMaybe q (option p) = p <a href="|">|</a> q</p></details><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:3" id="g:3"><h1>Separated Values Combinators</h1></a><div class="doc"><p>These combinators are concerned with delimited parsing, where one parser is repeated but delimited by another one.
 In each of these cases <code>p</code> is the parser of interest and <code>sep</code> is the delimeter. These combinators mainly differ
 in either the number of <code>p</code>s they require, or exactly where the delimeters are allowed (only between, always
 trailing, or either). In all cases, they return the list of results generated by the repeated parses of <code>p</code>.</p></div><div class="top"><p class="src"><a id="v:sepBy" class="def">sepBy</a> <a href="src/Text.Gigaparsec.Combinator.html#sepBy" class="link">Source</a> <a href="#v:sepBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser whose results are collected into a list.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep</td><td class="doc"><p><code>sep</code>, the delimiter that must be parsed between every <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> delimited by <code>sep</code>, returning the list of <code>p</code>'s results.</p></td></tr></table></div><div class="doc"><p>This combinator parses <strong>zero</strong> or more occurrences of <code>p</code>, separated by <code>sep</code>.</p><p>Behaves just like <code>sepBy1</code>, except does not require an initial <code>p</code>, returning the empty list instead.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:sepBy0">Examples</h4><details id="ch:sepBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>...
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let args = sepBy int (string &quot;, &quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;7, 3, 2&quot;
</code></strong>Success [7, 3, 2]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;&quot;
</code></strong>Success []
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1&quot;
</code></strong>Success [1]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1, 2, &quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:sepBy1" class="def">sepBy1</a> <a href="src/Text.Gigaparsec.Combinator.html#sepBy1" class="link">Source</a> <a href="#v:sepBy1" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser whose results are collected into a list.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep</td><td class="doc"><p><code>sep</code>, the delimiter that must be parsed between every <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> delimited by <code>sep</code>, returning the list of <code>p</code>'s results.</p></td></tr></table></div><div class="doc"><p>This combinator parses <strong>one</strong> or more occurrences of <code>p</code>, separated by <code>sep</code>.</p><p>First parses a <code>p</code>. Then parses <code>sep</code> followed by <code>p</code> until there are no more <code>sep</code>s.
The results of the <code>p</code>'s, <code>x1</code> through <code>xn</code>, are returned as <code>[x1, .., xn]</code>.
If <code>p</code> or <code>sep</code> fails having consumed input, the whole parser fails. Requires at least
one <code>p</code> to have been parsed.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:sepBy10">Examples</h4><details id="ch:sepBy10"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>...
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let args = sepBy1 int (string &quot;, &quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;7, 3, 2&quot;
</code></strong>Success [7, 3, 2]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1&quot;
</code></strong>Success [1]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1, 2, &quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:sepEndBy" class="def">sepEndBy</a> <a href="src/Text.Gigaparsec.Combinator.html#sepEndBy" class="link">Source</a> <a href="#v:sepEndBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser whose results are collected into a list.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep</td><td class="doc"><p><code>sep</code>, the delimiter that must be parsed between every <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> delimited by <code>sep</code>, returning the list of <code>p</code>'s results.</p></td></tr></table></div><div class="doc"><p>This combinator parses <strong>zero</strong> or more occurrences of <code>p</code>, separated and optionally ended by <code>sep</code>.</p><p>Behaves just like <code>sepEndBy1</code>, except does not require an initial <code>p</code>, returning the empty list instead.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:sepEndBy0">Examples</h4><details id="ch:sepEndBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>...
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let args = sepEndBy int (string &quot;;\n&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;7;\n3;\n2&quot;
</code></strong>Success [7, 3, 2]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;&quot;
</code></strong>Success Nil
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1&quot;
</code></strong>Success [1]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1;\n2;\n&quot;
</code></strong>Success [1, 2]
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:sepEndBy1" class="def">sepEndBy1</a> <a href="src/Text.Gigaparsec.Combinator.html#sepEndBy1" class="link">Source</a> <a href="#v:sepEndBy1" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser whose results are collected into a list.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep</td><td class="doc"><p><code>sep</code>, the delimiter that must be parsed between every <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> delimited by <code>sep</code>, returning the list of <code>p</code>'s results.</p></td></tr></table></div><div class="doc"><p>This combinator parses <strong>one</strong> or more occurrences of <code>p</code>, separated and optionally ended by <code>sep</code>.</p><p>First parses a <code>p</code>. Then parses <code>sep</code> followed by <code>p</code> until there are no more: if a final <code>sep</code> exists, this is parsed.
The results of the <code>p</code>'s, <code>x1</code> through <code>xn</code>, are returned as <code>[x1, .., xn]</code>.
If <code>p</code> or <code>sep</code> fails having consumed input, the whole parser fails. Requires at least
one <code>p</code> to have been parsed.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:sepEndBy10">Examples</h4><details id="ch:sepEndBy10"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>...
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let args = sepEndBy1 int (string &quot;;\n&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;7;\n3;\n2&quot;
</code></strong>Success [7, 3, 2]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1&quot;
</code></strong>Success [1]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1;\n2;\n&quot;
</code></strong>Success [1, 2]
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:endBy" class="def">endBy</a> <a href="src/Text.Gigaparsec.Combinator.html#endBy" class="link">Source</a> <a href="#v:endBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser whose results are collected into a list.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep</td><td class="doc"><p><code>sep</code>, the delimiter that must be parsed between every <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> delimited by <code>sep</code>, returning the list of <code>p</code>'s results.</p></td></tr></table></div><div class="doc"><p>This combinator parses <strong>zero</strong> or more occurrences of <code>p</code>, separated and ended by <code>sep</code>.</p><p>Behaves just like <code>endBy1</code>, except does not require an initial <code>p</code> and <code>sep</code>, returning the empty list instead.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:endBy0">Examples</h4><details id="ch:endBy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>...
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let args = endBy int (string &quot;;\n&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;7;\n3;\n2&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;&quot;
</code></strong>Success Nil
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1;\n&quot;
</code></strong>Success [1]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1;\n2;\n&quot;
</code></strong>Success [1, 2]
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:endBy1" class="def">endBy1</a> <a href="src/Text.Gigaparsec.Combinator.html#endBy1" class="link">Source</a> <a href="#v:endBy1" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser whose results are collected into a list.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> sep</td><td class="doc"><p><code>sep</code>, the delimiter that must be parsed between every <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> delimited by <code>sep</code>, returning the list of <code>p</code>'s results.</p></td></tr></table></div><div class="doc"><p>This combinator parses <strong>one</strong> or more occurrences of <code>p</code>, separated and ended by <code>sep</code>.</p><p>Parses <code>p</code> followed by <code>sep</code> one or more times.
The results of the <code>p</code>'s, <code>x1</code> through <code>xn</code>, are returned as <code>[x1, .., xn]</code>.
If <code>p</code> or <code>sep</code> fails having consumed input, the whole parser fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:endBy10">Examples</h4><details id="ch:endBy10"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>...
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let args = endBy1 int (string &quot;;\n&quot;)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;7;\n3;\n2&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1;\n&quot;
</code></strong>Success [1]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String args &quot;1;\n2;\n&quot;
</code></strong>Success [1, 2]
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:4" id="g:4"><h1>Multiple Branching/Sequencing Combinators</h1></a><div class="doc"><p>These combinators allow for testing or sequencing a large number of parsers in one go.</p></div><div class="top"><p class="src"><a id="v:choice" class="def">choice</a> <a href="src/Text.Gigaparsec.Combinator.html#choice" class="link">Source</a> <a href="#v:choice" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a]</td><td class="doc"><p>the parsers, <code>ps</code> to try, in order.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that tries to parse one of <code>ps</code>.</p></td></tr></table></div><div class="doc"><p>This combinator tries to parse each of the parsers <code>ps</code> in order, until one of them succeeds.</p><p>Finds the first parser in <code>ps</code> which succeeds, returning its result. If Nothing of the parsers
succeed, then this combinator fails. If a parser fails having consumed input, this combinator
fails <strong>immediately</strong>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:choice0">Examples</h4><details id="ch:choice0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = choice [string &quot;abc&quot;, string &quot;ab&quot;, string &quot;bc&quot;, string &quot;d&quot;]
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success &quot;abc&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;bc&quot;
</code></strong>Success &quot;bc&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;x&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> t, <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t (m a) -&gt; m (t a) <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><p>Evaluate each monadic action in the structure from left to
 right, and collect the results. For a version that ignores the
 results see <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Foldable.html#v:sequence_" title="Data.Foldable">sequence_</a></code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:sequence0">Examples</h4><details id="ch:sequence0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p><p>The first two examples are instances where the input and
 and output of <code><a href="Text-Gigaparsec-Combinator.html#v:sequence" title="Text.Gigaparsec.Combinator">sequence</a></code> are isomorphic.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sequence $ Right [1,2,3,4]
</code></strong>[Right 1,Right 2,Right 3,Right 4]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sequence $ [Right 1,Right 2,Right 3,Right 4]
</code></strong>Right [1,2,3,4]
</pre><p>The following examples demonstrate short circuit behavior
 for <code><a href="Text-Gigaparsec-Combinator.html#v:sequence" title="Text.Gigaparsec.Combinator">sequence</a></code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sequence $ Left [1,2,3,4]
</code></strong>Left [1,2,3,4]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>sequence $ [Left 0, Right 1,Right 2,Right 3,Right 4]
</code></strong>Left 0
</pre></details></div></div><div class="top"><p class="src"><a id="v:traverse" class="def">traverse</a> :: (<a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> t, <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b) <a href="#v:traverse" class="selflink">#</a></p><div class="doc"><p>Map each element of a structure to an action, evaluate these actions
 from left to right, and collect the results. For a version that ignores
 the results see <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Foldable.html#v:traverse_" title="Data.Foldable">traverse_</a></code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:traverse0">Examples</h4><details id="ch:traverse0"><summary class="hide-when-js-enabled">Expand</summary><p>Basic usage:</p><p>In the first two examples we show each evaluated action mapping to the
 output structure.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traverse Just [1,2,3,4]
</code></strong>Just [1,2,3,4]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traverse id [Right 1, Right 2, Right 3, Right 4]
</code></strong>Right [1,2,3,4]
</pre><p>In the next examples, we show that <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> values short
 circuit the created structure.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traverse (const Nothing) [1,2,3,4]
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traverse (\x -&gt; if odd x then Just x else Nothing)  [1,2,3,4]
</code></strong>Nothing
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>traverse id [Right 1, Right 2, Right 3, Right 4, Left 0]
</code></strong>Left 0
</pre></details></div></div><div class="top"><p class="src"><a id="v:skip" class="def">skip</a> <a href="src/Text.Gigaparsec.Combinator.html#skip" class="link">Source</a> <a href="#v:skip" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a]</td><td class="doc"><p>parsers <code>ps</code> to be sequenced.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p>a parser that parses each of <code>ps</code>, returning <code>()</code>.</p></td></tr></table></div><div class="doc"><p>This combinator will parse each of <code>ps</code> in order, discarding the results.</p><p>Given the parsers <code>ps</code>, consisting of <code>p1</code> through <code>pn</code>, parses
each in order. If they all succeed, this combinator succeeds. If any of
the parsers fail, then the whole combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:skip0">Examples</h4><details id="ch:skip0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = skip [char'a', item, char 'c']
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:5" id="g:5"><h1>Range Combinators</h1></a><div class="doc"><p>These combinators allow for the parsing of a specific parser either a specific number of times, or between a certain
 amount of times.</p></div><div class="top"><p class="src"><a id="v:exactly" class="def">exactly</a> <a href="src/Text.Gigaparsec.Combinator.html#exactly" class="link">Source</a> <a href="#v:exactly" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p><code>n</code>, the number of times to repeat <code>p</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to repeat.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>a parser that parses <code>p</code> exactly <code>n</code> times, returning a list of the results.</p></td></tr></table></div><div class="doc"><p>This combinator parses exactly <code>n</code> occurrences of <code>p</code>, returning these <code>n</code> results in a list.</p><p>Parses <code>p</code> repeatedly up to <code>n</code> times. If <code>p</code> fails before <code>n</code> is reached, then this combinator
fails. It is not required for <code>p</code> to fail after the <code>n</code>th parse. The results produced by
<code>p</code>, <code>x1</code> through <code>xn</code>, are returned as <code>[x1, .., xn]</code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:exactly0">Examples</h4><details id="ch:exactly0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = exactly 3 item
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success ['a', 'b', 'c']
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcd&quot;
</code></strong>Success ['a', 'b', 'c']
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:range" class="def">range</a> <a href="src/Text.Gigaparsec.Combinator.html#range" class="link">Source</a> <a href="#v:range" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p><code>min</code>, the minimum number of times to repeat <code>p</code>, inclusive.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p><code>max</code>, the maximum number of times to repeat <code>p</code>, inclusive.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to repeat.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> [a]</td><td class="doc"><p>the results of the successful parses of <code>p</code>.</p></td></tr></table></div><div class="doc"><p>This combinator parses between <code>min</code> and <code>max</code> occurrences of <code>p</code>, returning these <code>n</code> results in a list.</p><p>Parses <code>p</code> repeatedly a minimum of <code>min</code> times and up to <code>max</code> times both inclusive. If <code>p</code> fails before
<code>min</code> is reached, then this combinator fails. It is not required for <code>p</code> to fail after the <code>max</code>^th^ parse.
The results produced by <code>p</code>, <code>xmin</code> through <code>xmax</code>, are returned as <code>[xmin, .., xmax]</code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:range0">Examples</h4><details id="ch:range0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = range 3 5 item
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success ['a', 'b', 'c']
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcd&quot;
</code></strong>Success ['a', 'b', 'c', 'd']
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcde&quot;
</code></strong>Success ['a', 'b', 'c', 'd', 'e']
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcdef&quot;
</code></strong>Success ['a', 'b', 'c', 'd', 'e']
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:range_" class="def">range_</a> <a href="src/Text.Gigaparsec.Combinator.html#range_" class="link">Source</a> <a href="#v:range_" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p><code>min</code>, the minimum number of times to repeat <code>p</code>, inclusive.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p><code>max</code>, the maximum number of times to repeat <code>p</code>, inclusive.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to repeat.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This combinator parses between <code>min</code> and <code>max</code> occurrences of <code>p</code> but ignoring the results.</p><p>Parses <code>p</code> repeatedly a minimum of <code>min</code> times and up to <code>max</code> times both inclusive. If <code>p</code> fails before
<code>min</code> is reached, then this combinator fails. It is not required for <code>p</code> to fail after the <code>max</code>th parse.
The results are discarded and <code>()</code> is returned instead.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:range_0">Examples</h4><details id="ch:range_0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = range_ 3 5 item
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcd&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcde&quot;
</code></strong>Success ()
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcdef&quot;
</code></strong>Success ()
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:countRange" class="def">countRange</a> <a href="src/Text.Gigaparsec.Combinator.html#countRange" class="link">Source</a> <a href="#v:countRange" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p><code>min</code>, the minimum number of times to repeat <code>p</code>, inclusive.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p><code>max</code>, the maximum number of times to repeat <code>p</code>, inclusive.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>p</code>, the parser to repeat.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></td><td class="doc"><p>the number of times <code>p</code> parsed successfully.</p></td></tr></table></div><div class="doc"><p>This combinator parses between <code>min</code> and <code>max</code> occurrences of <code>p</code>, returning the number of successes.</p><p>Parses <code>p</code> repeatedly a minimum of <code>min</code> times and up to <code>max</code> times both inclusive. If <code>p</code> fails before
<code>min</code> is reached, then this combinator fails. It is not required for <code>p</code> to fail after the <code>max</code>th parse.
The results are discarded and the number of successful parses of <code>p</code>, <code>n</code>, is returned instead, such that
<code>min &lt;= n &lt;= max</code>.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:countRange0">Examples</h4><details id="ch:countRange0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = count 3 5 item
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;ab&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abc&quot;
</code></strong>Success 3
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcd&quot;
</code></strong>Success 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcde&quot;
</code></strong>Success 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;abcdef&quot;
</code></strong>Success 5
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:6" id="g:6"><h1>Selective Combinators</h1></a><div class="doc"><p>These combinators allow for the conditional extraction of a result, or the execution of a parser
 based on another. They are derived from &quot;branch&quot;.</p></div><div class="top"><p class="src"><a id="v:ifS" class="def">ifS</a> <a href="src/Text.Gigaparsec.Combinator.html#ifS" class="link">Source</a> <a href="#v:ifS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p><code>condP</code>, the parser that yields the condition value.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>thenP</code>, the parser to execute if the condition is <code>True</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p><code>elseP</code>, the parser to execute if the condition is <code>False</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that conditionally parses <code>thenP</code> or <code>elseP</code> after <code>condP</code>.</p></td></tr></table></div><div class="doc"><p>This combinator parses one of <code>thenP</code> or <code>elseP</code> depending on the result of parsing <code>condP</code>.</p><p>This is a lifted <code>if</code>-statement. First, parse <code>condP</code>: if it is successful and returns
<code>True</code>, then parse <code>thenP</code>; else, if it returned <code>False</code>, parse <code>elseP</code>; or, if <code>condP</code> failed
then fail. If either of <code>thenP</code> or <code>elseP</code> fail, then this combinator also fails.</p><p>Most useful in conjunction with <em>Registers</em>, as this allows for decisions to be made
based on state.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:ifS0">Examples</h4><details id="ch:ifS0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ifP (pure True) p _ == p
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ifP (pure False) _ p == p
</code></strong></pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:whenS" class="def">whenS</a> <a href="src/Text.Gigaparsec.Combinator.html#whenS" class="link">Source</a> <a href="#v:whenS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p><code>condP</code>, the parser that yields the condition value.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p><code>thenP</code>, the parser to execute if the condition is <code>True</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p>a parser that conditionally parses <code>thenP</code> after <code>condP</code>.</p></td></tr></table></div><div class="doc"><p>This combinator conditionally parses <code>thenP</code> depending on the result of parsing <code>condP</code>.</p><p>This is a lifted <code>if</code>-statement. First, parse <code>condP</code>: if it is successful and returns
<code>True</code>, then parse <code>thenP</code>; else, if it returned <code>False</code> do nothing; or, if <code>condP</code> failed
then fail. If <code>thenP</code> fails, then this combinator also fails.</p><p>Most useful in conjunction with <em>Registers</em>, as this allows for decisions to be made
based on state.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:whenS0">Examples</h4><details id="ch:whenS0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>when (pure True) p == p
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>when (pure False) _ == unit
</code></strong></pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:guardS" class="def">guardS</a> <a href="src/Text.Gigaparsec.Combinator.html#guardS" class="link">Source</a> <a href="#v:guardS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p><code>p</code>, the parser that yields the condition value.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This combinator verfies that the given parser returns <code>True</code>, or else fails.</p><p>First, parse <code>p</code>; if it succeeds then, so long at returns <code>True</code>, this <code>guard p</code> succeeds. Otherwise,
if <code>p</code> either fails, or returns <code>False</code>, <code>guard p</code> will fail.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:guardS0">Examples</h4><details id="ch:guardS0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>guard (pure True) == unit
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>guard (pure False) == empty
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>when (not &lt;$&gt; p) empty == guard p
</code></strong></pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:whileS" class="def">whileS</a> <a href="src/Text.Gigaparsec.Combinator.html#whileS" class="link">Source</a> <a href="#v:whileS" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.18.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p><code>p</code>, the parser to repeatedly parse.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</td><td class="doc"><p>a parser that continues to parse <code>p</code> until it returns <code>False</code>.</p></td></tr></table></div><div class="doc"><p>This combinator repeatedly parses <code>p</code> so long as it returns <code>True</code>.</p><p>This is a lifted <code>while</code>-loop. First, parse <code>p</code>: if it is successful and
returns <code>True</code>, then repeat; else if it returned <code>False</code> stop; or, if it
failed then this combinator fails.</p><p>Most useful in conjunction with <em>Registers</em>, as this allows for decisions to be made
based on state. In particular, this can be used to define the <code>forP</code> combinator.</p><p><em>Since: 0.1.0.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>