<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Gigaparsec.Token.Patterns</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">gigaparsec</span><ul class="links" id="page-menu"><li><a href="src/Text.Gigaparsec.Token.Patterns.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>Jamie Willis, Gigaparsec Maintainers</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Safe Haskell</th><td>Trustworthy</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Gigaparsec.Token.Patterns</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Overloaded Strings</a></li><li><a href="#g:2">Lexer Combinators</a><ul><li><a href="#g:3">Integer Parsers</a><ul><li><a href="#g:4">IntegerParserConfig</a><ul><li><a href="#g:5">Presets</a></li><li><a href="#g:6">Associated Types</a></li></ul></li></ul></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module is currently experimental, and may have bugs depending on the version
of Haskell, or the extensions enabled. Please report any issues to the maintainers.</p><p><em>Since: 0.2.2.0</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:overloadedStrings">overloadedStrings</a> :: <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a> -&gt; <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Dec" title="GHC.Internal.TH.Syntax">Dec</a>]</li><li class="src short"><a href="#v:lexerCombinators">lexerCombinators</a> :: <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a> -&gt; [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Name" title="GHC.Internal.TH.Syntax">Name</a>] -&gt; <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Dec" title="GHC.Internal.TH.Syntax">Dec</a>]</li><li class="src short"><a href="#v:lexerCombinatorsWithNames">lexerCombinatorsWithNames</a> :: <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a> -&gt; [(<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Name" title="GHC.Internal.TH.Syntax">Name</a>, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>)] -&gt; <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Dec" title="GHC.Internal.TH.Syntax">Dec</a>]</li><li class="src short"><a href="#v:generateIntegerParsers">generateIntegerParsers</a> :: <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Dec" title="GHC.Internal.TH.Syntax">Dec</a>]</li><li class="src short"><span class="keyword">data</span> <a href="#t:IntegerParserConfig">IntegerParserConfig</a></li><li class="src short"><a href="#v:prefix">prefix</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:widths">widths</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> (<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Type" title="GHC.Internal.TH.Syntax">Type</a>)</li><li class="src short"><a href="#v:bases">bases</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a></li><li class="src short"><a href="#v:includeUnbounded">includeUnbounded</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:signedOrUnsigned">signedOrUnsigned</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:SignedOrUnsigned" title="Text.Gigaparsec.Token.Patterns">SignedOrUnsigned</a></li><li class="src short"><a href="#v:collatedParser">collatedParser</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:emptyIntegerParserConfig">emptyIntegerParserConfig</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></li><li class="src short"><a href="#v:emptySignedIntegerParserConfig">emptySignedIntegerParserConfig</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></li><li class="src short"><a href="#v:emptyUnsignedIntegerParserConfig">emptyUnsignedIntegerParserConfig</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:SignedOrUnsigned">SignedOrUnsigned</a><ul class="subs"><li>= <a href="#v:Signed">Signed</a></li><li>| <a href="#v:Unsigned">Unsigned</a></li></ul></li><li class="src short"><a href="#v:allBases">allBases</a> :: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:IntLitBase">IntLitBase</a><ul class="subs"><li>= <a href="#v:Binary">Binary</a></li><li>| <a href="#v:Octal">Octal</a></li><li>| <a href="#v:Decimal">Decimal</a></li><li>| <a href="#v:Hexadecimal">Hexadecimal</a></li></ul></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Overloaded Strings</h1></a><div class="top"><p class="src"><a id="v:overloadedStrings" class="def">overloadedStrings</a> <a href="src/Text.Gigaparsec.Token.Patterns.html#overloadedStrings" class="link">Source</a> <a href="#v:overloadedStrings" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a></td><td class="doc"><p>the quoted <code><a href="Text-Gigaparsec-Token-Lexer.html#v:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code></p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Dec" title="GHC.Internal.TH.Syntax">Dec</a>]</td><td class="doc"><p>a synthesised <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:IsString" title="Data.String">IsString</a></code> instance.</p></td></tr></table></div><div class="doc"><p>When given a quoted reference to a <code><a href="Text-Gigaparsec-Token-Lexer.html#v:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code>, for example
<code class="inline-code">[|lexer|]</code>, this function will synthesise an <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:IsString" title="Data.String">IsString</a></code> instance that will
allow string literals to serve as <code class="inline-code">Parsec ()</code>. These literals will parse symbols
in the language associated with the lexer, followed by consuming valid whitespace.</p><p><em>Since: 0.2.2.0</em></p></div></div><a href="#g:2" id="g:2"><h1>Lexer Combinators</h1></a><div class="doc"><p>These functions will generate combinators for parsing things like identifiers, keywords, etc,
  as described by a <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code>.</p><p>The combinators will behave like their counterparts in <a href="Text-Gigaparsec-Token-Lexer.html">Text.Gigaparsec.Token.Lexer</a>,
  except they do not need to be given a lexer(/a subcomponent of a lexer) as an argument.</p><ul><li><code><a href="Text-Gigaparsec-Token-Patterns.html#v:lexerCombinators" title="Text.Gigaparsec.Token.Patterns">lexerCombinators</a></code> will generate these lexer combinators using the same name as the original combinators.</li><li><code><a href="Text-Gigaparsec-Token-Patterns.html#v:lexerCombinatorsWithNames" title="Text.Gigaparsec.Token.Patterns">lexerCombinatorsWithNames</a></code> lets you rename the generated combinator; otherwise it behaves exactly as <code><a href="Text-Gigaparsec-Token-Patterns.html#v:lexerCombinators" title="Text.Gigaparsec.Token.Patterns">lexerCombinators</a></code>.</li><li><code><a href="Text-Gigaparsec-Token-Patterns.html#v:generateIntegerParsers" title="Text.Gigaparsec.Token.Patterns">generateIntegerParsers</a></code> will generate lexer combinators for integer literals.
    If you try to generate a <code><a href="Text-Gigaparsec-Token-Lexer.html#v:decimal" title="Text.Gigaparsec.Token.Lexer">decimal</a></code> parser using <code><a href="Text-Gigaparsec-Token-Patterns.html#v:lexerCombinators" title="Text.Gigaparsec.Token.Patterns">lexerCombinators</a></code> or <code><a href="Text-Gigaparsec-Token-Patterns.html#v:lexerCombinatorsWithNames" title="Text.Gigaparsec.Token.Patterns">lexerCombinatorsWithNames</a></code>,
    you will get an error.</li></ul><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:noid:0">Examples:</h4><details id="ch:noid:0"><summary class="hide-when-js-enabled">Expand</summary><p>The combinator &quot;Text.Gigaparsec.Token.Lexer.identifier&quot; is used for parsing identifiers, and has the type,</p><pre>Lexer.identifier :: Lexer -&gt; Parsec String</pre><p>It is annoying to have to feed the lexer as the initial argument, as this will be fixed throughout the parser.
  Usually, one ends up writing their own combinator:</p><pre>identifier :: Parsec String
identifier = Lexer.identifier lexer</pre><p>Writing these by hand is tedious; especially if we wish to use multiple such combinators.
  This is where <code><a href="Text-Gigaparsec-Token-Patterns.html#v:lexerCombinators" title="Text.Gigaparsec.Token.Patterns">lexerCombinators</a></code> comes in:</p><pre>$(lexerCombinators [| lexer |] ['Lexer.identifier])</pre><p>will generate the combinator,</p><pre>identifier :: Parsec String
identifier = Lexer.identifier lexer</pre><p>If we wish to use multiple combinators, we just add each one to the list.
  For example,</p><pre>$(lexerCombinators [| lexer |] ['Lexer.identifier, 'Lexer.fully, 'Lexer.softKeyword, 'Lexer.softOperator])</pre></details></div><div class="top"><p class="src"><a id="v:lexerCombinators" class="def">lexerCombinators</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinators" class="link">Source</a> <a href="#v:lexerCombinators" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a></td><td class="doc"><p>The quoted <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code>.</p></td></tr><tr><td class="src">-&gt; [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Name" title="GHC.Internal.TH.Syntax">Name</a>]</td><td class="doc"><p>The combinators to generate.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Dec" title="GHC.Internal.TH.Syntax">Dec</a>]</td><td class="doc"><p>Definitions of the generated combinators.</p></td></tr></table></div><div class="doc"><p>Generates the specified lexer combinators using a quoted <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code>, for example, <code class="inline-code">[|lexer|]</code>.</p><p>The generated combinators will behave like their counterparts in <a href="Text-Gigaparsec-Token-Lexer.html">Text.Gigaparsec.Token.Lexer</a>, 
except they won't require a lexer (or subcomponents thereof) to be supplied as an argument.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:lexerCombinators0">Usage:</h4><details id="ch:lexerCombinators0"><summary class="hide-when-js-enabled">Expand</summary><pre>import Text.Gigaparsec.Token.Lexer qualified as Lexer
import Text.Gigaparsec.Token.Lexer (Lexer)
lexer :: Lexer
$(lexerCombinators [| lexer |] ['Lexer.lexeme, 'Lexer.fully, 'Lexer.identifier, 'Lexer.stringLiteral])</pre><p>This will generate the following combinators/functions:</p><pre>lexeme :: Lexeme
fully :: &#8704; a . Parsec a -&gt; Parsec a
identifier :: Parsec String
stringLiteral :: TextParsers String</pre><p>These will behave like their counterparts in <a href="Text-Gigaparsec-Token-Lexer.html">Text.Gigaparsec.Token.Lexer</a>, except they will not need
a <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code> (or its subcomponents) as an argument.</p></details><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:lexerCombinatorsWithNames" class="def">lexerCombinatorsWithNames</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinatorsWithNames" class="link">Source</a> <a href="#v:lexerCombinatorsWithNames" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a></td><td class="doc"><p>The quoted <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code>.</p></td></tr><tr><td class="src">-&gt; [(<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Name" title="GHC.Internal.TH.Syntax">Name</a>, <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>)]</td><td class="doc"><p>The combinators to generate with the given name.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Dec" title="GHC.Internal.TH.Syntax">Dec</a>]</td><td class="doc"><p>Definitions of the generated combinators.</p></td></tr></table></div><div class="doc"><p>Generates the specified lexer combinators with the given names using a quoted <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code>, for example, <code class="inline-code">[|lexer|]</code>.</p><p>The generated combinators will behave like their counterparts in <a href="Text-Gigaparsec-Token-Lexer.html">Text.Gigaparsec.Token.Lexer</a>, 
except they won't require a lexer (or subcomponents thereof) to be supplied as an argument.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:lexerCombinatorsWithNames0">Usage:</h4><details id="ch:lexerCombinatorsWithNames0"><summary class="hide-when-js-enabled">Expand</summary><pre>import Text.Gigaparsec.Token.Lexer qualified as Lexer
import Text.Gigaparsec.Token.Lexer (Lexer)
lexer :: Lexer
$(lexerCombinatorsWithNames [| lexer |] [('Lexer.lexeme, &quot;myLexeme&quot;), ('Lexer.fully, &quot;myFully&quot;)])</pre><p>This will generate the following combinators/functions:</p><pre>myLexeme :: Lexeme
myFully :: &#8704; a . Parsec a -&gt; Parsec a</pre><p>These will behave like their counterparts in <a href="Text-Gigaparsec-Token-Lexer.html">Text.Gigaparsec.Token.Lexer</a>, except they will not need
a <code><a href="Text-Gigaparsec-Token-Lexer.html#t:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code> (or its subcomponents) as an argument.</p></details><p><em>Since: 0.4.0.0</em></p></div></div><a href="#g:3" id="g:3"><h2>Integer Parsers</h2></a><div class="top"><p class="src"><a id="v:generateIntegerParsers" class="def">generateIntegerParsers</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#generateIntegerParsers" class="link">Source</a> <a href="#v:generateIntegerParsers" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Exp" title="GHC.Internal.TH.Syntax">Exp</a></td><td class="doc"><p>The quoted <code><a href="Text-Gigaparsec-Token-Lexer.html#v:Lexer" title="Text.Gigaparsec.Token.Lexer">Lexer</a></code></p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></td><td class="doc"><p>The configuration describing what numeric combinators to produce.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> [<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Dec" title="GHC.Internal.TH.Syntax">Dec</a>]</td><td class="doc"><p>The declarations of the specified combinators.</p></td></tr></table></div><div class="doc"><p>This function automatically generates lexer combinators for handling signed or unsigned integers.</p><p>See <code><a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></code> for how to configure which combinators are generated.</p><p><em>Note:</em> Due to staging restrictions in Template Haskell, the <code><a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></code> must be
defined in a separate module to where this function is used.
Multiple configs can be defined in the same module.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:generateIntegerParsers0">Usage:</h4><details id="ch:generateIntegerParsers0"><summary class="hide-when-js-enabled">Expand</summary><p>First, the config must be defined in another module.
You can define multiple configs in the same module, as long as they are used in a different module.</p><pre>{-# LANGUAGE TemplateHaskell, OverloadedLists #-}
module IntegerConfigs where
&#8230;
uIntCfg :: IntegerParserConfig
uIntCfg = emptyUnsignedIntegerParserConfig {
    prefix = &quot;u&quot;,
    widths = [(B8, [t| Word8 |]), (B32, [t| Word32 |])],
    bases = [Hexadecimal, Decimal, Binary],
    includeUnbounded = False,
    signedOrUnsigned = Unsigned,
    collatedParser = Just &quot;natural&quot;
  }</pre><p>Then, we can feed this config, along with a quoted lexer, to <code><a href="Text-Gigaparsec-Token-Patterns.html#v:generateIntegerParsers" title="Text.Gigaparsec.Token.Patterns">generateIntegerParsers</a></code>:</p><pre>{-# LANGUAGE TemplateHaskell #-}
module Lexer where
import IntegerConfigs (uIntCfg)
&#8230;
lexer :: Lexer
lexer = &#8230;

$(generateIntegerParsers [| lexer |] uIntCfg)</pre><p>This will generate the following combinators,</p><pre>   ubinary8 :: Parsec Word8
   udecimal8 :: Parsec Word8
   uhexadecimal8 :: Parsec Word8
   ubinary32 :: Parsec Word32
   udecimal3 :: Parsec Word32
   uhexadecimal32 :: Parsec Word32
   natural8 :: Parsec Word8
   natural32 :: Parsec Word32</pre></details><p><em>Since: 0.4.0.0</em></p></div></div><a href="#g:4" id="g:4"><h3>IntegerParserConfig</h3></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:IntegerParserConfig" class="def">IntegerParserConfig</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#IntegerParserConfig" class="link">Source</a> <a href="#t:IntegerParserConfig" class="selflink">#</a></p><div class="doc"><p>This type describes how to generate numeric parsers with <code><a href="Text-Gigaparsec-Token-Patterns.html#v:generateIntegerParsers" title="Text.Gigaparsec.Token.Patterns">generateIntegerParsers</a></code>.
This includes configuration for which bases and bitwidths to support, and whether to generate
parsers that can handle multiple bases. </p><p>See the <code><a href="Text-Gigaparsec-Token-Patterns.html#v:emptyIntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">emptyIntegerParserConfig</a></code> smart constructor to define a <code><a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></code>.</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:prefix" class="def">prefix</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#prefix" class="link">Source</a> <a href="#v:prefix" class="selflink">#</a></p><div class="doc"><p>The string to prepend to each generated parser's name (except for the <code><a href="Text-Gigaparsec-Token-Patterns.html#v:collatedParser" title="Text.Gigaparsec.Token.Patterns">collatedParser</a></code>, if specified).</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:widths" class="def">widths</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="Text-Gigaparsec-Token-Errors.html#t:Bits" title="Text.Gigaparsec.Token.Errors">Bits</a> (<a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Q" title="GHC.Internal.TH.Syntax">Q</a> <a href="https://hackage.haskell.org/package/ghc-internal-9.1202.0/docs/GHC-Internal-TH-Syntax.html#t:Type" title="GHC.Internal.TH.Syntax">Type</a>) <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#widths" class="link">Source</a> <a href="#v:widths" class="selflink">#</a></p><div class="doc"><p>The fixed bit-widths (8-bit, 16-bit, etc/) for which to generate parsers.</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:bases" class="def">bases</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#bases" class="link">Source</a> <a href="#v:bases" class="selflink">#</a></p><div class="doc"><p>The numeric bases (binary, octal, etc) for which to generate parsers.</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:includeUnbounded" class="def">includeUnbounded</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#includeUnbounded" class="link">Source</a> <a href="#v:includeUnbounded" class="selflink">#</a></p><div class="doc"><p>When <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, generate the unbounded integer parsers (e.g. <code><a href="Text-Gigaparsec-Token-Lexer.html#v:decimal" title="Text.Gigaparsec.Token.Lexer">decimal</a></code>) for each base specified in <code><a href="Text-Gigaparsec-Token-Patterns.html#v:bases" title="Text.Gigaparsec.Token.Patterns">bases</a></code>.</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:signedOrUnsigned" class="def">signedOrUnsigned</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:SignedOrUnsigned" title="Text.Gigaparsec.Token.Patterns">SignedOrUnsigned</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#signedOrUnsigned" class="link">Source</a> <a href="#v:signedOrUnsigned" class="selflink">#</a></p><div class="doc"><p>Whether or not the parsers to generate are for <code><a href="Text-Gigaparsec-Token-Patterns.html#v:Signed" title="Text.Gigaparsec.Token.Patterns">Signed</a></code> or <code><a href="Text-Gigaparsec-Token-Patterns.html#v:Unsigned" title="Text.Gigaparsec.Token.Patterns">Unsigned</a></code> integers.</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:collatedParser" class="def">collatedParser</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#collatedParser" class="link">Source</a> <a href="#v:collatedParser" class="selflink">#</a></p><div class="doc"><p>Generate a generic integer parser with the given name,
    at each width (including unbounded) specified by <code><a href="Text-Gigaparsec-Token-Patterns.html#v:widths" title="Text.Gigaparsec.Token.Patterns">widths</a></code>, that
    is able to parse each base specified in <code><a href="Text-Gigaparsec-Token-Patterns.html#v:bases" title="Text.Gigaparsec.Token.Patterns">bases</a></code>.</p><ul><li>If <code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>, do not generate such a parser.</li><li>If <code class="inline-code"><code><a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code> &quot;&quot;</code>, then the default name will be <code class="inline-code">&quot;natural&quot;</code>  or <code class="inline-code">&quot;integer&quot;</code> when <code><a href="Text-Gigaparsec-Token-Patterns.html#v:signedOrUnsigned" title="Text.Gigaparsec.Token.Patterns">signedOrUnsigned</a></code>
      is <code><a href="Text-Gigaparsec-Token-Patterns.html#v:Unsigned" title="Text.Gigaparsec.Token.Patterns">Unsigned</a></code> or <code><a href="Text-Gigaparsec-Token-Patterns.html#v:Signed" title="Text.Gigaparsec.Token.Patterns">Signed</a></code>, respectively.</li></ul><p><em>Since: 0.4.0.0</em></p></div></div><a href="#g:5" id="g:5"><h4>Presets</h4></a><div class="top"><p class="src"><a id="v:emptyIntegerParserConfig" class="def">emptyIntegerParserConfig</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#emptyIntegerParserConfig" class="link">Source</a> <a href="#v:emptyIntegerParserConfig" class="selflink">#</a></p><div class="doc"><p>An empty <code><a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></code>, which will generate nothing when given to <code><a href="Text-Gigaparsec-Token-Patterns.html#v:generateIntegerParsers" title="Text.Gigaparsec.Token.Patterns">generateIntegerParsers</a></code>.
Extend this using record updates, to tailor a config to your liking.</p><p>By default, the <code><a href="Text-Gigaparsec-Token-Patterns.html#v:prefix" title="Text.Gigaparsec.Token.Patterns">prefix</a></code> field is the empty string, which will likely cause issues if you do not override this.</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:emptySignedIntegerParserConfig" class="def">emptySignedIntegerParserConfig</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#emptySignedIntegerParserConfig" class="link">Source</a> <a href="#v:emptySignedIntegerParserConfig" class="selflink">#</a></p><div class="doc"><p>An empty <code><a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></code> for <code><a href="Text-Gigaparsec-Token-Patterns.html#v:Signed" title="Text.Gigaparsec.Token.Patterns">Signed</a></code> integers, which will generate nothing when given to <code><a href="Text-Gigaparsec-Token-Patterns.html#v:generateIntegerParsers" title="Text.Gigaparsec.Token.Patterns">generateIntegerParsers</a></code>.
Extend this using record updates, to tailor a config to your liking.</p><p>By default, the <code><a href="Text-Gigaparsec-Token-Patterns.html#v:prefix" title="Text.Gigaparsec.Token.Patterns">prefix</a></code> field is the empty string, which will likely cause issues if you do not override this.</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:emptyUnsignedIntegerParserConfig" class="def">emptyUnsignedIntegerParserConfig</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#emptyUnsignedIntegerParserConfig" class="link">Source</a> <a href="#v:emptyUnsignedIntegerParserConfig" class="selflink">#</a></p><div class="doc"><p>An empty <code><a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></code> for <code><a href="Text-Gigaparsec-Token-Patterns.html#v:Unsigned" title="Text.Gigaparsec.Token.Patterns">Unsigned</a></code> integers, which will generate nothing when given to <code><a href="Text-Gigaparsec-Token-Patterns.html#v:generateIntegerParsers" title="Text.Gigaparsec.Token.Patterns">generateIntegerParsers</a></code>.
Extend this using record updates, to tailor a config to your liking.</p><p>By default, the <code><a href="Text-Gigaparsec-Token-Patterns.html#v:prefix" title="Text.Gigaparsec.Token.Patterns">prefix</a></code> field is the empty string, which will likely cause issues if you do not override this.</p><p><em>Since: 0.4.0.0</em></p></div></div><a href="#g:6" id="g:6"><h4>Associated Types</h4></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SignedOrUnsigned" class="def">SignedOrUnsigned</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#SignedOrUnsigned" class="link">Source</a> <a href="#t:SignedOrUnsigned" class="selflink">#</a></p><div class="doc"><p>Determines if the combinators are for <code><a href="Text-Gigaparsec-Token-Patterns.html#v:Signed" title="Text.Gigaparsec.Token.Patterns">Signed</a></code> or <code><a href="Text-Gigaparsec-Token-Patterns.html#v:Unsigned" title="Text.Gigaparsec.Token.Patterns">Unsigned</a></code> int literals.</p><p><em>Since: 0.4.0.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Signed" class="def">Signed</a></td><td class="doc"><p>The int literal is signed, so can be negative.</p><p><em>Since: 0.4.0.0</em></p></td></tr><tr><td class="src"><a id="v:Unsigned" class="def">Unsigned</a></td><td class="doc"><p>The literal is unsigned, so is always non-negative.</p><p><em>Since: 0.4.0.0</em></p></td></tr></table></div></div><div class="top"><p class="src"><a id="v:allBases" class="def">allBases</a> :: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#allBases" class="link">Source</a> <a href="#v:allBases" class="selflink">#</a></p><div class="doc"><p>Set of all possible <code><a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a></code>s.</p><p><em>Since: 0.4.0.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:IntLitBase" class="def">IntLitBase</a> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#IntLitBase" class="link">Source</a> <a href="#t:IntLitBase" class="selflink">#</a></p><div class="doc"><p>The base of a numeric literal.</p><p>Used in <code><a href="Text-Gigaparsec-Token-Patterns.html#t:IntegerParserConfig" title="Text.Gigaparsec.Token.Patterns">IntegerParserConfig</a></code> to specify which parsers for which bases should be generated.</p><p><em>Since: 0.4.0.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Binary" class="def">Binary</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Octal" class="def">Octal</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Decimal" class="def">Decimal</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a id="v:Hexadecimal" class="def">Hexadecimal</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:IntLitBase">Instances</h4><details id="i:IntLitBase" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:IntLitBase:Show:1"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:Show" title="Prelude">Show</a> <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a></span> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#line-115" class="link">Source</a> <a href="#t:IntLitBase" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:IntLitBase:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal-Token-Patterns-IntegerParsers.html">Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Prelude.html#t:ShowS" title="Prelude">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:IntLitBase:Eq:2"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a></span> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#line-115" class="link">Source</a> <a href="#t:IntLitBase" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:IntLitBase:Eq:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal-Token-Patterns-IntegerParsers.html">Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:IntLitBase:Ord:3"></span> <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a></span> <a href="src/Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers.html#line-115" class="link">Source</a> <a href="#t:IntLitBase" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:IntLitBase:Ord:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Text-Gigaparsec-Internal-Token-Patterns-IntegerParsers.html">Text.Gigaparsec.Internal.Token.Patterns.IntegerParsers</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:compare">compare</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="#v:compare" class="selflink">#</a></p><p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60-" class="selflink">#</a></p><p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62-" class="selflink">#</a></p><p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62--61-" class="selflink">#</a></p><p class="src"><a href="#v:max">max</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> <a href="#v:max" class="selflink">#</a></p><p class="src"><a href="#v:min">min</a> :: <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> -&gt; <a href="Text-Gigaparsec-Token-Patterns.html#t:IntLitBase" title="Text.Gigaparsec.Token.Patterns">IntLitBase</a> <a href="#v:min" class="selflink">#</a></p></div></details></td></tr></table></details></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>