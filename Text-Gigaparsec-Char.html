<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Gigaparsec.Char</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">gigaparsec-0.3.0.0: Refreshed parsec-style library for compatibility with Scala parsley</span><ul class="links" id="page-menu"><li id="quick-jump-button"><a href="#">Quick Jump</a></li><li><a href="src/Text.Gigaparsec.Char.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>Jamie Willis, Gigaparsec Maintainers</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Gigaparsec.Char</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Core Combinators</a></li><li><a href="#g:2">Character Class Combinators</a></li><li><a href="#g:3">String Combinators</a></li><li><a href="#g:4">Specific Character Parsers</a></li><li><a href="#g:5">Whitespace Skipping Parsers</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains many parsers to do with reading one or more characters. Almost every parser
will need something from this module.</p><p>In particular, this module contains: combinators that can read specific characters; combinators that
represent character classes and their negations; combinators for reading specific strings; as well
as a selection of pre-made parsers to parse specific kinds of character, like digits and letters.</p><p><em>Since: 0.1.0.0</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:char">char</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:item">item</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:satisfy">satisfy</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:satisfyMap">satisfyMap</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:oneOf">oneOf</a> :: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:noneOf">noneOf</a> :: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:string">string</a> :: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:stringOfMany">stringOfMany</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:stringOfSome">stringOfSome</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:strings">strings</a> :: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:trie">trie</a> :: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> (<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</li><li class="src short"><a href="#v:bit">bit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:crlf">crlf</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:digit">digit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:endOfLine">endOfLine</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:hexDigit">hexDigit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:letter">letter</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:letterOrDigit">letterOrDigit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:lower">lower</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:newline">newline</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:octDigit">octDigit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:space">space</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:tab">tab</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:upper">upper</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:whitespace">whitespace</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></li><li class="src short"><a href="#v:spaces">spaces</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li><li class="src short"><a href="#v:whitespaces">whitespaces</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Core Combinators</h1></a><div class="doc"><p>These are the most primitive combinators for consuming input capable of any input reading tasks.</p></div><div class="top"><p class="src"><a id="v:char" class="def">char</a> <a href="src/Text.Gigaparsec.Char.html#char" class="link">Source</a> <a href="#v:char" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>the character to parse, <code>c</code>.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>a parser that tries to read a single <code>c</code>, or fails.</p></td></tr></table></div><div class="doc"><p>This combinator tries to parse a single specific character <code>c</code> from the input.</p><p>Attempts to read the given character <code>c</code> from the input stream at the current position. If this
character can be found, it is consumed and returned. Otherwise, no input is consumed and this
combinator will fail.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:char0">Examples</h4><details id="ch:char0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (char 'a') &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (char 'a') &quot;a&quot;
</code></strong>Success 'a'
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (char 'a') &quot;ba&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:item" class="def">item</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#item" class="link">Source</a> <a href="#v:item" class="selflink">#</a></p><div class="doc"><p>This parser will parse <strong>any</strong> single character from the input, failing if there is no input
remaining.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:satisfy" class="def">satisfy</a> <a href="src/Text.Gigaparsec.Char.html#satisfy" class="link">Source</a> <a href="#v:satisfy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>the predicate, <code>pred</code>, to test the next character against, should one
 exist.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>a parser that tries to read a single character <code>c</code>, such that <code>pred c</code>
 is true, or fails.</p></td></tr></table></div><div class="doc"><p>This combinator tries to parse a single character from the input that matches the given predicate.</p><p>Attempts to read a character from the input and tests it against the predicate <code>pred</code>. If a character
<code>c</code> can be read and <code>pred c</code> is true, then <code>c</code> is consumed and returned. Otherwise, no input is
consumed and this combinator will fail.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:satisfy0">Examples</h4><details id="ch:satisfy0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (satisfy Data.Char.isDigit) &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (satisfy Data.Char.isDigit) &quot;7&quot;
</code></strong>Success '7'
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (satisfy Data.Char.isDigit) &quot;a5&quot;
</code></strong>Failure ..
</pre><p>Roughly speaking:</p><pre>char c = satisfy (== c)
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:satisfyMap" class="def">satisfyMap</a> <a href="src/Text.Gigaparsec.Char.html#satisfyMap" class="link">Source</a> <a href="#v:satisfyMap" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</td><td class="doc"><p>the function to test the next character against and transform it with, should one exist.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This combinator tries to parse and process a character from the input if it is defined for the given function.</p><p>Attempts to read a character from the input and tests to see if it is in the domain of <code>f</code>. If a character
<code>c</code> can be read and <code>f c</code> returns a <code>Just</code>, then <code>c</code> is consumed and <code>Just (f c)</code> is returned. Otherwise,
no input is consumed and this combinator will fail.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:satisfyMap0">Examples</h4><details id="ch:satisfyMap0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let digit = satisfyMap (\c -&gt; if isDigit c then Just (digitToInt c) else Nothing)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String digit &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String digit &quot;7&quot;
</code></strong>Success 7
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String digit &quot;a5&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:2" id="g:2"><h1>Character Class Combinators</h1></a><div class="doc"><p>These combinators allow for working with <em>character classes</em>. This means that a set, or range,
 of characters can be specified, and the combinator will return a parser that matches one of
 those characters (or conversely, any character that is <em>not</em> in that set). The parsed character
 is always returned.</p></div><div class="top"><p class="src"><a id="v:oneOf" class="def">oneOf</a> <a href="src/Text.Gigaparsec.Char.html#oneOf" class="link">Source</a> <a href="#v:oneOf" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>the set of character, <code>cs</code>, to check.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>a parser that parses one of the member of the set <code>cs</code>.</p></td></tr></table></div><div class="doc"><p>This combinator tries to parse any character from supplied set of characters <code>cs</code>, returning it if
successful.</p><p>If the next character in the input is a member of the set <code>cs</code>, it is consumed and returned.
Otherwise, no input is consumed and the combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:oneOf0">Examples</h4><details id="ch:oneOf0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = oneOf (Set.fromList ['a'..'c'])
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;a&quot;
</code></strong>Success 'a'
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;c&quot;
</code></strong>Success 'c'
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;xb&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:noneOf" class="def">noneOf</a> <a href="src/Text.Gigaparsec.Char.html#noneOf" class="link">Source</a> <a href="#v:noneOf" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>the set, <code>cs</code>, of characters to check.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>a parser that parses one character that is not a member of the set <code>cs</code>.</p></td></tr></table></div><div class="doc"><p>This combinator tries to parse any character <strong>not</strong> from supplied set of characters <code>cs</code>,
returning it if successful.</p><p>If the next character in the input is not a member of the set <code>cs</code>, it is consumed and returned.
Otherwise, no input is consumed and the combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:noneOf0">Examples</h4><details id="ch:noneOf0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = noneOf (Set.from ['a'..'c'])
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;a&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;c&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;xb&quot;
</code></strong>Success 'x'
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:3" id="g:3"><h1>String Combinators</h1></a><div class="doc"><p>These combinators allow for working with, or building, strings. This means that they can parse
 specific strings, specific sets of strings, or can read characters repeatedly to generate
 strings. They are united in all returning <code><a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></code> as their result.</p></div><div class="top"><p class="src"><a id="v:string" class="def">string</a> <a href="src/Text.Gigaparsec.Char.html#string" class="link">Source</a> <a href="#v:string" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>the string, <code>s</code>, to be parsed from the input</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>a parser that either parses the string <code>s</code> or fails at the first
 mismatched character.</p></td></tr></table></div><div class="doc"><p>This combinator attempts to parse a given string from the input, and fails otherwise.</p><p>Attempts to read the given string <em>completely</em> from the input at the current position.
If the string is present, then the parser succeeds, and the entire string is consumed
from the input. Otherwise, if the input has too few characters remaining, or not all
the characters matched, the parser fails. On failure, <strong>all</strong> the characters that were
matched are consumed from the input.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:string0">Examples</h4><details id="ch:string0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (string &quot;abc&quot;) &quot;&quot;
</code></strong>Failure ..
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (string &quot;abc&quot;) &quot;abcd&quot;
</code></strong>Success &quot;abc&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String (string &quot;abc&quot;) &quot;xabc&quot;
</code></strong>Failure ..
</pre></details><h4>Notes</h4><ul><li>The error messages generated by <code><a href="Text-Gigaparsec-Char.html#v:string" title="Text.Gigaparsec.Char">string</a></code> do not reflect how far into the input it managed
  to get: this is because the error being positioned at the start of the string is more
  natural. However, input <strong>will</strong> still be consumed for purposes of backtracking.</li></ul><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:stringOfMany" class="def">stringOfMany</a> <a href="src/Text.Gigaparsec.Char.html#stringOfMany" class="link">Source</a> <a href="#v:stringOfMany" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>the predicate, <code>pred</code>, to test characters against.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>a parser that returns the span of characters satisfying <code>pred</code></p></td></tr></table></div><div class="doc"><p>This combinator parses characters matching the given predicate <strong>zero</strong> or more times, collecting
the results into a string.</p><p>Repeatly reads characters that satisfy the given predicate <code>pred</code>. When no more characters
can be successfully read, the results are stitched together into a <code>String</code> and returned.
This combinator can never fail, since <code>satisfy</code> can never fail having consumed input.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:stringOfMany0">Examples</h4><details id="ch:stringOfMany0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ident = letter &lt;:&gt; stringOfMany isAlphaNum
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String ident &quot;abdc9d&quot;
</code></strong>Success &quot;abdc9d&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String ident &quot;a&quot;
</code></strong>Success &quot;a&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @Stringr ident &quot;9&quot;
</code></strong>Failure ..
</pre></details><h4>Notes</h4><ul><li>this acts exactly like <code>stringOfMany (satisfy pred)</code>, but may be more efficient.</li><li>analogous to the <code>megaparsec</code> <code>takeWhileP</code> combinator.</li></ul><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:stringOfSome" class="def">stringOfSome</a> :: (<a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Text.Gigaparsec.Char.html#stringOfSome" class="link">Source</a> <a href="#v:stringOfSome" class="selflink">#</a></p><div class="doc"><p>This combinator parses characters matching the given predicate <strong>one</strong> or more times, collecting
the results into a string.</p><p>Repeatly reads characters that satisfy the given predicate <code>pred</code>. When no more characters
can be successfully read, the results are stitched together into a <code>String</code> and returned.
This combinator can never fail having consumed input, since <code>satisfy</code> can never fail having
consumed input.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:stringOfSome0">Examples</h4><details id="ch:stringOfSome0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let ident = stringOfSome isAlpha
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String ident &quot;abdc9d&quot;
</code></strong>Success &quot;abdc&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String ident &quot;a&quot;
</code></strong>Success &quot;a&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @Stringr ident &quot;9&quot;
</code></strong>Failure ..
</pre></details><h4>Notes</h4><ul><li>this acts exactly like <code>stringOfMany (satisfy pred)</code>, but may be more efficient.</li><li>analogous to the <code>megaparsec</code> <code>takeWhileP</code> combinator.</li></ul><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:strings" class="def">strings</a> <a href="src/Text.Gigaparsec.Char.html#strings" class="link">Source</a> <a href="#v:strings" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Set.html#t:Set" title="Data.Set">Set</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>the strings to try to parse.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>a parser that tries to parse all the given strings returning the
 longest one that matches.</p></td></tr></table></div><div class="doc"><p>This combinator tries to parse each of the strings <code>strs</code>, until one of them succeeds.</p><p>Unlike <code><a href="Text-Gigaparsec-Combinator.html#v:choice" title="Text.Gigaparsec.Combinator">choice</a></code>, this combinator will not necessarily parse the strings in the
order provided. It will avoid strings that have another string as a prefix first, so that it has
<em>Longest Match</em> semantics. It will try to minimise backtracking too, making it a much more efficient
option than <code>choice . map atomic</code>.</p><p>The longest succeeding string will be returned. If no strings match then the combinator fails.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:strings0">Examples</h4><details id="ch:strings0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = strings (Set.fromList [&quot;hell&quot;, &quot;hello&quot;, &quot;goodbye&quot;, &quot;g&quot;, &quot;abc&quot;])
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;hell&quot;
</code></strong>Success &quot;hell&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;hello&quot;
</code></strong>Success &quot;hello&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;good&quot;
</code></strong>Success &quot;g&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;goodbye&quot;
</code></strong>Success &quot;goodbye&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;a&quot;
</code></strong>Failure ..
</pre></details><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:trie" class="def">trie</a> <a href="src/Text.Gigaparsec.Char.html#trie" class="link">Source</a> <a href="#v:trie" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/containers-0.6.8/docs/Data-Map-Strict.html#t:Map" title="Data.Map.Strict">Map</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> (<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a)</td><td class="doc"><p>the key-value pairs to try to parse.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> a</td><td class="doc"><p>a parser that tries to parse all the given key-value pairs,
 returning the (possibly failing) result of the value that
 corresponds to the longest matching key.</p></td></tr></table></div><div class="doc"><p>This combinator tries to parse each of the key-value pairs <code>kvs</code>, until one of them succeeds.</p><p>Each key-value pair in the map provided to this combinator is a string and a parser to perform if
that string can be parsed. Keys that are a prefix of another key are avoided, so that the parser
overall has <em>Longest Match</em> semantics. It will try and minimise backtracking too, making it an
efficient option.</p><h4 class="subheading details-toggle-control details-toggle" data-details-id="ch:trie0">Examples</h4><details id="ch:trie0"><summary class="hide-when-js-enabled">Expand</summary><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let p = trie $ Map.fromList [ (&quot;hell&quot;, pure 4)
</code></strong>                                , (&quot;hello&quot;, pure 5)
                                , (&quot;goodbye&quot;, pure 7)
                                , (&quot;g&quot;, pure 1)
                                , (&quot;abc&quot;, pure 3)
                                ]
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;hell&quot;
</code></strong>Success 4
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;hello&quot;
</code></strong>Success 5
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;good&quot;
</code></strong>Success 1
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;goodbye&quot;
</code></strong>Success 7
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>parse @String p &quot;a&quot;
</code></strong>Failure ..
</pre></details><h4>Notes</h4><ul><li>The scope of any backtracking performed is isolated to the key itself, as it is assumed
  that once a key parses correctly, the branch has been committed to. Putting an <code><a href="Text-Gigaparsec.html#v:atomic" title="Text.Gigaparsec">atomic</a></code>
  around the values will not affect this behaviour.</li></ul><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:4" id="g:4"><h1>Specific Character Parsers</h1></a><div class="doc"><p>These parsers are special cases of <code><a href="Text-Gigaparsec-Char.html#v:satisfy" title="Text.Gigaparsec.Char">satisfy</a></code> or <code><a href="Text-Gigaparsec-Char.html#v:char" title="Text.Gigaparsec.Char">char</a></code>. They are worth
 using, as they are given special error labelling, producing nicer error messages than their
 primitive counterparts.</p></div><div class="top"><p class="src"><a id="v:bit" class="def">bit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#bit" class="link">Source</a> <a href="#v:bit" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a binary digit (bit) and returns it if successful.</p><p>A bit is either <code>'0'</code> or <code>'1'</code>.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:crlf" class="def">crlf</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#crlf" class="link">Source</a> <a href="#v:crlf" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a <code>CRLF</code> newline character pair, returning <code>'\n'</code> if successful.</p><p>A <code>CRLF</code> character is the pair of carriage return (<code>'\r'</code>) and line feed (<code>'\n'</code>). These
two characters will be parsed together or not at all. The parser is made atomic using <code><a href="Text-Gigaparsec.html#v:atomic" title="Text.Gigaparsec">atomic</a></code>.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:digit" class="def">digit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#digit" class="link">Source</a> <a href="#v:digit" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a digit, and returns it if successful.</p><p>A digit is one of <code>'0'</code> to <code>'9'</code> (inclusive).</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:endOfLine" class="def">endOfLine</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#endOfLine" class="link">Source</a> <a href="#v:endOfLine" class="selflink">#</a></p><div class="doc"><p>This parser will parse either a line feed (<code>LF</code>) or a <code>CRLF</code> newline, returning <code>'\n'</code> if successful.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:hexDigit" class="def">hexDigit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#hexDigit" class="link">Source</a> <a href="#v:hexDigit" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a hexadecimal digit, and returns it if successful.</p><p>A hexadecimal digit is one of (all inclusive ranges):</p><ol><li value="1">the digits <code>'0'</code> through <code>'9'</code></li><li value="2">the letters <code>'a'</code> through <code>'f'</code></li><li value="3">the letters <code>'A'</code> through <code>'Z'</code></li></ol><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:letter" class="def">letter</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#letter" class="link">Source</a> <a href="#v:letter" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a letter, and returns it if successful.</p><p>A letter is a character within the following Unicode General Categories:</p><ol><li value="1">Uppercase Letter (<code>Lu</code>)</li><li value="2">Lowercase Letter (<code>Ll</code>)</li><li value="3">Titlecase Letter (<code>Lt</code>)</li><li value="4">Modifier Letter (<code>Lm</code>)</li><li value="5">Other Letter (<code>Lo</code>)</li></ol><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:letterOrDigit" class="def">letterOrDigit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#letterOrDigit" class="link">Source</a> <a href="#v:letterOrDigit" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse either a letter or a digit, and returns it if successful.</p><p>A letter or digit is anything that would parse in either <code><a href="Text-Gigaparsec-Char.html#v:letter" title="Text.Gigaparsec.Char">letter</a></code> or <code><a href="Text-Gigaparsec-Char.html#v:digit" title="Text.Gigaparsec.Char">digit</a></code>.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:lower" class="def">lower</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#lower" class="link">Source</a> <a href="#v:lower" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse an lowercase letter, and returns it if successful.</p><p>A lowercase letter is any character whose Unicode <em>Category Type</em> is Lowercase
Letter (<code>Ll</code>).</p><p>Examples of characters within this category include:</p><ul><li>the Latin letters <code>'a'</code> through <code>'z'</code></li><li>Latin special character such as <code>'&#233;'</code>, <code>'&#223;'</code>, <code>'&#240;'</code></li><li>Cryillic letters</li><li>Greek letters</li><li>Coptic letters</li></ul><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:newline" class="def">newline</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#newline" class="link">Source</a> <a href="#v:newline" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a line feed newline (<code>'\n'</code>) character, and returns it if successful.</p><p>This parser will not accept a carriage return (<code>CR</code>) character or <code>CRLF</code>.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:octDigit" class="def">octDigit</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#octDigit" class="link">Source</a> <a href="#v:octDigit" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse an octal digit, and returns it if successful.</p><p>An octal digit is one of <code>'0'</code> to <code>'7'</code> (inclusive).</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:space" class="def">space</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#space" class="link">Source</a> <a href="#v:space" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a space or tab character, and returns it if successful.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:tab" class="def">tab</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#tab" class="link">Source</a> <a href="#v:tab" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a tab (<code>'\t'</code>) character, and returns it if successful.</p><p>This parser does not recognise vertical tabs, only horizontal ones.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:upper" class="def">upper</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#upper" class="link">Source</a> <a href="#v:upper" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse an uppercase letter, and returns it if successful.</p><p>An uppercase letter is any character whose Unicode <em>Category Type</em> is Uppercase Letter (<code>Lu</code>).
Examples of characters within this category include:</p><ul><li>the Latin letters <code>'A'</code> through <code>'Z'</code></li><li>Latin special character such as <code>'&#197;'</code>, <code>'&#199;'</code>, <code>'&#213;'</code></li><li>Cryillic letters</li><li>Greek letters</li><li>Coptic letters</li></ul><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:whitespace" class="def">whitespace</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.20.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Text.Gigaparsec.Char.html#whitespace" class="link">Source</a> <a href="#v:whitespace" class="selflink">#</a></p><div class="doc"><p>This parser tries to parse a whitespace character, and returns it if successful.</p><p>Whitespace is any one of the following:</p><ol><li value="1">a space (<code>' '</code>)</li><li value="2">a tab (<code>'t'</code>)</li><li value="3">a line feed (<code>'n'</code>)</li><li value="4">a carriage return (<code>'r'</code>)</li><li value="5">a form feed (<code>'f'</code>)</li><li value="6">a vertical tab (<code>'v'</code>)</li><li value="7">any other character with <em>General Category</em> Space (<code>Zs</code>)</li></ol><p><em>Since: 0.1.0.0</em></p></div></div><a href="#g:5" id="g:5"><h1>Whitespace Skipping Parsers</h1></a><div class="doc"><p>These parsers are designed to skip chunks of whitespace, for very rudimentary lexing tasks. It
 is probably better to use the functionality of <a href="Gigaparsec-Token.html">Gigaparsec.Token</a>.</p></div><div class="top"><p class="src"><a id="v:spaces" class="def">spaces</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.Char.html#spaces" class="link">Source</a> <a href="#v:spaces" class="selflink">#</a></p><div class="doc"><p>This parser skips zero or more space characters using <code><a href="Text-Gigaparsec-Char.html#v:space" title="Text.Gigaparsec.Char">space</a></code>.</p><p><em>Since: 0.1.0.0</em></p></div></div><div class="top"><p class="src"><a id="v:whitespaces" class="def">whitespaces</a> :: <a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> () <a href="src/Text.Gigaparsec.Char.html#whitespaces" class="link">Source</a> <a href="#v:whitespaces" class="selflink">#</a></p><div class="doc"><p>This parser skips zero or more space characters using <code><a href="Text-Gigaparsec-Char.html#v:whitespace" title="Text.Gigaparsec.Char">whitespace</a></code>.</p><p><em>Since: 0.1.0.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.28.0</p></div></body></html>