<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Text.Gigaparsec.Errors.TokenExtractors</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">gigaparsec-0.2.5.0: Refreshed parsec-style library for compatiblity with Scala parsley</span><ul class="links" id="page-menu"><li><a href="src/Text.Gigaparsec.Errors.TokenExtractors.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>Jamie Willis, Gigaparsec Maintainers</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Gigaparsec.Errors.TokenExtractors</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains implementations of token extractors that can be used in the
<a href="Text-Gigaparsec-Errors-ErrorBuilder.html">Text.Gigaparsec.Errors.ErrorBuilder</a> to decide how to extract unexpected tokens from the residual
input left over from a parse error.</p><p>These are common strategies, and something here is likely to be what is needed. They are all careful
to handle unprintable characters and whitespace in a sensible way, and account for unicode codepoints
that are wider than a single 16-bit character.</p><p><em>Since: 0.2.5.0</em></p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:Token">Token</a><ul class="subs"><li>= <a href="#v:Raw">Raw</a> !<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li>| <a href="#v:Named">Named</a> !<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a> !<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a></li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:TokenExtractor">TokenExtractor</a> = <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:Token" title="Text.Gigaparsec.Errors.TokenExtractors">Token</a></li><li class="src short"><a href="#v:tillNextWhitespace">tillNextWhitespace</a> :: <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></li><li class="src short"><a href="#v:singleChar">singleChar</a> :: <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></li><li class="src short"><a href="#v:matchParserDemand">matchParserDemand</a> :: <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></li><li class="src short"><a href="#v:lexToken">lexToken</a> :: [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>] -&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a> -&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></li><li class="src short"><a href="#v:lexTokenWithSelect">lexTokenWithSelect</a> :: (<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>, <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a>) -&gt; (<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>, <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a>)) -&gt; [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>] -&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a> -&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Token" class="def">Token</a> <a href="src/Text.Gigaparsec.Errors.TokenExtractors.html#Token" class="link">Source</a> <a href="#t:Token" class="selflink">#</a></p><div class="doc"><p>This type represents an extracted token returned by <code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#v:unexpectedToken" title="Text.Gigaparsec.Errors.ErrorBuilder">unexpectedToken</a></code>
in <code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#v:ErrorBuilder" title="Text.Gigaparsec.Errors.ErrorBuilder">ErrorBuilder</a></code>.</p><p>There is deliberately no analogue for <code>EndOfInput</code> because we guarantee that non-empty
residual input is provided to token extraction.</p><p><em>Since: 0.2.5.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Raw" class="def">Raw</a></td><td class="doc"><p>This is a token that is directly extracted from the residual input itself.</p></td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src">!<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></dfn><div class="doc"><p>the input extracted.</p></div></li></ul></div></td></tr><tr><td class="src"><a id="v:Named" class="def">Named</a></td><td class="doc"><p>This is a token that has been given a name, and is treated like a labelled item.</p></td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src">!<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a></dfn><div class="doc"><p>the description of the token.</p></div></li><li><dfn class="src">!<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a></dfn><div class="doc"><p>the amount of residual input this token ate.</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:TokenExtractor" class="def">TokenExtractor</a> <a href="src/Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor" class="link">Source</a> <a href="#t:TokenExtractor" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">&nbsp;= <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></td><td class="doc"><p>the remaining input, <code>cs</code>, at point of failure.</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a></td><td class="doc"><p>the input the parser tried to read when it failed
   (this is <strong>not</strong> guaranteed to be smaller than the length of
    <code>cs</code>, but is <strong>guaranteed to be greater than 0</strong>).</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p>was this error generated as part of &quot;lexing&quot;, or in a wider parser (see <code><a href="Text-Gigaparsec-Errors-Combinator.html#v:markAsToken" title="Text.Gigaparsec.Errors.Combinator">markAsToken</a></code>).</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:Token" title="Text.Gigaparsec.Errors.TokenExtractors">Token</a></td><td class="doc"><p>a token extracted from <code>cs</code> that will be used as part of the unexpected message.</p></td></tr></table></div><div class="doc"><p>Type alias for token extractors, matches the shape of
<code><a href="Text-Gigaparsec-Errors-ErrorBuilder.html#v:unexpectedToken" title="Text.Gigaparsec.Errors.ErrorBuilder">unexpectedToken</a></code>.</p><p><em>Since: 0.2.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:tillNextWhitespace" class="def">tillNextWhitespace</a> <a href="src/Text.Gigaparsec.Errors.TokenExtractors.html#tillNextWhitespace" class="link">Source</a> <a href="#v:tillNextWhitespace" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p>should the extractor cap the token to the amount of input the parser demanded?</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>what counts as a space character</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This extractor provides an implementation for <code><a href="Text-Gigaparsec-ErrorBuilder.html#v:unexpectedToken" title="Text.Gigaparsec.ErrorBuilder">unexpectedToken</a></code>:
it will construct a token that extends to the next available whitespace in the remaining input.
It can be configured to constrict this token to the minimum of the next whitespace or whatever the
parser demanded.</p><p>In the case of unprintable characters or whitespace, this extractor will favour reporting a more
meaningful name.</p><p><em>Since: 0.2.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:singleChar" class="def">singleChar</a> :: <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a> <a href="src/Text.Gigaparsec.Errors.TokenExtractors.html#singleChar" class="link">Source</a> <a href="#v:singleChar" class="selflink">#</a></p><div class="doc"><p>This extractor provides an implementation for <code><a href="Text-Gigaparsec-ErrorBuilder.html#v:unexpectedToken" title="Text.Gigaparsec.ErrorBuilder">unexpectedToken</a></code>:
it will unconditionally report the first character in the remaining input as the problematic token.</p><p>In the case of unprintable characters or whitespace, this extractor will favour reporting
a more meaningful name.</p><p><em>Since: 0.2.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:matchParserDemand" class="def">matchParserDemand</a> :: <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a> <a href="src/Text.Gigaparsec.Errors.TokenExtractors.html#matchParserDemand" class="link">Source</a> <a href="#v:matchParserDemand" class="selflink">#</a></p><div class="doc"><p>This extractor provides an implementation for <code><a href="Text-Gigaparsec-ErrorBuilder.html#v:unexpectedToken" title="Text.Gigaparsec.ErrorBuilder">unexpectedToken</a></code>:
it will make a token as wide as the amount of input the parser tried to consume when it failed.</p><p>In the case of unprintable characters or whitespace, this extractor will favour reporting a more
meaningful name.</p><p><em>Since: 0.2.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:lexToken" class="def">lexToken</a> <a href="src/Text.Gigaparsec.Errors.TokenExtractors.html#lexToken" class="link">Source</a> <a href="#v:lexToken" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>]</td><td class="doc"><p>The tokens that should be recognised by this extractor: each parser should return the
 intended name of the token exactly as it should appear in the <a href="Named.html">Named</a> token.</p><p>This <em>should</em> include a whitespace parser for &quot;unexpected whitespace&quot;. However, with the
 exception of the whitespace parser, these tokens should not consume trailing (and
 certainly not leading) whitespace: if using definitions from <a href="Text-Gigaparsec-Token-Lexer.html">Text.Gigaparsec.Token.Lexer</a>
 functionality, the <code>nonlexeme</code> versions of the tokens should be used.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></td><td class="doc"><p>If the parser failed during the parsing of a token, this
 function extracts the problematic item from the remaining input.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This extractor provides an implementation for <code><a href="Text-Gigaparsec-ErrorBuilder.html#v:unexpectedToken" title="Text.Gigaparsec.ErrorBuilder">unexpectedToken</a></code>:
it will try and parse the residual input to identify a valid lexical token to report.</p><p>When parsing a grammar that as a dedicated lexical distinction, it is nice to be able to report
problematic tokens relevant to that grammar as opposed to generic input lifted straight from the
input stream. The easiest way of doing this would be having a pre-lexing pass and parsing based
on tokens, but this is deliberately not how Parsley is designed. Instead, this extractor can
try and parse the remaining input to try and identify a token on demand.</p><p>If the <code>lexicalError</code> flag of the <code>unexpectedToken</code> function is not set, which would indicate a
problem within a token reported by a classical lexer and not the parser, the extractor will
try to parse each of the provided <code>tokens</code> in turn: whichever is the longest matched of these
tokens will be reported as the problematic one, where an earlier token arbitrates ties
(<code><a href="Text-Gigaparsec-Errors-TokenExtractors.html#v:lexTokenWithSelect" title="Text.Gigaparsec.Errors.TokenExtractors">lexTokenWithSelect</a></code> can alter which is chosen). For best effect, these tokens should not consume
whitespace (which would otherwise be included at the end of the token!): this means that, if
using the <code>Lexer</code>, the functionality in <strong><code>nonlexeme</code></strong> should be used. If one of the
givens tokens cannot be parsed, the input until the <em>next</em> valid parsable token (or end of input)
is returned as a <code>Raw</code>.</p><p>If <code>lexicalError</code> is true, then the given token extractor will be used instead to extract a
default token.</p><p><em>Since: 0.2.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:lexTokenWithSelect" class="def">lexTokenWithSelect</a> <a href="src/Text.Gigaparsec.Errors.TokenExtractors.html#lexTokenWithSelect" class="link">Source</a> <a href="#v:lexTokenWithSelect" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>, <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a>) -&gt; (<a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>, <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a>))</td><td class="doc"><p>If the extractor is successful in identifying tokens that can be parsed from
 the residual input, this function will select <em>one</em> of them to report back.</p></td></tr><tr><td class="src">-&gt; [<a href="Text-Gigaparsec.html#t:Parsec" title="Text.Gigaparsec">Parsec</a> <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Data-String.html#t:String" title="Data.String">String</a>]</td><td class="doc"><p>The tokens that should be recognised by this extractor: each parser should return the
 intended name of the token exactly as it should appear in the <a href="Named.html">Named</a> token.</p><p>This <em>should</em> include a whitespace parser for &quot;unexpected whitespace&quot;. However, with the
 exception of the whitespace parser, these tokens should not consume trailing (and
 certainly not leading) whitespace: if using definitions from <a href="Text-Gigaparsec-Token-Lexer.html">Text.Gigaparsec.Token.Lexer</a>
 functionality, the <code>nonlexeme</code> versions of the tokens should be used.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></td><td class="doc"><p>If the parser failed during the parsing of a token, this
 function extracts the problematic item from the remaining input.</p></td></tr><tr><td class="src">-&gt; <a href="Text-Gigaparsec-Errors-TokenExtractors.html#t:TokenExtractor" title="Text.Gigaparsec.Errors.TokenExtractors">TokenExtractor</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>This extractor provides an implementation for <code><a href="Text-Gigaparsec-ErrorBuilder.html#v:unexpectedToken" title="Text.Gigaparsec.ErrorBuilder">unexpectedToken</a></code>:
it will try and parse the residual input to identify a valid lexical token to report.</p><p>When parsing a grammar that as a dedicated lexical distinction, it is nice to be able to report
problematic tokens relevant to that grammar as opposed to generic input lifted straight from the
input stream. The easiest way of doing this would be having a pre-lexing pass and parsing based
on tokens, but this is deliberately not how Parsley is designed. Instead, this extractor can
try and parse the remaining input to try and identify a token on demand.</p><p>If the <code>lexicalError</code> flag of the <code>unexpectedToken</code> function is not set, which would indicate a
problem within a token reported by a classical lexer and not the parser, the extractor will
try to parse each of the provided <code>tokens</code> in turn: the given function is used to select which
is returned.
For best effect, these tokens should not consume
whitespace (which would otherwise be included at the end of the token!): this means that, if
using the <code>Lexer</code>, the functionality in <strong><code>nonlexeme</code></strong> should be used. If one of the
givens tokens cannot be parsed, the input until the <em>next</em> valid parsable token (or end of input)
is returned as a <code>Raw</code>.</p><p>If <code>lexicalError</code> is true, then the given token extractor will be used instead to extract a
default token.</p><p><em>Since: 0.2.5.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.30.0</p></div></body></html>