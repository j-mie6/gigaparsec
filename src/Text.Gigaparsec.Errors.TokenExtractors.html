<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Safe #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span><span>
</span><span id="line-4"></span><span class="annot"><span class="hs-comment">{-|
Module      : Text.Gigaparsec.Errors.TokenExtractors
Description : This module contains implementations of token extractors that can be used in the
              @ErrorBuilder@ to decide how to extract unexpected tokens from the residual input left
              over from a parse error.
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : stable

This module contains implementations of token extractors that can be used in the
&quot;Text.Gigaparsec.Errors.ErrorBuilder&quot; to decide how to extract unexpected tokens from the residual
input left over from a parse error.

These are common strategies, and something here is likely to be what is needed. They are all careful
to handle unprintable characters and whitespace in a sensible way, and account for unicode codepoints
that are wider than a single 16-bit character.

@since 0.2.5.0
-}</span></span><span>
</span><span id="line-23"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Text.Gigaparsec.Errors.TokenExtractors</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-24"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Token"><span class="hs-identifier">Token</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier">TokenExtractor</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#tillNextWhitespace"><span class="hs-identifier">tillNextWhitespace</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#singleChar"><span class="hs-identifier">singleChar</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#matchParserDemand"><span class="hs-identifier">matchParserDemand</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexToken"><span class="hs-identifier">lexToken</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexTokenWithSelect"><span class="hs-identifier">lexTokenWithSelect</span></a></span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html"><span class="hs-identifier">Text.Gigaparsec</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier">Parsec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#Result"><span class="hs-identifier">Result</span></a></span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.html#Success"><span class="hs-identifier">Success</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#parse"><span class="hs-identifier">parse</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.html#atomic"><span class="hs-identifier">atomic</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#lookAhead"><span class="hs-identifier">lookAhead</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier">notFollowedBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">some</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#%3C%2B%3E"><span class="hs-operator">(&lt;+&gt;)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#%3C~%3E"><span class="hs-operator">(&lt;~&gt;)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#mapMaybeS"><span class="hs-identifier">mapMaybeS</span></a></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Char.html"><span class="hs-identifier">Text.Gigaparsec.Char</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Char.html#item"><span class="hs-identifier">item</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html"><span class="hs-identifier">Text.Gigaparsec.Combinator</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier">option</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Position.html"><span class="hs-identifier">Text.Gigaparsec.Position</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Position.html#offset"><span class="hs-identifier">offset</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Char</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">generalCategory</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ord</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">GeneralCategory</span></span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Format</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Surrogate</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">PrivateUse</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">NotAssigned</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Control</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Char</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Char</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">isSpace</span></span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">NonEmpty</span></span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(:|)</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">nonEmpty</span></span><span class="hs-special">)</span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List.NonEmpty</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">toList</span></span><span class="hs-special">)</span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Void</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Void</span></span><span class="hs-special">)</span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">maximumBy</span></span><span class="hs-special">)</span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Numeric</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">showHex</span></span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Function</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">on</span></span><span class="hs-special">)</span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">catMaybes</span></span><span class="hs-special">)</span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span class="annot"><span class="hs-comment">{-|
Type alias for token extractors, matches the shape of
'Text.Gigaparsec.Errors.ErrorBuilder.unexpectedToken'.

@since 0.2.5.0
-}</span></span><span>
</span><span id="line-55"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-type">TokenExtractor</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span>
</span><span id="line-56"></span><span class="hs-keyword">type</span><span> </span><span id="TokenExtractor"><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-var">TokenExtractor</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the remaining input, @cs@, at point of failure.</span></span><span>
</span><span id="line-57"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word</span></span><span>         </span><span class="hs-comment">-- ^ the input the parser tried to read when it failed</span><span>
</span><span id="line-58"></span><span>                                    </span><span class="hs-comment">--   (this is __not__ guaranteed to be smaller than the length of</span><span>
</span><span id="line-59"></span><span>                                    </span><span class="hs-comment">--    @cs@, but is __guaranteed to be greater than 0__).</span><span>
</span><span id="line-60"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ was this error generated as part of \&quot;lexing\&quot;, or in a wider parser (see 'Text.Gigaparsec.Errors.Combinator.markAsToken').</span></span><span>
</span><span id="line-61"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ a token extracted from @cs@ that will be used as part of the unexpected message.</span></span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span class="annot"><span class="hs-comment">{-|
This type represents an extracted token returned by 'Text.Gigaparsec.Errors.ErrorBuilder.unexpectedToken'
in 'Text.Gigaparsec.Errors.ErrorBuilder.ErrorBuilder'.

There is deliberately no analogue for @EndOfInput@ because we guarantee that non-empty
residual input is provided to token extraction.

@since 0.2.5.0
-}</span></span><span>
</span><span id="line-72"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span>
</span><span id="line-73"></span><span class="hs-keyword">data</span><span> </span><span id="Token"><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Token"><span class="hs-identifier hs-var">Token</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Raw"><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Raw"><span class="hs-identifier hs-var">Raw</span></a></span></span><span>                   </span><span class="annot"><span class="hs-comment">-- ^ This is a token that is directly extracted from the residual input itself.</span></span><span>
</span><span id="line-74"></span><span>              </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ the input extracted.</span></span><span>
</span><span id="line-75"></span><span>           </span><span class="hs-glyph">|</span><span> </span><span id="Named"><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Named"><span class="hs-identifier hs-var">Named</span></a></span></span><span>                 </span><span class="annot"><span class="hs-comment">-- ^ This is a token that has been given a name, and is treated like a labelled item.</span></span><span>
</span><span id="line-76"></span><span>              </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>              </span><span class="annot"><span class="hs-comment">-- ^ the description of the token.</span></span><span>
</span><span id="line-77"></span><span>              </span><span class="hs-pragma">{-# UNPACK</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="hs-glyph">!</span><span class="annot"><span class="hs-identifier hs-type">Word</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the amount of residual input this token ate.</span></span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span class="hs-pragma">{-# INLINABLE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#tillNextWhitespace"><span class="hs-pragma hs-type">tillNextWhitespace</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-80"></span><span class="annot"><span class="hs-comment">{-|
This extractor provides an implementation for 'Text.Gigaparsec.ErrorBuilder.unexpectedToken':
it will construct a token that extends to the next available whitespace in the remaining input.
It can be configured to constrict this token to the minimum of the next whitespace or whatever the
parser demanded.

In the case of unprintable characters or whitespace, this extractor will favour reporting a more
meaningful name.

@since 0.2.5.0
-}</span></span><span>
</span><span id="line-91"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#tillNextWhitespace"><span class="hs-identifier hs-type">tillNextWhitespace</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>           </span><span class="annot"><span class="hs-comment">-- ^ should the extractor cap the token to the amount of input the parser demanded?</span></span><span>
</span><span id="line-92"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ what counts as a space character</span></span><span>
</span><span id="line-93"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-type">TokenExtractor</span></a></span><span>
</span><span id="line-94"></span><span id="tillNextWhitespace"><span class="annot"><span class="annottext">tillNextWhitespace :: Bool -&gt; (Char -&gt; Bool) -&gt; TokenExtractor
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#tillNextWhitespace"><span class="hs-identifier hs-var hs-var">tillNextWhitespace</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Char -&gt; Maybe Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-var">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679241466"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679241466"><span class="hs-identifier hs-var">tok</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679241466"><span class="hs-identifier hs-var">tok</span></a></span><span>
</span><span id="line-95"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#tillNextWhitespace"><span class="hs-identifier hs-var">tillNextWhitespace</span></a></span><span> </span><span id="local-6989586621679241467"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679241467"><span class="hs-identifier hs-var">trimToDemand</span></a></span></span><span> </span><span id="local-6989586621679241468"><span class="annot"><span class="annottext">Char -&gt; Bool
</span><a href="#local-6989586621679241468"><span class="hs-identifier hs-var">isSpace</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679241469"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241469"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span id="local-6989586621679241470"><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679241470"><span class="hs-identifier hs-var">cs</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679241471"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679241471"><span class="hs-identifier hs-var">parserDemanded</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-96"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679241467"><span class="hs-identifier hs-var">trimToDemand</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Raw"><span class="hs-identifier hs-var">Raw</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; [Char] -&gt; [Char]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word -&gt; Int
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679241471"><span class="hs-identifier hs-var">parserDemanded</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Char] -&gt; [Char]
</span><a href="#local-6989586621679241473"><span class="hs-identifier hs-var">tillSpace</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241469"><span class="hs-identifier hs-var">c</span></a></span><span class="annot"><span class="annottext">Char -&gt; [Char] -&gt; [Char]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679241470"><span class="hs-identifier hs-var">cs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Raw"><span class="hs-identifier hs-var">Raw</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Char] -&gt; [Char]
</span><a href="#local-6989586621679241473"><span class="hs-identifier hs-var">tillSpace</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241469"><span class="hs-identifier hs-var">c</span></a></span><span class="annot"><span class="annottext">Char -&gt; [Char] -&gt; [Char]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679241470"><span class="hs-identifier hs-var">cs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-98"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679241473"><span class="annot"><span class="annottext">tillSpace :: [Char] -&gt; [Char]
</span><a href="#local-6989586621679241473"><span class="hs-identifier hs-var hs-var">tillSpace</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Char -&gt; Bool) -&gt; [Char] -&gt; [Char]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">takeWhile</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool) -&gt; (Char -&gt; Bool) -&gt; Char -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><a href="#local-6989586621679241468"><span class="hs-identifier hs-var">isSpace</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="annot"><span class="hs-comment">{-|
This extractor provides an implementation for 'Text.Gigaparsec.ErrorBuilder.unexpectedToken':
it will unconditionally report the first character in the remaining input as the problematic token.

In the case of unprintable characters or whitespace, this extractor will favour reporting
a more meaningful name.

@since 0.2.5.0
-}</span></span><span>
</span><span id="line-109"></span><span class="hs-pragma">{-# INLINABLE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#singleChar"><span class="hs-pragma hs-type">singleChar</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-110"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#singleChar"><span class="hs-identifier hs-type">singleChar</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-type">TokenExtractor</span></a></span><span>
</span><span id="line-111"></span><span id="singleChar"><span class="annot"><span class="annottext">singleChar :: TokenExtractor
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#singleChar"><span class="hs-identifier hs-var hs-var">singleChar</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Char -&gt; Maybe Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-var">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679241477"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679241477"><span class="hs-identifier hs-var">tok</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679241477"><span class="hs-identifier hs-var">tok</span></a></span><span>
</span><span id="line-112"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#singleChar"><span class="hs-identifier hs-var">singleChar</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679241478"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241478"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Raw"><span class="hs-identifier hs-var">Raw</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241478"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span class="annot"><span class="hs-comment">{-|
This extractor provides an implementation for 'Text.Gigaparsec.ErrorBuilder.unexpectedToken':
it will make a token as wide as the amount of input the parser tried to consume when it failed.

In the case of unprintable characters or whitespace, this extractor will favour reporting a more
meaningful name.

@since 0.2.5.0
-}</span></span><span>
</span><span id="line-123"></span><span class="hs-pragma">{-# INLINABLE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#matchParserDemand"><span class="hs-pragma hs-type">matchParserDemand</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-124"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#matchParserDemand"><span class="hs-identifier hs-type">matchParserDemand</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-type">TokenExtractor</span></a></span><span>
</span><span id="line-125"></span><span id="matchParserDemand"><span class="annot"><span class="annottext">matchParserDemand :: TokenExtractor
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#matchParserDemand"><span class="hs-identifier hs-var hs-var">matchParserDemand</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Char -&gt; Maybe Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-var">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679241479"><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679241479"><span class="hs-identifier hs-var">tok</span></a></span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token
</span><a href="#local-6989586621679241479"><span class="hs-identifier hs-var">tok</span></a></span><span>
</span><span id="line-126"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#matchParserDemand"><span class="hs-identifier hs-var">matchParserDemand</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679241480"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241480"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span id="local-6989586621679241481"><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679241481"><span class="hs-identifier hs-var">cs</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679241482"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679241482"><span class="hs-identifier hs-var">parserDemanded</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Raw"><span class="hs-identifier hs-var">Raw</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; [Char] -&gt; [Char]
forall a. Int -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">take</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word -&gt; Int
forall a b. (Integral a, Num b) =&gt; a -&gt; b
</span><span class="hs-identifier hs-var">fromIntegral</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679241482"><span class="hs-identifier hs-var">parserDemanded</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241480"><span class="hs-identifier hs-var">c</span></a></span><span class="annot"><span class="annottext">Char -&gt; [Char] -&gt; [Char]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Char]
</span><a href="#local-6989586621679241481"><span class="hs-identifier hs-var">cs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-127"></span><span>
</span><span id="line-128"></span><span class="hs-pragma">{-# INLINABLE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-pragma hs-type">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-129"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-type">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span>
</span><span id="line-130"></span><span id="whitespaceOrUnprintable"><span class="annot"><span class="annottext">whitespaceOrUnprintable :: NonEmpty Char -&gt; Maybe Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-var hs-var">whitespaceOrUnprintable</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\n'</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token -&gt; Maybe Token
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe Token) -&gt; Token -&gt; Maybe Token
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Word -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Named"><span class="hs-identifier hs-var">Named</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;newline&quot;</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">1</span></span><span>
</span><span id="line-131"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-var">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\r'</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token -&gt; Maybe Token
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe Token) -&gt; Token -&gt; Maybe Token
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Word -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Named"><span class="hs-identifier hs-var">Named</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;carriage return&quot;</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">1</span></span><span>
</span><span id="line-132"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-var">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'\t'</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token -&gt; Maybe Token
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe Token) -&gt; Token -&gt; Maybe Token
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Word -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Named"><span class="hs-identifier hs-var">Named</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;tab&quot;</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">1</span></span><span>
</span><span id="line-133"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-var">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">' '</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token -&gt; Maybe Token
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe Token) -&gt; Token -&gt; Maybe Token
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Word -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Named"><span class="hs-identifier hs-var">Named</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;space&quot;</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">1</span></span><span>
</span><span id="line-134"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#whitespaceOrUnprintable"><span class="hs-identifier hs-var">whitespaceOrUnprintable</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679241483"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241483"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">:|</span></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>
</span><span id="line-135"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Char -&gt; Bool
</span><span class="hs-identifier hs-var">Char.isSpace</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241483"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token -&gt; Maybe Token
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe Token) -&gt; Token -&gt; Maybe Token
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Word -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Named"><span class="hs-identifier hs-var">Named</span></a></span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;whitespace character&quot;</span></span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">1</span></span><span>
</span><span id="line-136"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Char -&gt; GeneralCategory
</span><span class="hs-identifier hs-var">generalCategory</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241483"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-137"></span><span>    </span><span class="annot"><span class="annottext">GeneralCategory
</span><span class="hs-identifier hs-var">Format</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Token
</span><a href="#local-6989586621679241484"><span class="hs-identifier hs-var">unprintable</span></a></span><span>
</span><span id="line-138"></span><span>    </span><span class="annot"><span class="annottext">GeneralCategory
</span><span class="hs-identifier hs-var">Surrogate</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Token
</span><a href="#local-6989586621679241484"><span class="hs-identifier hs-var">unprintable</span></a></span><span>
</span><span id="line-139"></span><span>    </span><span class="annot"><span class="annottext">GeneralCategory
</span><span class="hs-identifier hs-var">PrivateUse</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Token
</span><a href="#local-6989586621679241484"><span class="hs-identifier hs-var">unprintable</span></a></span><span>
</span><span id="line-140"></span><span>    </span><span class="annot"><span class="annottext">GeneralCategory
</span><span class="hs-identifier hs-var">NotAssigned</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Token
</span><a href="#local-6989586621679241484"><span class="hs-identifier hs-var">unprintable</span></a></span><span>
</span><span id="line-141"></span><span>    </span><span class="annot"><span class="annottext">GeneralCategory
</span><span class="hs-identifier hs-var">Control</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Token
</span><a href="#local-6989586621679241484"><span class="hs-identifier hs-var">unprintable</span></a></span><span>
</span><span id="line-142"></span><span>    </span><span class="annot"><span class="annottext">GeneralCategory
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Token
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679241484"><span class="annot"><span class="annottext">unprintable :: Maybe Token
</span><a href="#local-6989586621679241484"><span class="hs-identifier hs-var hs-var">unprintable</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Token -&gt; Maybe Token
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(Token -&gt; Maybe Token) -&gt; Token -&gt; Maybe Token
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Word -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Named"><span class="hs-identifier hs-var">Named</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;non-printable character (\\x&quot;</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; [Char] -&gt; [Char]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; [Char] -&gt; [Char]
forall a. Integral a =&gt; a -&gt; [Char] -&gt; [Char]
</span><span class="hs-identifier hs-var">showHex</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char -&gt; Int
</span><span class="hs-identifier hs-var">ord</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679241483"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;)&quot;</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Word
</span><span class="hs-number">1</span></span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span class="annot"><span class="hs-comment">{-|
This extractor provides an implementation for 'Text.Gigaparsec.ErrorBuilder.unexpectedToken':
it will try and parse the residual input to identify a valid lexical token to report.

When parsing a grammar that as a dedicated lexical distinction, it is nice to be able to report
problematic tokens relevant to that grammar as opposed to generic input lifted straight from the
input stream. The easiest way of doing this would be having a pre-lexing pass and parsing based
on tokens, but this is deliberately not how Parsley is designed. Instead, this extractor can
try and parse the remaining input to try and identify a token on demand.

If the @lexicalError@ flag of the @unexpectedToken@ function is not set, which would indicate a
problem within a token reported by a classical lexer and not the parser, the extractor will
try to parse each of the provided @tokens@ in turn: whichever is the longest matched of these
tokens will be reported as the problematic one, where an earlier token arbitrates ties
('lexTokenWithSelect' can alter which is chosen). For best effect, these tokens should not consume
whitespace (which would otherwise be included at the end of the token!): this means that, if
using the @Lexer@, the functionality in __@nonlexeme@__ should be used. If one of the
givens tokens cannot be parsed, the input until the /next/ valid parsable token (or end of input)
is returned as a @Raw@.

If @lexicalError@ is true, then the given token extractor will be used instead to extract a
default token.

@since 0.2.5.0
-}</span></span><span>
</span><span id="line-170"></span><span class="hs-pragma">{-# INLINABLE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexToken"><span class="hs-pragma hs-type">lexToken</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-171"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexToken"><span class="hs-identifier hs-type">lexToken</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ The tokens that should be recognised by this extractor: each parser should return the</span><span>
</span><span id="line-172"></span><span>                            </span><span class="hs-comment">-- intended name of the token exactly as it should appear in the &quot;Named&quot; token.</span><span>
</span><span id="line-173"></span><span>                            </span><span class="hs-comment">--</span><span>
</span><span id="line-174"></span><span>                            </span><span class="hs-comment">-- This /should/ include a whitespace parser for &quot;unexpected whitespace&quot;. However, with the</span><span>
</span><span id="line-175"></span><span>                            </span><span class="hs-comment">-- exception of the whitespace parser, these tokens should not consume trailing (and</span><span>
</span><span id="line-176"></span><span>                            </span><span class="hs-comment">-- certainly not leading) whitespace: if using definitions from &quot;Text.Gigaparsec.Token.Lexer&quot;</span><span>
</span><span id="line-177"></span><span>                            </span><span class="hs-comment">-- functionality, the @nonlexeme@ versions of the tokens should be used.</span><span>
</span><span id="line-178"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-type">TokenExtractor</span></a></span><span>  </span><span class="hs-comment">-- ^ If the parser failed during the parsing of a token, this</span><span>
</span><span id="line-179"></span><span>                            </span><span class="hs-comment">-- function extracts the problematic item from the remaining input.</span><span>
</span><span id="line-180"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-type">TokenExtractor</span></a></span><span>
</span><span id="line-181"></span><span id="lexToken"><span class="annot"><span class="annottext">lexToken :: [Parsec [Char]] -&gt; TokenExtractor -&gt; TokenExtractor
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexToken"><span class="hs-identifier hs-var hs-var">lexToken</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(NonEmpty ([Char], Word) -&gt; ([Char], Word))
-&gt; [Parsec [Char]] -&gt; TokenExtractor -&gt; TokenExtractor
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexTokenWithSelect"><span class="hs-identifier hs-var">lexTokenWithSelect</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(([Char], Word) -&gt; ([Char], Word) -&gt; Ordering)
-&gt; NonEmpty ([Char], Word) -&gt; ([Char], Word)
forall (t :: * -&gt; *) a.
Foldable t =&gt;
(a -&gt; a -&gt; Ordering) -&gt; t a -&gt; a
</span><span class="hs-identifier hs-var">maximumBy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Word -&gt; Word -&gt; Ordering
forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><span class="hs-identifier hs-var">compare</span></span><span> </span><span class="annot"><span class="annottext">(Word -&gt; Word -&gt; Ordering)
-&gt; (([Char], Word) -&gt; Word)
-&gt; ([Char], Word)
-&gt; ([Char], Word)
-&gt; Ordering
forall b c a. (b -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; a -&gt; c
</span><span class="hs-operator hs-var">`on`</span></span><span> </span><span class="annot"><span class="annottext">([Char], Word) -&gt; Word
forall a b. (a, b) -&gt; b
</span><span class="hs-identifier hs-var">snd</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-182"></span><span>
</span><span id="line-183"></span><span class="annot"><span class="hs-comment">{-|
This extractor provides an implementation for 'Text.Gigaparsec.ErrorBuilder.unexpectedToken':
it will try and parse the residual input to identify a valid lexical token to report.

When parsing a grammar that as a dedicated lexical distinction, it is nice to be able to report
problematic tokens relevant to that grammar as opposed to generic input lifted straight from the
input stream. The easiest way of doing this would be having a pre-lexing pass and parsing based
on tokens, but this is deliberately not how Parsley is designed. Instead, this extractor can
try and parse the remaining input to try and identify a token on demand.

If the @lexicalError@ flag of the @unexpectedToken@ function is not set, which would indicate a
problem within a token reported by a classical lexer and not the parser, the extractor will
try to parse each of the provided @tokens@ in turn: the given function is used to select which
is returned.
For best effect, these tokens should not consume
whitespace (which would otherwise be included at the end of the token!): this means that, if
using the @Lexer@, the functionality in __@nonlexeme@__ should be used. If one of the
givens tokens cannot be parsed, the input until the /next/ valid parsable token (or end of input)
is returned as a @Raw@.

If @lexicalError@ is true, then the given token extractor will be used instead to extract a
default token.

@since 0.2.5.0
-}</span></span><span>
</span><span id="line-208"></span><span class="hs-pragma">{-# INLINABLE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexTokenWithSelect"><span class="hs-pragma hs-type">lexTokenWithSelect</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-209"></span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexTokenWithSelect"><span class="hs-identifier hs-type">lexTokenWithSelect</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-210"></span><span>                   </span><span class="hs-comment">-- ^ If the extractor is successful in identifying tokens that can be parsed from</span><span>
</span><span id="line-211"></span><span>                   </span><span class="hs-comment">-- the residual input, this function will select /one/ of them to report back.</span><span>
</span><span id="line-212"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">]</span><span>
</span><span id="line-213"></span><span>                   </span><span class="hs-comment">-- ^ The tokens that should be recognised by this extractor: each parser should return the</span><span>
</span><span id="line-214"></span><span>                   </span><span class="hs-comment">-- intended name of the token exactly as it should appear in the &quot;Named&quot; token.</span><span>
</span><span id="line-215"></span><span>                   </span><span class="hs-comment">--</span><span>
</span><span id="line-216"></span><span>                   </span><span class="hs-comment">-- This /should/ include a whitespace parser for &quot;unexpected whitespace&quot;. However, with the</span><span>
</span><span id="line-217"></span><span>                   </span><span class="hs-comment">-- exception of the whitespace parser, these tokens should not consume trailing (and</span><span>
</span><span id="line-218"></span><span>                   </span><span class="hs-comment">-- certainly not leading) whitespace: if using definitions from &quot;Text.Gigaparsec.Token.Lexer&quot;</span><span>
</span><span id="line-219"></span><span>                   </span><span class="hs-comment">-- functionality, the @nonlexeme@ versions of the tokens should be used.</span><span>
</span><span id="line-220"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-type">TokenExtractor</span></a></span><span>
</span><span id="line-221"></span><span>                   </span><span class="hs-comment">-- ^ If the parser failed during the parsing of a token, this</span><span>
</span><span id="line-222"></span><span>                   </span><span class="hs-comment">-- function extracts the problematic item from the remaining input.</span><span>
</span><span id="line-223"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#TokenExtractor"><span class="hs-identifier hs-type">TokenExtractor</span></a></span><span>
</span><span id="line-224"></span><span id="lexTokenWithSelect"><span class="annot"><span class="annottext">lexTokenWithSelect :: (NonEmpty ([Char], Word) -&gt; ([Char], Word))
-&gt; [Parsec [Char]] -&gt; TokenExtractor -&gt; TokenExtractor
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#lexTokenWithSelect"><span class="hs-identifier hs-var hs-var">lexTokenWithSelect</span></a></span></span><span> </span><span id="local-6989586621679241489"><span class="annot"><span class="annottext">NonEmpty ([Char], Word) -&gt; ([Char], Word)
</span><a href="#local-6989586621679241489"><span class="hs-identifier hs-var">selectToken</span></a></span></span><span> </span><span id="local-6989586621679241490"><span class="annot"><span class="annottext">[Parsec [Char]]
</span><a href="#local-6989586621679241490"><span class="hs-identifier hs-var">tokens</span></a></span></span><span> </span><span id="local-6989586621679241491"><span class="annot"><span class="annottext">TokenExtractor
</span><a href="#local-6989586621679241491"><span class="hs-identifier hs-var">extractItem</span></a></span></span><span> </span><span id="local-6989586621679241492"><span class="annot"><span class="annottext">NonEmpty Char
</span><a href="#local-6989586621679241492"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621679241493"><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679241493"><span class="hs-identifier hs-var">parserDemanded</span></a></span></span><span> </span><span id="local-6989586621679241494"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679241494"><span class="hs-identifier hs-var">lexical</span></a></span></span><span>
</span><span id="line-225"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679241494"><span class="hs-identifier hs-var">lexical</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TokenExtractor
</span><a href="#local-6989586621679241491"><span class="hs-identifier hs-var">extractItem</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty Char
</span><a href="#local-6989586621679241492"><span class="hs-identifier hs-var">cs</span></a></span><span> </span><span class="annot"><span class="annottext">Word
</span><a href="#local-6989586621679241493"><span class="hs-identifier hs-var">parserDemanded</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-226"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">NonEmpty Char -&gt; Token
</span><a href="#local-6989586621679241495"><span class="hs-identifier hs-var">extractToken</span></a></span><span> </span><span class="annot"><span class="annottext">NonEmpty Char
</span><a href="#local-6989586621679241492"><span class="hs-identifier hs-var">cs</span></a></span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-228"></span><span>    </span><span class="annot"><a href="#local-6989586621679241495"><span class="hs-identifier hs-type">extractToken</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Token"><span class="hs-identifier hs-type">Token</span></a></span><span>
</span><span id="line-229"></span><span>    </span><span id="local-6989586621679241495"><span class="annot"><span class="annottext">extractToken :: NonEmpty Char -&gt; Token
</span><a href="#local-6989586621679241495"><span class="hs-identifier hs-var hs-var">extractToken</span></a></span></span><span> </span><span id="local-6989586621679241496"><span class="annot"><span class="annottext">NonEmpty Char
</span><a href="#local-6989586621679241496"><span class="hs-identifier hs-var">inp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-230"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#Success"><span class="hs-identifier hs-type">Success</span></a></span><span> </span><span id="local-6989586621679241499"><span class="annot"><span class="annottext">Either (NonEmpty ([Char], Word)) [Char]
</span><a href="#local-6989586621679241499"><span class="hs-identifier hs-var">rawOrToks</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall err a.
ErrorBuilder err =&gt;
Parsec a -&gt; [Char] -&gt; Result err a
</span><a href="Text.Gigaparsec.html#parse"><span class="hs-identifier hs-var">parse</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">Void</span></span><span> </span><span class="annot"><span class="annottext">Parsec (Either (NonEmpty ([Char], Word)) [Char])
</span><a href="#local-6989586621679241500"><span class="hs-identifier hs-var">parser</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">NonEmpty Char -&gt; [Char]
forall a. NonEmpty a -&gt; [a]
</span><span class="hs-identifier hs-var">NonEmpty.toList</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty Char
</span><a href="#local-6989586621679241496"><span class="hs-identifier hs-var">inp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-231"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(NonEmpty ([Char], Word) -&gt; Token)
-&gt; ([Char] -&gt; Token)
-&gt; Either (NonEmpty ([Char], Word)) [Char]
-&gt; Token
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">([Char] -&gt; Word -&gt; Token) -&gt; ([Char], Word) -&gt; Token
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Word -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Named"><span class="hs-identifier hs-var">Named</span></a></span><span> </span><span class="annot"><span class="annottext">(([Char], Word) -&gt; Token)
-&gt; (NonEmpty ([Char], Word) -&gt; ([Char], Word))
-&gt; NonEmpty ([Char], Word)
-&gt; Token
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">NonEmpty ([Char], Word) -&gt; ([Char], Word)
</span><a href="#local-6989586621679241489"><span class="hs-identifier hs-var">selectToken</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; Token
</span><a href="Text.Gigaparsec.Errors.TokenExtractors.html#Raw"><span class="hs-identifier hs-var">Raw</span></a></span><span> </span><span class="annot"><span class="annottext">Either (NonEmpty ([Char], Word)) [Char]
</span><a href="#local-6989586621679241499"><span class="hs-identifier hs-var">rawOrToks</span></a></span><span>
</span><span id="line-232"></span><span>
</span><span id="line-233"></span><span>    </span><span class="annot"><a href="#local-6989586621679241500"><span class="hs-identifier hs-type">parser</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">NonEmpty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Word</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>    </span><span id="local-6989586621679241500"><span class="annot"><span class="annottext">parser :: Parsec (Either (NonEmpty ([Char], Word)) [Char])
</span><a href="#local-6989586621679241500"><span class="hs-identifier hs-var hs-var">parser</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-235"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679241507"><span class="annot"><span class="annottext">toks :: Parsec (NonEmpty ([Char], Word))
</span><a href="#local-6989586621679241507"><span class="hs-identifier hs-var hs-var">toks</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([Maybe ([Char], Word)] -&gt; Maybe (NonEmpty ([Char], Word)))
-&gt; Parsec [Maybe ([Char], Word)]
-&gt; Parsec (NonEmpty ([Char], Word))
forall a b. (a -&gt; Maybe b) -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#mapMaybeS"><span class="hs-identifier hs-var">mapMaybeS</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[([Char], Word)] -&gt; Maybe (NonEmpty ([Char], Word))
forall a. [a] -&gt; Maybe (NonEmpty a)
</span><span class="hs-identifier hs-var">nonEmpty</span></span><span> </span><span class="annot"><span class="annottext">([([Char], Word)] -&gt; Maybe (NonEmpty ([Char], Word)))
-&gt; ([Maybe ([Char], Word)] -&gt; [([Char], Word)])
-&gt; [Maybe ([Char], Word)]
-&gt; Maybe (NonEmpty ([Char], Word))
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[Maybe ([Char], Word)] -&gt; [([Char], Word)]
forall a. [Maybe a] -&gt; [a]
</span><span class="hs-identifier hs-var">catMaybes</span></span><span class="hs-special">)</span><span>
</span><span id="line-236"></span><span>                           </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Parsec [Char] -&gt; Parsec (Maybe ([Char], Word)))
-&gt; [Parsec [Char]] -&gt; Parsec [Maybe ([Char], Word)]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679241509"><span class="annot"><span class="annottext">Parsec [Char]
</span><a href="#local-6989586621679241509"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Parsec ([Char], Word) -&gt; Parsec (Maybe ([Char], Word))
forall a. Parsec a -&gt; Parsec (Maybe a)
</span><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier hs-var">option</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec ([Char], Word) -&gt; Parsec ([Char], Word)
forall a. Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.html#lookAhead"><span class="hs-identifier hs-var">lookAhead</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec [Char] -&gt; Parsec [Char]
forall a. Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.html#atomic"><span class="hs-identifier hs-var">atomic</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [Char]
</span><a href="#local-6989586621679241509"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [Char] -&gt; Parsec Word -&gt; Parsec ([Char], Word)
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec (a, b)
</span><a href="Text.Gigaparsec.html#%3C~%3E"><span class="hs-operator hs-var">&lt;~&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Word
</span><a href="Text.Gigaparsec.Position.html#offset"><span class="hs-identifier hs-var">offset</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Parsec [Char]]
</span><a href="#local-6989586621679241490"><span class="hs-identifier hs-var">tokens</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-237"></span><span>          </span><span id="local-6989586621679241515"><span class="annot"><span class="annottext">rawTok :: Parsec [Char]
</span><a href="#local-6989586621679241515"><span class="hs-identifier hs-var hs-var">rawTok</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Char -&gt; Parsec [Char]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">some</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Parsec [Char] -&gt; Parsec ()) -&gt; [Parsec [Char]] -&gt; Parsec [()]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="annot"><span class="annottext">Parsec [Char] -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier hs-var">notFollowedBy</span></a></span><span> </span><span class="annot"><span class="annottext">[Parsec [Char]]
</span><a href="#local-6989586621679241490"><span class="hs-identifier hs-var">tokens</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [()] -&gt; Parsec Char -&gt; Parsec Char
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec Char
</span><a href="Text.Gigaparsec.Char.html#item"><span class="hs-identifier hs-var">item</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-238"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec (NonEmpty ([Char], Word))
</span><a href="#local-6989586621679241507"><span class="hs-identifier hs-var">toks</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec (NonEmpty ([Char], Word))
-&gt; Parsec [Char]
-&gt; Parsec (Either (NonEmpty ([Char], Word)) [Char])
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec (Either a b)
</span><a href="Text.Gigaparsec.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [Char]
</span><a href="#local-6989586621679241515"><span class="hs-identifier hs-var">rawTok</span></a></span><span>
</span><span id="line-239"></span></pre></body></html>