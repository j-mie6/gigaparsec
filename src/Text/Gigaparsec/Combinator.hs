{-# LANGUAGE Safe #-}
{-|
Module      : Text.Gigaparsec.Combinator
Description : This module contains a huge number of pre-made combinators that are
              very useful for a variety of purposes.
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : stable

This module contains a huge number of pre-made combinators that are very useful for a variety of purposes.

In particular, it contains combinators for: performing a parser iteratively, collecting all the results;
querying whether or not any input is left; optionally performing parsers; parsing delimited constructions;
handling multiple possible alternatives or parsers to sequence; handling more complex conditional execution;
and more.

@since 0.1.0.0
-}
module Text.Gigaparsec.Combinator (
  -- * Iterative Combinators
  -- | These combinators all execute a given parser an unbounded number of times, until either it fails, or another
  -- parser succeeds, depending on the combinator. Depending on the combinator, all of the results produced by the
  -- repeated execution of the parser may be returned in a @[]@. These are almost essential for any practical parsing
  -- task.
    skipMany, skipSome, manyTill,

  -- * Optional Parsing Combinators
  -- | These combinators allow for the /possible/ parsing of some parser. If the parser succeeds, that is ok
  -- so long as it __did not consume input__. Be aware that the result of the success may be replaced with
  -- these combinators, with the exception of "option", which still preserves the result.

  -- * Separated Values Combinators
  -- | These combinators are concerned with delimited parsing, where one parser is repeated but delimited by another one.
  -- In each of these cases @p@ is the parser of interest and @sep@ is the delimeter. These combinators mainly differ
  -- in either the number of @p@s they require, or exactly where the delimeters are allowed (only between, always
  -- trailing, or either). In all cases, they return the list of results generated by the repeated parses of @p@.
    sepEndBy1,

  -- * Multiple Branching/Sequencing Combinators
  -- | These combinators allow for testing or sequencing a large number of parsers in one go.
    choice,

  -- * Range Combinators
  -- | These combinators allow for the parsing of a specific parser either a specific number of times, or between a certain
  -- amount of thimes.

  -- * Selective Combinators
  -- | These combinators allow for the conditional extraction of a result, or the execution of a parser
  -- based on another. They are derived from "branch".
  ) where

import Text.Gigaparsec (Parsec, void, many, some, (<|>), ($>), (<:>))
import Data.Foldable (asum)

choice :: [Parsec a] -> Parsec a
choice = asum

skipMany :: Parsec a -> Parsec ()
skipMany = void . many

skipSome :: Parsec a -> Parsec ()
skipSome = void . some

manyTill :: Parsec a -> Parsec end -> Parsec [a]
manyTill p end = let go = end $> [] <|> p <:> go in go

sepEndBy1 :: Parsec a -> Parsec sep -> Parsec [a]
sepEndBy1 p sep = let seb1 = p <:> (sep *> (seb1 <|> pure []) <|> pure []) in seb1
