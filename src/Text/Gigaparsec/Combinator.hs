{-# LANGUAGE Safe #-}
{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Use optional" #-}
{-|
Module      : Text.Gigaparsec.Combinator
Description : This module contains a huge number of pre-made combinators that are
              very useful for a variety of purposes.
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : stable

This module contains a huge number of pre-made combinators that are very useful for a variety of purposes.

In particular, it contains combinators for: performing a parser iteratively, collecting all the results;
querying whether or not any input is left; optionally performing parsers; parsing delimited constructions;
handling multiple possible alternatives or parsers to sequence; handling more complex conditional execution;
and more.

@since 0.1.0.0
-}
module Text.Gigaparsec.Combinator (
  -- * Iterative Combinators
  -- | These combinators all execute a given parser an unbounded number of times, until either it fails, or another
  -- parser succeeds, depending on the combinator. Depending on the combinator, all of the results produced by the
  -- repeated execution of the parser may be returned in a @[]@. These are almost essential for any practical parsing
  -- task.
    manyN, skipMany, skipSome, skipManyN, count, count1, manyTill, someTill,

  -- * Optional Parsing Combinators
  -- | These combinators allow for the /possible/ parsing of some parser. If the parser succeeds, that is ok
  -- so long as it __did not consume input__. Be aware that the result of the success may be replaced with
  -- these combinators, with the exception of "option", which still preserves the result.
    option, optional, optionalAs, decide, fromMaybeS,

  -- * Separated Values Combinators
  -- | These combinators are concerned with delimited parsing, where one parser is repeated but delimited by another one.
  -- In each of these cases @p@ is the parser of interest and @sep@ is the delimeter. These combinators mainly differ
  -- in either the number of @p@s they require, or exactly where the delimeters are allowed (only between, always
  -- trailing, or either). In all cases, they return the list of results generated by the repeated parses of @p@.
    sepBy, sepBy1, sepEndBy, sepEndBy1, endBy, endBy1,

  -- * Multiple Branching/Sequencing Combinators
  -- | These combinators allow for testing or sequencing a large number of parsers in one go.
    choice, sequence, traverse, skip,

  -- * Range Combinators
  -- | These combinators allow for the parsing of a specific parser either a specific number of times, or between a certain
  -- amount of times.
    exactly, range, range_, countRange,

  -- * Selective Combinators
  -- | These combinators allow for the conditional extraction of a result, or the execution of a parser
  -- based on another. They are derived from "branch".
    ifS, whenS, guardS, whileS,
  ) where

import Text.Gigaparsec (Parsec, many, some, (<|>), ($>), (<:>), select,
                        branch, empty, unit, manyl, somel, notFollowedBy, liftA2)
import Data.Foldable (asum, sequenceA_)

choice :: [Parsec a] -> Parsec a
choice = asum

skip :: [Parsec a] -> Parsec ()
skip = sequenceA_

option :: Parsec a -> Parsec (Maybe a)
option p = Just <$> p <|> pure Nothing

optional :: Parsec a -> Parsec ()
optional = optionalAs ()

optionalAs :: b -> Parsec a -> Parsec b
optionalAs x p = p $> x <|> pure x

-- TODO: collect
decide :: Parsec (Maybe a) -> Parsec a
decide p = p >>= maybe empty pure

-- this is decide overload
fromMaybeS :: Parsec a -> Parsec (Maybe a) -> Parsec a
fromMaybeS q p = select (maybe (Left ()) Right <$> p) (const <$> q)

manyN :: Int -> Parsec a -> Parsec [a]
manyN 0 p = many p
manyN 1 p = some p
manyN n p = p <:> manyN (n - 1) p

skipMany :: Parsec a -> Parsec ()
skipMany p = let go = p *> go <|> unit in go

skipSome :: Parsec a -> Parsec ()
skipSome p = p *> skipMany p

skipManyN :: Int -> Parsec a -> Parsec ()
skipManyN 0 p = skipMany p
skipManyN 1 p = skipSome p
skipManyN n p = p *> skipManyN (n - 1) p

count :: Parsec a -> Parsec Int
count = manyl (flip (const (+ 1))) 0

count1 :: Parsec a -> Parsec Int
count1 = somel (flip (const (+ 1))) 0

sepBy :: Parsec a -> Parsec sep -> Parsec [a]
sepBy p sep = sepBy1 p sep <|> pure []

sepBy1 :: Parsec a -> Parsec sep -> Parsec [a]
sepBy1 p sep = p <:> many (sep *> p)

sepEndBy :: Parsec a -> Parsec sep -> Parsec [a]
sepEndBy p sep = sepEndBy1 p sep <|> pure []

sepEndBy1 :: Parsec a -> Parsec sep -> Parsec [a]
sepEndBy1 p sep = let seb1 = p <:> (sep *> (seb1 <|> pure []) <|> pure []) in seb1

endBy :: Parsec a -> Parsec sep -> Parsec [a]
endBy p sep = endBy1 p sep <|> pure []

endBy1 :: Parsec a -> Parsec sep -> Parsec [a]
endBy1 p sep = some (p <* sep)

manyTill :: Parsec a -> Parsec end -> Parsec [a]
manyTill p end = let go = end $> [] <|> p <:> go in go

someTill :: Parsec a -> Parsec end -> Parsec [a]
someTill p end = notFollowedBy end *> (p <:> manyTill p end)

-- this is ifP
ifS :: Parsec Bool -> Parsec a -> Parsec a -> Parsec a
ifS cond t e = branch (bool <$> cond) (const <$> e) (const <$> t)
  where bool True = Right ()
        bool False = Left ()

-- this is when
whenS :: Parsec Bool -> Parsec () -> Parsec ()
whenS cond p = ifS cond p unit

-- this is guard
guardS :: Parsec Bool -> Parsec ()
guardS cond = ifS cond unit empty

-- this is whileP
whileS :: Parsec Bool -> Parsec ()
whileS c = let go = whenS c go in go

exactly :: Int -> Parsec a -> Parsec [a]
exactly n p = traverse (const p) [1..n]

range :: Int -> Int -> Parsec a -> Parsec [a]
range 0 0 _ = pure []
range 0 mx p = p <:> range 0 (mx - 1) p <|> pure []
range mn mx p = p <:> range (mn - 1) mx p

range_ :: Int -> Int -> Parsec a -> Parsec ()
range_ 0 0 _ = unit
range_ 0 mx p = optional (p *> range_ 0 (mx - 1) p)
range_ mn mx p = p *> range_ (mn - 1) mx p

-- this is count overloading
countRange :: Int -> Int -> Parsec a -> Parsec Int
countRange 0 0 _ = pure 0
countRange 0 mx p = liftA2 (const (+ 1)) p (countRange 0 (mx - 1) p) <|> pure 0
countRange mn mx p = liftA2 (const (+ 1)) p (countRange (mn - 1) mx p)
