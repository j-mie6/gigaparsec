<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span>
</span><span id="line-2"></span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# OPTIONS_HADDOCK hide #-}</span><span>
</span><span id="line-4"></span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE DeriveTraversable #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE ExistentialQuantification #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE NamedFieldPuns #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE PatternSynonyms #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskell #-}</span><span>
</span><span id="line-12"></span><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><span id="line-13"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-14"></span><span class="hs-pragma">{-# LANGUAGE TypeOperators #-}</span><span>
</span><span id="line-15"></span><span class="hs-pragma">{-# LANGUAGE UnicodeSyntax #-}</span><span>
</span><span id="line-16"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-17"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-unused-do-bind #-}</span><span>
</span><span id="line-18"></span><span>
</span><span id="line-19"></span><span class="annot"><span class="hs-comment">{- |
Module      : Text.Gigaparsec.Token.Patterns
Description : Template Haskell generators to help with patterns
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : experimental

This module is currently experimental, and may have bugs depending on the version
of Haskell, or the extensions enabled. Please report any issues to the maintainers.

@since 0.2.2.0
-}</span></span><span>
</span><span id="line-31"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html"><span class="hs-identifier">Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-32"></span><span>  </span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html"><span class="hs-identifier">Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-34"></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">safe</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html"><span class="hs-identifier">Text.Gigaparsec.Internal.Token.Lexer</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-36"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexeme"><span class="hs-identifier">Lexeme</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-37"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#charLiteral"><span class="hs-identifier">charLiteral</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#multiStringLiteral"><span class="hs-identifier">multiStringLiteral</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#names"><span class="hs-identifier">names</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-40"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#rawMultiStringLiteral"><span class="hs-identifier">rawMultiStringLiteral</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#rawStringLiteral"><span class="hs-identifier">rawStringLiteral</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#stringLiteral"><span class="hs-identifier">stringLiteral</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#symbol"><span class="hs-identifier">symbol</span></a></span><span>
</span><span id="line-44"></span><span>  </span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-45"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier">Lexer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#lexeme"><span class="hs-identifier">lexeme</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#space"><span class="hs-identifier">space</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Space"><span class="hs-identifier">Space</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-47"></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">safe</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Names.html"><span class="hs-identifier">Text.Gigaparsec.Internal.Token.Names</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Names.html#Names"><span class="hs-identifier">Names</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">safe</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Symbol.html"><span class="hs-identifier">Text.Gigaparsec.Internal.Token.Symbol</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Symbol.html#Symbol"><span class="hs-identifier">Symbol</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">safe</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Text.html"><span class="hs-identifier">Text.Gigaparsec.Internal.Token.Text</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Text.html#TextParsers"><span class="hs-identifier">TextParsers</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.DecUtils.html"><span class="hs-identifier">Text.Gigaparsec.Internal.TH.DecUtils</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.DecUtils.html#funDsingleClause"><span class="hs-identifier">funDsingleClause</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.TypeUtils.html"><span class="hs-identifier">Text.Gigaparsec.Internal.TH.TypeUtils</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.TypeUtils.html#removeUnusedTVars"><span class="hs-identifier">removeUnusedTVars</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.TypeUtils.html#sanitiseBndrStars"><span class="hs-identifier">sanitiseBndrStars</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.TypeUtils.html#sanitiseTypeStars"><span class="hs-identifier">sanitiseTypeStars</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.VersionAgnostic.html"><span class="hs-identifier">Text.Gigaparsec.Internal.TH.VersionAgnostic</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-56"></span><span>  </span><span class="annot"><span class="hs-identifier">Dec</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">DocLoc</span></span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">DeclDoc</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Exp</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Inline</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Inline</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Phases</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">AllPhases</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Q</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Quasi</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">qRecover</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span>
</span><span id="line-57"></span><span>  </span><span class="annot"><span class="hs-identifier">Quote</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">newName</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Type</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ForallT</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">addModFinalizer</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">getDoc</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">isInstance</span></span><span class="hs-special">,</span><span> </span><span>
</span><span id="line-58"></span><span>  </span><span class="annot"><span class="hs-identifier">nameBase</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">putDoc</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">reifyType</span></span><span class="hs-special">,</span><span>
</span><span id="line-59"></span><span>  </span><span class="annot"><span class="hs-identifier">RuleMatch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">FunLike</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-60"></span><span>  </span><span class="annot"><span class="hs-identifier">Type</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">AppT</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ArrowT</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ForallVisT</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span>
</span><span id="line-61"></span><span>  </span><span class="hs-keyword">pattern</span><span> </span><span class="annot"><span class="hs-identifier">MulArrowT</span></span><span class="hs-special">,</span><span>
</span><span id="line-62"></span><span>  </span><span class="annot"><span class="hs-identifier">clause</span></span><span class="hs-special">,</span><span>
</span><span id="line-63"></span><span>  </span><span class="annot"><span class="hs-identifier">funD</span></span><span class="hs-special">,</span><span>
</span><span id="line-64"></span><span>  </span><span class="annot"><span class="hs-identifier">normalB</span></span><span class="hs-special">,</span><span>
</span><span id="line-65"></span><span>  </span><span class="annot"><span class="hs-identifier">pprint</span></span><span class="hs-special">,</span><span>
</span><span id="line-66"></span><span>  </span><span class="annot"><span class="hs-identifier">pragInlD</span></span><span class="hs-special">,</span><span>
</span><span id="line-67"></span><span>  </span><span class="annot"><span class="hs-identifier">sigD</span></span><span class="hs-special">,</span><span>
</span><span id="line-68"></span><span>  </span><span class="annot"><span class="hs-identifier">varE</span></span><span class="hs-special">,</span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span>
</span><span id="line-71"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Bifunctor</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Bifunctor</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">first</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-72"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Constraint</span></span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fromMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-74"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.VersionAgnostic.html"><span class="hs-identifier">Text.Gigaparsec.Internal.TH.VersionAgnostic</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Name</span></span><span class="hs-special">)</span><span>
</span><span id="line-75"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Token.Lexer.html"><span class="hs-identifier">Text.Gigaparsec.Token.Lexer</span></a></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Lexer</span></span><span>
</span><span id="line-76"></span><span>
</span><span id="line-77"></span><span class="annot"><span class="hs-comment">{-|
Generates the specified lexer combinators using a quoted `Lexer`, for example, @[|lexer|]@.

The generated combinators will behave like their counterparts in &quot;Text.Gigaparsec.Token.Lexer&quot;, 
except they won't require a lexer (or subcomponents thereof) to be supplied as an argument.


==== __Usage:__

&gt; import Text.Gigaparsec.Token.Lexer qualified as Lexer
&gt; import Text.Gigaparsec.Token.Lexer (Lexer)
&gt; lexer :: Lexer
&gt; $(lexerCombinators [| lexer |] ['Lexer.lexeme, 'Lexer.fully, 'Lexer.identifier, 'Lexer.stringLiteral])

This will generate the following combinators/functions:

&gt; lexeme :: Lexeme
&gt; fully :: &#8704; a . Parsec a -&gt; Parsec a
&gt; identifier :: Parsec String
&gt; stringLiteral :: TextParsers String

These will behave like their counterparts in &quot;Text.Gigaparsec.Token.Lexer&quot;, except they will not need
a 'Lexer' (or its subcomponents) as an argument.

@since 0.4.0.0

-}</span></span><span>
</span><span id="line-104"></span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinators"><span class="hs-identifier hs-type">lexerCombinators</span></a></span><span>
</span><span id="line-105"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ The quoted 'Lexer'.</span></span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>  </span><span class="annot"><span class="hs-comment">-- ^ The combinators to generate.</span></span><span>
</span><span id="line-107"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ Definitions of the generated combinators.</span></span><span>
</span><span id="line-108"></span><span id="lexerCombinators"><span class="annot"><span class="annottext">lexerCombinators :: Q Exp -&gt; [Name] -&gt; Q [Dec]
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinators"><span class="hs-identifier hs-var hs-var">lexerCombinators</span></a></span></span><span> </span><span id="local-6989586621679253353"><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679253353"><span class="hs-identifier hs-var">lexer</span></a></span></span><span> </span><span id="local-6989586621679253354"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679253354"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q Exp -&gt; [(Name, String)] -&gt; Q [Dec]
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinatorsWithNames"><span class="hs-identifier hs-var">lexerCombinatorsWithNames</span></a></span><span> </span><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679253353"><span class="hs-identifier hs-var">lexer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; [String] -&gt; [(Name, String)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679253354"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; String) -&gt; [Name] -&gt; [String]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679253354"><span class="hs-identifier hs-var">ns</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-109"></span><span>
</span><span id="line-110"></span><span class="annot"><span class="hs-comment">{-|
Generates the specified lexer combinators with the given names using a quoted `Lexer`, for example, @[|lexer|]@.

The generated combinators will behave like their counterparts in &quot;Text.Gigaparsec.Token.Lexer&quot;, 
except they won't require a lexer (or subcomponents thereof) to be supplied as an argument.


==== __Usage:__

&gt; import Text.Gigaparsec.Token.Lexer qualified as Lexer
&gt; import Text.Gigaparsec.Token.Lexer (Lexer)
&gt; lexer :: Lexer
&gt; $(lexerCombinatorsWithNames [| lexer |] [('Lexer.lexeme, &quot;myLexeme&quot;), ('Lexer.fully, &quot;myFully&quot;)])

This will generate the following combinators/functions:

&gt; myLexeme :: Lexeme
&gt; myFully :: &#8704; a . Parsec a -&gt; Parsec a

These will behave like their counterparts in &quot;Text.Gigaparsec.Token.Lexer&quot;, except they will not need
a 'Lexer' (or its subcomponents) as an argument.

@since 0.4.0.0

-}</span></span><span>
</span><span id="line-135"></span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinatorsWithNames"><span class="hs-identifier hs-type">lexerCombinatorsWithNames</span></a></span><span> </span><span>
</span><span id="line-136"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span>            </span><span class="annot"><span class="hs-comment">-- ^ The quoted `Lexer`.</span></span><span>
</span><span id="line-137"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ The combinators to generate with the given name.</span></span><span>
</span><span id="line-138"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span class="hs-special">]</span><span>          </span><span class="annot"><span class="hs-comment">-- ^ Definitions of the generated combinators.</span></span><span>
</span><span id="line-139"></span><span id="lexerCombinatorsWithNames"><span class="annot"><span class="annottext">lexerCombinatorsWithNames :: Q Exp -&gt; [(Name, String)] -&gt; Q [Dec]
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinatorsWithNames"><span class="hs-identifier hs-var hs-var">lexerCombinatorsWithNames</span></a></span></span><span> </span><span id="local-6989586621679253356"><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679253356"><span class="hs-identifier hs-var">lexer</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">([[Dec]] -&gt; [Dec]) -&gt; Q [[Dec]] -&gt; Q [Dec]
forall a b. (a -&gt; b) -&gt; Q a -&gt; Q b
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">[[Dec]] -&gt; [Dec]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">(Q [[Dec]] -&gt; Q [Dec])
-&gt; ([(Name, String)] -&gt; Q [[Dec]]) -&gt; [(Name, String)] -&gt; Q [Dec]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">((Name, String) -&gt; Q [Dec]) -&gt; [(Name, String)] -&gt; Q [[Dec]]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
forall (f :: * -&gt; *) a b.
Applicative f =&gt;
(a -&gt; f b) -&gt; [a] -&gt; f [b]
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; String -&gt; Q [Dec]) -&gt; (Name, String) -&gt; Q [Dec]
forall a b c. (a -&gt; b -&gt; c) -&gt; (a, b) -&gt; c
</span><span class="hs-identifier hs-var">uncurry</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Q Exp -&gt; Name -&gt; String -&gt; Q [Dec]
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinatorWithName"><span class="hs-identifier hs-var">lexerCombinatorWithName</span></a></span><span> </span><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679253356"><span class="hs-identifier hs-var">lexer</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span class="annot"><span class="hs-comment">{-|
Create a single lexer combinator with a given name, defined in terms of the lexer.
-}</span></span><span>
</span><span id="line-144"></span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinatorWithName"><span class="hs-identifier hs-type">lexerCombinatorWithName</span></a></span><span>
</span><span id="line-145"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span>
</span><span id="line-146"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">-- The name of the old combinator</span><span>
</span><span id="line-147"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-comment">-- the new name of the combinator</span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span class="hs-special">]</span><span>
</span><span id="line-149"></span><span id="lexerCombinatorWithName"><span class="annot"><span class="annottext">lexerCombinatorWithName :: Q Exp -&gt; Name -&gt; String -&gt; Q [Dec]
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#lexerCombinatorWithName"><span class="hs-identifier hs-var hs-var">lexerCombinatorWithName</span></a></span></span><span> </span><span id="local-6989586621679253362"><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679253362"><span class="hs-identifier hs-var">lexer</span></a></span></span><span> </span><span id="local-6989586621679253363"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253363"><span class="hs-identifier hs-var">old</span></a></span></span><span> </span><span id="local-6989586621679253364"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679253364"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-150"></span><span>  </span><span id="local-6989586621679253365"><span class="annot"><a href="#local-6989586621679253365"><span class="hs-identifier hs-var">newTp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Bool -&gt; Q Type
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#getLexerCombinatorType"><span class="hs-identifier hs-var">getLexerCombinatorType</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253363"><span class="hs-identifier hs-var">old</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-151"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#mkLexerCombinatorDec"><span class="hs-identifier hs-type">mkLexerCombinatorDec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253362"><span class="hs-identifier hs-type">lexer</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253364"><span class="hs-identifier hs-type">nm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253363"><span class="hs-identifier hs-type">old</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253365"><span class="hs-identifier hs-type">newTp</span></a></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="annot"><span class="hs-comment">{-| 
Constructs the combinator using the given type.
Calculates the definition of the combinator using a typeclass (if possible).
-}</span></span><span>
</span><span id="line-157"></span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#mkLexerCombinatorDec"><span class="hs-identifier hs-type">mkLexerCombinatorDec</span></a></span><span>
</span><span id="line-158"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The quoted Lexer  </span></span><span>
</span><span id="line-159"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The name of the combinator to generate</span></span><span>
</span><span id="line-160"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The quoted name of the original combinator</span></span><span>
</span><span id="line-161"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The return type of the new combinator</span></span><span>
</span><span id="line-162"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span class="hs-special">]</span><span>
</span><span id="line-163"></span><span id="mkLexerCombinatorDec"><span class="annot"><span class="annottext">mkLexerCombinatorDec :: Q Exp -&gt; String -&gt; Name -&gt; Type -&gt; Q [Dec]
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#mkLexerCombinatorDec"><span class="hs-identifier hs-var hs-var">mkLexerCombinatorDec</span></a></span></span><span> </span><span id="local-6989586621679253368"><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679253368"><span class="hs-identifier hs-var">lexer</span></a></span></span><span> </span><span id="local-6989586621679253369"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679253369"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span id="local-6989586621679253370"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253370"><span class="hs-identifier hs-var">old</span></a></span></span><span> </span><span id="local-6989586621679253371"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253371"><span class="hs-identifier hs-var">tp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-164"></span><span>  </span><span id="local-6989586621679253372"><span class="annot"><a href="#local-6989586621679253372"><span class="hs-identifier hs-var">newX</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Name
forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679253369"><span class="hs-identifier hs-var">nm</span></a></span><span>
</span><span id="line-165"></span><span>  </span><span id="local-6989586621679253373"><span class="annot"><a href="#local-6989586621679253373"><span class="hs-identifier hs-var">oldDocs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">getDoc</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DeclDoc</span></span><span> </span><span class="annot"><a href="#local-6989586621679253370"><span class="hs-identifier hs-type">old</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-166"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679253374"><span class="annot"><a href="#local-6989586621679253374"><span class="hs-identifier hs-var hs-var">newDocs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe String -&gt; String
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span> </span><span class="annot"><span class="annottext">Maybe String
</span><a href="#local-6989586621679253373"><span class="hs-identifier hs-var">oldDocs</span></a></span><span>
</span><span id="line-167"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">addModFinalizer</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">putDoc</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DeclDoc</span></span><span> </span><span class="annot"><a href="#local-6989586621679253372"><span class="hs-identifier hs-type">newX</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679253374"><span class="hs-identifier hs-type">newDocs</span></a></span><span>
</span><span id="line-168"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">sequence</span></span><span>
</span><span id="line-169"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pragInlD</span></span><span> </span><span class="annot"><a href="#local-6989586621679253372"><span class="hs-identifier hs-type">newX</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Inline</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">FunLike</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">AllPhases</span></span><span>
</span><span id="line-170"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">sigD</span></span><span> </span><span class="annot"><a href="#local-6989586621679253372"><span class="hs-identifier hs-type">newX</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">pure</span></span><span> </span><span class="annot"><a href="#local-6989586621679253371"><span class="hs-identifier hs-type">tp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-171"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">funD</span></span><span> </span><span class="annot"><a href="#local-6989586621679253372"><span class="hs-identifier hs-type">newX</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">clause</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">normalB</span></span><span> </span><span class="hs-special">[|</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span><span> </span><span class="hs-special">$</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">varE</span></span><span> </span><span class="annot"><a href="#local-6989586621679253370"><span class="hs-identifier hs-type">old</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">$</span><span class="annot"><a href="#local-6989586621679253368"><span class="hs-identifier hs-type">lexer</span></a></span><span class="hs-special">|]</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">]</span><span>
</span><span id="line-172"></span><span>    </span><span class="hs-special">]</span><span>
</span><span id="line-173"></span><span>
</span><span id="line-174"></span><span class="annot"><span class="hs-comment">{-| 
Constructs the combinator using the given type.
Calculates the definition of the combinator using the `LexerField` typeclass (if possible).
-}</span></span><span>
</span><span id="line-178"></span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#mkLexerCombinatorDecWithProj"><span class="hs-identifier hs-type">mkLexerCombinatorDecWithProj</span></a></span><span> </span><span>
</span><span id="line-179"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The quoted Lexer</span></span><span>
</span><span id="line-180"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The name of the combinator to generate</span></span><span>
</span><span id="line-181"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @old@, The quoted name of the original combinator</span></span><span>
</span><span id="line-182"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ The return type of the new combinator</span></span><span>
</span><span id="line-183"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ projection to precompose the @old@ combinator with</span></span><span>
</span><span id="line-184"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ The name of the new combinator and its declaration</span></span><span>
</span><span id="line-185"></span><span id="mkLexerCombinatorDecWithProj"><span class="annot"><span class="annottext">mkLexerCombinatorDecWithProj :: Q Exp -&gt; String -&gt; Name -&gt; Q Type -&gt; Q Exp -&gt; Q (Name, [Dec])
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#mkLexerCombinatorDecWithProj"><span class="hs-identifier hs-var hs-var">mkLexerCombinatorDecWithProj</span></a></span></span><span> </span><span id="local-6989586621679253378"><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679253378"><span class="hs-identifier hs-var">lexer</span></a></span></span><span> </span><span id="local-6989586621679253379"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679253379"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span id="local-6989586621679253380"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253380"><span class="hs-identifier hs-var">old</span></a></span></span><span> </span><span id="local-6989586621679253381"><span class="annot"><span class="annottext">Q Type
</span><a href="#local-6989586621679253381"><span class="hs-identifier hs-var">tp</span></a></span></span><span> </span><span id="local-6989586621679253382"><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679253382"><span class="hs-identifier hs-var">proj</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-186"></span><span>  </span><span id="local-6989586621679253383"><span class="annot"><a href="#local-6989586621679253383"><span class="hs-identifier hs-var">newX</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Name
forall (m :: * -&gt; *). Quote m =&gt; String -&gt; m Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679253379"><span class="hs-identifier hs-var">nm</span></a></span><span>
</span><span id="line-187"></span><span>  </span><span id="local-6989586621679253384"><span class="annot"><a href="#local-6989586621679253384"><span class="hs-identifier hs-var">oldDocs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">getDoc</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DeclDoc</span></span><span> </span><span class="annot"><a href="#local-6989586621679253380"><span class="hs-identifier hs-type">old</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-188"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679253385"><span class="annot"><a href="#local-6989586621679253385"><span class="hs-identifier hs-var hs-var">newDocs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe String -&gt; String
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span> </span><span class="annot"><span class="annottext">Maybe String
</span><a href="#local-6989586621679253384"><span class="hs-identifier hs-var">oldDocs</span></a></span><span>
</span><span id="line-189"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">addModFinalizer</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">putDoc</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DeclDoc</span></span><span> </span><span class="annot"><a href="#local-6989586621679253383"><span class="hs-identifier hs-type">newX</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621679253385"><span class="hs-identifier hs-type">newDocs</span></a></span><span>
</span><span id="line-190"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679253383"><span class="hs-identifier hs-type">newX</span></a></span><span class="hs-special">,</span><span class="hs-special">)</span><span>
</span><span id="line-191"></span><span>    </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">sequence</span></span><span>
</span><span id="line-192"></span><span>      </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="hs-identifier hs-type">pragInlD</span></span><span> </span><span class="annot"><a href="#local-6989586621679253383"><span class="hs-identifier hs-type">newX</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Inline</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">FunLike</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">AllPhases</span></span><span>
</span><span id="line-193"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">sigD</span></span><span> </span><span class="annot"><a href="#local-6989586621679253383"><span class="hs-identifier hs-type">newX</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253381"><span class="hs-identifier hs-type">tp</span></a></span><span>
</span><span id="line-194"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.DecUtils.html#funDsingleClause"><span class="hs-identifier hs-type">funDsingleClause</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253383"><span class="hs-identifier hs-type">newX</span></a></span><span> </span><span class="hs-special">[|</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">$</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">varE</span></span><span> </span><span class="annot"><a href="#local-6989586621679253380"><span class="hs-identifier hs-type">old</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">.</span></span><span> </span><span class="hs-special">$</span><span class="annot"><a href="#local-6989586621679253382"><span class="hs-identifier hs-type">proj</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">$</span><span class="annot"><a href="#local-6989586621679253378"><span class="hs-identifier hs-type">lexer</span></a></span><span class="hs-special">|]</span><span>
</span><span id="line-195"></span><span>      </span><span class="hs-special">]</span><span>
</span><span id="line-196"></span><span>
</span><span id="line-197"></span><span class="annot"><span class="hs-comment">{-| 
Figures out the type of the combinator minus the domain; this will be one of a 'Lexer' component, or any other subcomponents (e.g. 'Symbol' or 'Space').
Calculates the domain type, and the return type of the new combinator.
The boolean flag set to True means one should ensure the domain type gives a specific combinator,
and doesn't lead to an ambiguous return type.
-}</span></span><span>
</span><span id="line-203"></span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#getLexerCombinatorType"><span class="hs-identifier hs-type">getLexerCombinatorType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-204"></span><span id="getLexerCombinatorType"><span class="annot"><span class="annottext">getLexerCombinatorType :: Name -&gt; Bool -&gt; Q Type
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#getLexerCombinatorType"><span class="hs-identifier hs-var hs-var">getLexerCombinatorType</span></a></span></span><span> </span><span id="local-6989586621679253387"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span></span><span> </span><span id="local-6989586621679253388"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679253388"><span class="hs-identifier hs-var">checkType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-205"></span><span>  </span><span id="local-6989586621679253389"><span class="annot"><a href="#local-6989586621679253389"><span class="hs-identifier hs-var">tp</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
</span><span class="hs-identifier hs-var">reifyType</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span><span>
</span><span id="line-206"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679253390"><span class="annot"><a href="#local-6989586621679253390"><span class="hs-identifier hs-var">prefix</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679253391"><span class="annot"><a href="#local-6989586621679253391"><span class="hs-identifier hs-var">dom</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679253392"><span class="annot"><a href="#local-6989586621679253392"><span class="hs-identifier hs-var">cod</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-207"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679253393"><span class="hs-identifier hs-type">notFunctionTypeMsg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253387"><span class="hs-identifier hs-type">old</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253389"><span class="hs-identifier hs-type">tp</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">`qRecover`</span></span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#fnTpDomain"><span class="hs-identifier hs-type">fnTpDomain</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253389"><span class="hs-identifier hs-type">tp</span></a></span><span>
</span><span id="line-208"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679253395"><span class="annot"><a href="#local-6989586621679253395"><span class="hs-identifier hs-var hs-var">newTp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679253390"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253392"><span class="hs-identifier hs-var">cod</span></a></span><span>
</span><span id="line-209"></span><span>  </span><span id="local-6989586621679253396"><span class="annot"><a href="#local-6989586621679253396"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="hs-identifier hs-type">isInstance</span></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">LexerField</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679253391"><span class="hs-identifier hs-type">dom</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-210"></span><span>  </span><span class="hs-keyword">if</span><span> </span><span class="annot"><a href="#local-6989586621679253388"><span class="hs-identifier hs-type">checkType</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">&amp;&amp;</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">not</span></span><span> </span><span class="annot"><a href="#local-6989586621679253396"><span class="hs-identifier hs-type">b</span></a></span><span>
</span><span id="line-211"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><a href="#local-6989586621679253399"><span class="hs-identifier hs-type">catchErrors</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253391"><span class="hs-identifier hs-type">dom</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253395"><span class="hs-identifier hs-type">newTp</span></a></span><span>
</span><span id="line-212"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">$</span></span><span> </span><span class="annot"><a href="#local-6989586621679253390"><span class="hs-identifier hs-type">prefix</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253392"><span class="hs-identifier hs-type">cod</span></a></span><span>
</span><span id="line-213"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-214"></span><span>  </span><span class="hs-comment">-- If the quoted name is not at least a function type, then there's no real way to define the combinator :p</span><span>
</span><span id="line-215"></span><span>  </span><span class="annot"><a href="#local-6989586621679253393"><span class="hs-identifier hs-type">notFunctionTypeMsg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-216"></span><span>  </span><span id="local-6989586621679253393"><span class="annot"><span class="annottext">notFunctionTypeMsg :: Name -&gt; Type -&gt; String
</span><a href="#local-6989586621679253393"><span class="hs-identifier hs-var hs-var">notFunctionTypeMsg</span></a></span></span><span> </span><span id="local-6989586621679253400"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253400"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679253401"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253401"><span class="hs-identifier hs-var">tp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[String] -&gt; String
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Constant `&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253400"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;` does not have a function type: &quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253401"><span class="hs-identifier hs-var">tp</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-217"></span><span>
</span><span id="line-218"></span><span>  </span><span class="hs-comment">-- Preventative Errors: catch the cases someone tries to define one of the String or Integer parsers</span><span>
</span><span id="line-219"></span><span>  </span><span class="hs-comment">-- they should do these manually or with the bespoke generators!</span><span>
</span><span id="line-220"></span><span>  </span><span id="local-6989586621679253232"><span class="annot"><a href="#local-6989586621679253399"><span class="hs-identifier hs-type">catchErrors</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679253232"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-221"></span><span>  </span><span id="local-6989586621679253399"><span class="annot"><span class="annottext">catchErrors :: forall a. Type -&gt; Type -&gt; Q a
</span><a href="#local-6989586621679253399"><span class="hs-identifier hs-var hs-var">catchErrors</span></a></span></span><span> </span><span id="local-6989586621679253408"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253408"><span class="hs-identifier hs-var">dom</span></a></span></span><span> </span><span id="local-6989586621679253409"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253409"><span class="hs-identifier hs-var">newTp</span></a></span></span><span>
</span><span id="line-222"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Lexer.ascii</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q a
forall a. Name -&gt; Q a
</span><a href="#local-6989586621679253410"><span class="hs-identifier hs-var">failStringParser</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span><span>
</span><span id="line-223"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Lexer.unicode</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q a
forall a. Name -&gt; Q a
</span><a href="#local-6989586621679253410"><span class="hs-identifier hs-var">failStringParser</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span><span>
</span><span id="line-224"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="hs-special">'</span><span class="hs-identifier">Lexer.latin1</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q a
forall a. Name -&gt; Q a
</span><a href="#local-6989586621679253410"><span class="hs-identifier hs-var">failStringParser</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span><span>
</span><span id="line-225"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q a
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; String
</span><a href="#local-6989586621679253411"><span class="hs-identifier hs-var">notLexerFieldMsg</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253387"><span class="hs-identifier hs-var">old</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253408"><span class="hs-identifier hs-var">dom</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-226"></span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-comment">-- Message to give to the user when they give a TextParser field, as there is no way to disambiguate</span><span>
</span><span id="line-228"></span><span>  </span><span class="hs-comment">-- exactly *which* TextParser they want.</span><span>
</span><span id="line-229"></span><span>  </span><span class="hs-comment">-- And there is no point in implementing a way for the user to ask for this;</span><span>
</span><span id="line-230"></span><span>  </span><span class="hs-comment">-- at that point, it would be no more work on the user's end than were they to write a manual definition.</span><span>
</span><span id="line-231"></span><span>  </span><span id="local-6989586621679253238"><span class="annot"><a href="#local-6989586621679253410"><span class="hs-identifier hs-type">failStringParser</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679253238"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-232"></span><span>  </span><span id="local-6989586621679253410"><span class="annot"><span class="annottext">failStringParser :: forall a. Name -&gt; Q a
</span><a href="#local-6989586621679253410"><span class="hs-identifier hs-var hs-var">failStringParser</span></a></span></span><span> </span><span id="local-6989586621679253420"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253420"><span class="hs-identifier hs-var">nm</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-233"></span><span>    </span><span class="annot"><span class="annottext">String -&gt; Q a
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q a) -&gt; String -&gt; Q a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-234"></span><span>      </span><span class="annot"><span class="annottext">[String] -&gt; String
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span>
</span><span id="line-235"></span><span>        </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Cannot derive a lexer combinator for `&quot;</span></span><span>
</span><span id="line-236"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253420"><span class="hs-identifier hs-var">nm</span></a></span><span>
</span><span id="line-237"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;`, as there are many possible &quot;</span></span><span>
</span><span id="line-238"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="hs-special">''</span><span class="hs-identifier">TextParsers</span><span>
</span><span id="line-239"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; to define it in terms of, including:&quot;</span></span><span>
</span><span id="line-240"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="hs-special">'</span><span class="hs-identifier">stringLiteral</span><span>
</span><span id="line-241"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;, &quot;</span></span><span>
</span><span id="line-242"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="hs-special">'</span><span class="hs-identifier">rawStringLiteral</span><span>
</span><span id="line-243"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;, &quot;</span></span><span>
</span><span id="line-244"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="hs-special">'</span><span class="hs-identifier">multiStringLiteral</span><span>
</span><span id="line-245"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;, and &quot;</span></span><span>
</span><span id="line-246"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="hs-special">'</span><span class="hs-identifier">rawMultiStringLiteral</span><span>
</span><span id="line-247"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;.&quot;</span></span><span>
</span><span id="line-248"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n You will need to manually define this combinator, as you are then able to pick which TextParser it should use.&quot;</span></span><span>
</span><span id="line-249"></span><span>        </span><span class="hs-special">]</span><span>
</span><span id="line-250"></span><span>
</span><span id="line-251"></span><span>  </span><span class="hs-comment">-- If the quoted name is not a recognised lexer field, then we should tell the user as much.</span><span>
</span><span id="line-252"></span><span>  </span><span class="hs-comment">-- The error may be due to being able to disambiguate the field, rather than the field not existing.</span><span>
</span><span id="line-253"></span><span>  </span><span class="annot"><a href="#local-6989586621679253411"><span class="hs-identifier hs-type">notLexerFieldMsg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-254"></span><span>  </span><span id="local-6989586621679253411"><span class="annot"><span class="annottext">notLexerFieldMsg :: Name -&gt; Type -&gt; String
</span><a href="#local-6989586621679253411"><span class="hs-identifier hs-var hs-var">notLexerFieldMsg</span></a></span></span><span> </span><span id="local-6989586621679253421"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253421"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679253422"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253422"><span class="hs-identifier hs-var">tp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-255"></span><span>    </span><span class="annot"><span class="annottext">[String] -&gt; String
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span>
</span><span id="line-256"></span><span>      </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Cannot produce a lexer combinator for function: &quot;</span></span><span>
</span><span id="line-257"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679253421"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-258"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;.&quot;</span></span><span>
</span><span id="line-259"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n This is because the type: `&quot;</span></span><span>
</span><span id="line-260"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253422"><span class="hs-identifier hs-var">tp</span></a></span><span>
</span><span id="line-261"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;` cannot be used to give a precise combinator, either because it does not refer to &quot;</span></span><span>
</span><span id="line-262"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;any fields of a `Lexer`, or because it ambiguously refers to many fields of a `Lexer`.&quot;</span></span><span>
</span><span id="line-263"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n Some fields of the `Lexer` share the same type, so there are multiple possible candidate combinators for a particular field.&quot;</span></span><span>
</span><span id="line-264"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; For example: &quot;</span></span><span>
</span><span id="line-265"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n   - `decimal`, `hexadecimal`,... all have type `IntegerParsers canHold -&gt; Parsec Integer`.&quot;</span></span><span>
</span><span id="line-266"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;\n   - `ascii`, `unicode`, ... all have type `TextParsers t -&gt; Parsec t`.&quot;</span></span><span>
</span><span id="line-267"></span><span>      </span><span class="hs-special">]</span><span>
</span><span id="line-268"></span><span>
</span><span id="line-269"></span><span class="hs-comment">---------------------------------------------------------------------------------------------------</span><span>
</span><span id="line-270"></span><span class="hs-comment">-- Util functions</span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span class="annot"><span class="hs-comment">{-|
Denote the type of an arrow; it is either normal or linear.
-}</span></span><span>
</span><span id="line-275"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#ArrowTp"><span class="hs-identifier hs-type">ArrowTp</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span>
</span><span id="line-276"></span><span class="hs-keyword">data</span><span> </span><span id="ArrowTp"><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#ArrowTp"><span class="hs-identifier hs-var">ArrowTp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="StdArrow"><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#StdArrow"><span class="hs-identifier hs-var">StdArrow</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="LinearArrow"><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LinearArrow"><span class="hs-identifier hs-var">LinearArrow</span></a></span></span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span class="annot"><span class="hs-comment">{-|
Get the domain of a function type.
Keep any prefixed constraints and type variable quantifiers as a prefixing function.
-}</span></span><span>
</span><span id="line-282"></span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#fnTpDomain"><span class="hs-identifier hs-type">fnTpDomain</span></a></span><span>
</span><span id="line-283"></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#ArrowTp"><span class="hs-identifier hs-type">ArrowTp</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-285"></span><span class="hs-comment">-- The head of the type, includes any preceding constraints</span><span>
</span><span id="line-286"></span><span class="hs-comment">-- and foralls. this is a function which prefixes the given type with the constraints/foralls</span><span>
</span><span id="line-287"></span><span class="hs-comment">-- The domain and codomain of the type</span><span>
</span><span id="line-288"></span><span id="fnTpDomain"><span class="annot"><span class="annottext">fnTpDomain :: Type -&gt; Q (Type -&gt; Type, Type, ArrowTp, Type)
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#fnTpDomain"><span class="hs-identifier hs-var hs-var">fnTpDomain</span></a></span></span><span> </span><span id="local-6989586621679253425"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253425"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-289"></span><span>  </span><span class="hs-special">(</span><span id="local-6989586621679253426"><span class="annot"><a href="#local-6989586621679253426"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679253427"><span class="annot"><a href="#local-6989586621679253427"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679253428"><span class="annot"><a href="#local-6989586621679253428"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679253429"><span class="annot"><a href="#local-6989586621679253429"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q (Type -&gt; Type, (Type, ArrowTp, Type))
</span><a href="#local-6989586621679253430"><span class="hs-identifier hs-var">fnTpDomain'</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q (Type -&gt; Type, (Type, ArrowTp, Type)))
-&gt; Q Type -&gt; Q (Type -&gt; Type, (Type, ArrowTp, Type))
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Text.Gigaparsec.Internal.TH.TypeUtils.html#sanitiseTypeStars"><span class="hs-identifier hs-var">sanitiseTypeStars</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253425"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-290"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.TH.TypeUtils.html#removeUnusedTVars"><span class="hs-identifier hs-type">removeUnusedTVars</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">.</span></span><span> </span><span class="annot"><a href="#local-6989586621679253426"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679253427"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679253428"><span class="hs-identifier hs-type">c</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621679253429"><span class="hs-identifier hs-type">d</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-291"></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-292"></span><span>  </span><span id="local-6989586621679253430"><span class="annot"><span class="annottext">fnTpDomain' :: Type -&gt; Q (Type -&gt; Type, (Type, ArrowTp, Type))
</span><a href="#local-6989586621679253430"><span class="hs-identifier hs-var hs-var">fnTpDomain'</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679253443"><span class="annot"><span class="annottext">[TyVarBndr Specificity]
</span><a href="#local-6989586621679253443"><span class="hs-identifier hs-var">bnds</span></a></span></span><span> </span><span id="local-6989586621679253444"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621679253444"><span class="hs-identifier hs-var">ctx</span></a></span></span><span> </span><span id="local-6989586621679253445"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253445"><span class="hs-identifier hs-var">tp</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-293"></span><span>    </span><span id="local-6989586621679253446"><span class="annot"><a href="#local-6989586621679253446"><span class="hs-identifier hs-var">bnds'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr Specificity] -&gt; Q [TyVarBndr Specificity]
forall flag. [TyVarBndr flag] -&gt; Q [TyVarBndr flag]
</span><a href="Text.Gigaparsec.Internal.TH.TypeUtils.html#sanitiseBndrStars"><span class="hs-identifier hs-var">sanitiseBndrStars</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr Specificity]
</span><a href="#local-6989586621679253443"><span class="hs-identifier hs-var">bnds</span></a></span><span>
</span><span id="line-294"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">first</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ForallT</span></span><span> </span><span class="annot"><span class="hs-identifier">bnds'</span></span><span> </span><span class="annot"><span class="hs-identifier">ctx</span></span><span> </span><span class="annot"><span class="hs-operator">.</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621679253430"><span class="hs-identifier hs-type">fnTpDomain'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253445"><span class="hs-identifier hs-type">tp</span></a></span><span>
</span><span id="line-295"></span><span>  </span><span class="annot"><a href="#local-6989586621679253430"><span class="hs-identifier hs-var">fnTpDomain'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallVisT</span></span><span> </span><span id="local-6989586621679253447"><span class="annot"><span class="annottext">[TyVarBndr ()]
</span><a href="#local-6989586621679253447"><span class="hs-identifier hs-var">bnds</span></a></span></span><span> </span><span id="local-6989586621679253448"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253448"><span class="hs-identifier hs-var">tp</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-296"></span><span>    </span><span id="local-6989586621679253449"><span class="annot"><a href="#local-6989586621679253449"><span class="hs-identifier hs-var">bnds'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr ()] -&gt; Q [TyVarBndr ()]
forall flag. [TyVarBndr flag] -&gt; Q [TyVarBndr flag]
</span><a href="Text.Gigaparsec.Internal.TH.TypeUtils.html#sanitiseBndrStars"><span class="hs-identifier hs-var">sanitiseBndrStars</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr ()]
</span><a href="#local-6989586621679253447"><span class="hs-identifier hs-var">bnds</span></a></span><span>
</span><span id="line-297"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">first</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">ForallVisT</span></span><span> </span><span class="annot"><span class="hs-identifier">bnds'</span></span><span> </span><span class="annot"><span class="hs-operator">.</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-operator hs-type">&lt;$&gt;</span></span><span> </span><span class="annot"><a href="#local-6989586621679253430"><span class="hs-identifier hs-type">fnTpDomain'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679253448"><span class="hs-identifier hs-type">tp</span></a></span><span>
</span><span id="line-298"></span><span>  </span><span class="annot"><a href="#local-6989586621679253430"><span class="hs-identifier hs-var">fnTpDomain'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">ArrowT</span></span><span> </span><span id="local-6989586621679253450"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253450"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679253451"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253451"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-299"></span><span>    </span><span class="annot"><span class="annottext">(Type -&gt; Type, (Type, ArrowTp, Type))
-&gt; Q (Type -&gt; Type, (Type, ArrowTp, Type))
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253450"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ArrowTp
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#StdArrow"><span class="hs-identifier hs-var">StdArrow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253451"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-300"></span><span>  </span><span class="annot"><a href="#local-6989586621679253430"><span class="hs-identifier hs-var">fnTpDomain'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">MulArrowT</span></span><span> </span><span id="local-6989586621679253453"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253453"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679253454"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253454"><span class="hs-identifier hs-var">b</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-301"></span><span>    </span><span class="annot"><span class="annottext">(Type -&gt; Type, (Type, ArrowTp, Type))
-&gt; Q (Type -&gt; Type, (Type, ArrowTp, Type))
forall a. a -&gt; Q a
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253453"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ArrowTp
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LinearArrow"><span class="hs-identifier hs-var">LinearArrow</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253454"><span class="hs-identifier hs-var">b</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-302"></span><span>  </span><span class="annot"><a href="#local-6989586621679253430"><span class="hs-identifier hs-var">fnTpDomain'</span></a></span><span> </span><span id="local-6989586621679253455"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253455"><span class="hs-identifier hs-var">tp</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-303"></span><span>    </span><span class="annot"><span class="annottext">String -&gt; Q (Type -&gt; Type, (Type, ArrowTp, Type))
forall a. String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span>
</span><span id="line-304"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Type of given function is not a function type: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; String
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679253455"><span class="hs-identifier hs-var">tp</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-305"></span><span>
</span><span id="line-306"></span><span class="hs-comment">---------------------------------------------------------------------------------------------------</span><span>
</span><span id="line-307"></span><span class="hs-comment">-- Lexer Field</span><span>
</span><span id="line-308"></span><span>
</span><span id="line-309"></span><span class="annot"><span class="hs-comment">{- |
@a@ is a `LexerField` when it is the type of a component or subcomponent of the `Lexer` type.
This includes things like `Lexeme` and `Symbol`.

Avoid writing instances for:
- IntegerParsers
- TextParsers String

As this leads to ambiguous projections if users try to generate combinators for, e.g., 'Lexer.decimal.
There are two possible instances here, one for `integer`, the other for `natural`, and there is no way to disambiguate here.
By avoiding writing these instances, we can give the user a more informative error message should they try this.
-}</span></span><span>
</span><span id="line-321"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerField"><span class="hs-identifier hs-type">LexerField</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Constraint</span></span><span>
</span><span id="line-322"></span><span class="hs-keyword">class</span><span> </span><span id="LexerField"><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerField"><span class="hs-identifier hs-var">LexerField</span></a></span></span><span> </span><span id="local-6989586621679253258"><span class="annot"><a href="#local-6989586621679253258"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-323"></span><span>  </span><span id="project"><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679253256"><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679253258"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253256"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253256"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-324"></span><span>
</span><span id="line-325"></span><span class="hs-keyword">type</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerProj"><span class="hs-identifier hs-type">LexerProj</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-operator">*</span></span><span>
</span><span id="line-326"></span><span class="hs-keyword">type</span><span> </span><span id="LexerProj"><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerProj"><span class="hs-identifier hs-var">LexerProj</span></a></span></span><span> </span><span id="local-6989586621679253457"><span class="annot"><a href="#local-6989586621679253457"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span id="local-6989586621679253458"><span class="annot"><a href="#local-6989586621679253458"><span class="hs-identifier hs-type">b</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679253457"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253458"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253458"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-327"></span><span>
</span><span id="line-328"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerField"><span class="hs-identifier hs-type">LexerField</span></a></span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-329"></span><span>  </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-pragma hs-type">project</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-330"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679253462"><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253462"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253462"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-331"></span><span>  </span><span id="local-6989586621679253463"><span class="annot"><span class="annottext">project :: forall b. (Lexer -&gt; b) -&gt; Lexer -&gt; b
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-var hs-var hs-var">project</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Lexer -&gt; b) -&gt; Lexer -&gt; b
forall a. a -&gt; a
</span><span class="hs-identifier hs-var">id</span></span><span>
</span><span id="line-332"></span><span>
</span><span id="line-333"></span><span class="hs-comment">---------------------------------------------------------------------------------------------------</span><span>
</span><span id="line-334"></span><span class="hs-comment">-- Lexemes</span><span>
</span><span id="line-335"></span><span>
</span><span id="line-336"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerField"><span class="hs-identifier hs-type">LexerField</span></a></span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-337"></span><span>  </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-pragma hs-type">project</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-338"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679253466"><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexeme"><span class="hs-identifier hs-type">Lexeme</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253466"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253466"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-339"></span><span>  </span><span id="local-6989586621679253467"><span class="annot"><span class="annottext">project :: forall b. (Lexeme -&gt; b) -&gt; Lexer -&gt; b
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-var hs-var hs-var">project</span></a></span></span><span> </span><span id="local-6989586621679253468"><span class="annot"><span class="annottext">Lexeme -&gt; b
</span><a href="#local-6989586621679253468"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Lexeme -&gt; b
</span><a href="#local-6989586621679253468"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(Lexeme -&gt; b) -&gt; (Lexer -&gt; Lexeme) -&gt; Lexer -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Lexer -&gt; Lexeme
</span><a href="Text.Gigaparsec.Internal.Token.Lexer.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span>
</span><span id="line-340"></span><span>
</span><span id="line-341"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerField"><span class="hs-identifier hs-type">LexerField</span></a></span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Symbol.html#Symbol"><span class="hs-identifier hs-type">Symbol</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-342"></span><span>  </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-pragma hs-type">project</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-343"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679253471"><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Symbol.html#Symbol"><span class="hs-identifier hs-type">Symbol</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253471"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253471"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-344"></span><span>  </span><span id="local-6989586621679253472"><span class="annot"><span class="annottext">project :: forall b. (Symbol -&gt; b) -&gt; Lexer -&gt; b
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-var hs-var hs-var">project</span></a></span></span><span> </span><span id="local-6989586621679253473"><span class="annot"><span class="annottext">Symbol -&gt; b
</span><a href="#local-6989586621679253473"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Symbol -&gt; b
</span><a href="#local-6989586621679253473"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(Symbol -&gt; b) -&gt; (Lexer -&gt; Symbol) -&gt; Lexer -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Lexeme -&gt; Symbol
</span><a href="Text.Gigaparsec.Internal.Token.Lexer.html#symbol"><span class="hs-identifier hs-var">symbol</span></a></span><span> </span><span class="annot"><span class="annottext">(Lexeme -&gt; Symbol) -&gt; (Lexer -&gt; Lexeme) -&gt; Lexer -&gt; Symbol
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Lexer -&gt; Lexeme
</span><a href="Text.Gigaparsec.Internal.Token.Lexer.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span>
</span><span id="line-345"></span><span>
</span><span id="line-346"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerField"><span class="hs-identifier hs-type">LexerField</span></a></span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Names.html#Names"><span class="hs-identifier hs-type">Names</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-347"></span><span>  </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-pragma hs-type">project</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-348"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679253476"><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Names.html#Names"><span class="hs-identifier hs-type">Names</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253476"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253476"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-349"></span><span>  </span><span id="local-6989586621679253477"><span class="annot"><span class="annottext">project :: forall b. (Names -&gt; b) -&gt; Lexer -&gt; b
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-var hs-var hs-var">project</span></a></span></span><span> </span><span id="local-6989586621679253478"><span class="annot"><span class="annottext">Names -&gt; b
</span><a href="#local-6989586621679253478"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Names -&gt; b
</span><a href="#local-6989586621679253478"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(Names -&gt; b) -&gt; (Lexer -&gt; Names) -&gt; Lexer -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Lexeme -&gt; Names
</span><a href="Text.Gigaparsec.Internal.Token.Lexer.html#names"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">(Lexeme -&gt; Names) -&gt; (Lexer -&gt; Lexeme) -&gt; Lexer -&gt; Names
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Lexer -&gt; Lexeme
</span><a href="Text.Gigaparsec.Internal.Token.Lexer.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span>
</span><span id="line-350"></span><span>
</span><span id="line-351"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerField"><span class="hs-identifier hs-type">LexerField</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Text.html#TextParsers"><span class="hs-identifier hs-type">TextParsers</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-352"></span><span>  </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-pragma hs-type">project</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-353"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679253481"><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Text.html#TextParsers"><span class="hs-identifier hs-type">TextParsers</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253481"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253481"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-354"></span><span>  </span><span id="local-6989586621679253482"><span class="annot"><span class="annottext">project :: forall b. (TextParsers Char -&gt; b) -&gt; Lexer -&gt; b
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-var hs-var hs-var">project</span></a></span></span><span> </span><span id="local-6989586621679253483"><span class="annot"><span class="annottext">TextParsers Char -&gt; b
</span><a href="#local-6989586621679253483"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TextParsers Char -&gt; b
</span><a href="#local-6989586621679253483"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(TextParsers Char -&gt; b)
-&gt; (Lexer -&gt; TextParsers Char) -&gt; Lexer -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Lexeme -&gt; TextParsers Char
</span><a href="Text.Gigaparsec.Internal.Token.Lexer.html#charLiteral"><span class="hs-identifier hs-var">charLiteral</span></a></span><span> </span><span class="annot"><span class="annottext">(Lexeme -&gt; TextParsers Char)
-&gt; (Lexer -&gt; Lexeme) -&gt; Lexer -&gt; TextParsers Char
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Lexer -&gt; Lexeme
</span><a href="Text.Gigaparsec.Internal.Token.Lexer.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span>
</span><span id="line-355"></span><span>
</span><span id="line-356"></span><span class="hs-comment">---------------------------------------------------------------------------------------------------</span><span>
</span><span id="line-357"></span><span class="hs-comment">-- Space</span><span>
</span><span id="line-358"></span><span>
</span><span id="line-359"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#LexerField"><span class="hs-identifier hs-type">LexerField</span></a></span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Space"><span class="hs-identifier hs-type">Space</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-360"></span><span>  </span><span class="hs-pragma">{-# INLINE</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-pragma hs-type">project</span></a></span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-361"></span><span>  </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-type">project</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span id="local-6989586621679253486"><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Space"><span class="hs-identifier hs-type">Space</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253486"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#Lexer"><span class="hs-identifier hs-type">Lexer</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679253486"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-362"></span><span>  </span><span id="local-6989586621679253487"><span class="annot"><span class="annottext">project :: forall b. (Space -&gt; b) -&gt; Lexer -&gt; b
</span><a href="Text.Gigaparsec.Internal.Token.Patterns.LexerCombinators.html#project"><span class="hs-identifier hs-var hs-var hs-var">project</span></a></span></span><span> </span><span id="local-6989586621679253488"><span class="annot"><span class="annottext">Space -&gt; b
</span><a href="#local-6989586621679253488"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Space -&gt; b
</span><a href="#local-6989586621679253488"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">(Space -&gt; b) -&gt; (Lexer -&gt; Space) -&gt; Lexer -&gt; b
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Lexer -&gt; Space
</span><a href="Text.Gigaparsec.Internal.Token.Lexer.html#space"><span class="hs-identifier hs-var">space</span></a></span><span>
</span><span id="line-363"></span></pre></body></html>