<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Safe #-}</span><span>
</span><span id="line-2"></span><span class="annot"><span class="hs-comment">{-|
Module      : Text.Gigaparsec.Combinator
Description : This module contains a huge number of pre-made combinators that are
              very useful for a variety of purposes.
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : stable

This module contains a huge number of pre-made combinators that are very useful for a variety of purposes.

In particular, it contains combinators for: performing a parser iteratively, collecting all the results;
querying whether or not any input is left; optionally performing parsers; parsing delimited constructions;
handling multiple possible alternatives or parsers to sequence; handling more complex conditional execution;
and more.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-19"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Text.Gigaparsec.Combinator</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-20"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Iterative Combinators</span></span><span>
</span><span id="line-21"></span><span>  </span><span class="hs-comment">-- | These combinators all execute a given parser an unbounded number of times, until either it fails, or another</span><span>
</span><span id="line-22"></span><span>  </span><span class="hs-comment">-- parser succeeds, depending on the combinator. Depending on the combinator, all of the results produced by the</span><span>
</span><span id="line-23"></span><span>  </span><span class="hs-comment">-- repeated execution of the parser may be returned in a @[]@. These are almost essential for any practical parsing</span><span>
</span><span id="line-24"></span><span>  </span><span class="hs-comment">-- task.</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier">manyN</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier">skipMany</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier">skipSome</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier">skipManyN</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier">count</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier">count1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier">manyTill</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier">someTill</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Optional Parsing Combinators</span></span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the /possible/ parsing of some parser. If the parser succeeds, that is ok</span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-comment">-- so long as it __did not consume input__. Be aware that the result of the success may be replaced with</span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-comment">-- these combinators, with the exception of &quot;option&quot;, which still preserves the result.</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier">option</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier">optional</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier">optionalAs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier">decide</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier">fromMaybeS</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>
</span><span id="line-33"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Separated Values Combinators</span></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-comment">-- | These combinators are concerned with delimited parsing, where one parser is repeated but delimited by another one.</span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-comment">-- In each of these cases @p@ is the parser of interest and @sep@ is the delimeter. These combinators mainly differ</span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-comment">-- in either the number of @p@s they require, or exactly where the delimeters are allowed (only between, always</span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-comment">-- trailing, or either). In all cases, they return the list of results generated by the repeated parses of @p@.</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier">sepBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier">sepBy1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier">sepEndBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier">sepEndBy1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier">endBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier">endBy1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Multiple Branching/Sequencing Combinators</span></span><span>
</span><span id="line-41"></span><span>  </span><span class="annot"><span class="hs-comment">-- | These combinators allow for testing or sequencing a large number of parsers in one go.</span></span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier">choice</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">sequence</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">traverse</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier">skip</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Range Combinators</span></span><span>
</span><span id="line-45"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the parsing of a specific parser either a specific number of times, or between a certain</span><span>
</span><span id="line-46"></span><span>  </span><span class="hs-comment">-- amount of times.</span><span>
</span><span id="line-47"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier">exactly</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier">range</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier">range_</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier">countRange</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Selective Combinators</span></span><span>
</span><span id="line-50"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the conditional extraction of a result, or the execution of a parser</span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-comment">-- based on another. They are derived from &quot;branch&quot;.</span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier">ifS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier">whenS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier">guardS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier">whileS</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html"><span class="hs-identifier">Text.Gigaparsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier">Parsec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">many</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">some</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator">($&gt;)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator">(&lt;:&gt;)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">select</span></span><span class="hs-special">,</span><span>
</span><span id="line-56"></span><span>                        </span><span class="annot"><span class="hs-identifier">branch</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword">unit</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#manyl"><span class="hs-identifier">manyl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#somel"><span class="hs-identifier">somel</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier">notFollowedBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">liftA2</span></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">asum</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">sequenceA_</span></span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span class="annot"><span class="hs-comment">{-|
This combinator tries to parse each of the parsers @ps@ in order, until one of them succeeds.

Finds the first parser in @ps@ which succeeds, returning its result. If Nothing of the parsers
succeed, then this combinator fails. If a parser fails having consumed input, this combinator
fails __immediately__.

==== __Examples__
&gt;&gt;&gt; let p = choice [string &quot;abc&quot;, string &quot;ab&quot;, string &quot;bc&quot;, string &quot;d&quot;]
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success &quot;abc&quot;
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;bc&quot;
Success &quot;bc&quot;
&gt;&gt;&gt; parse @String p &quot;x&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-79"></span><span id="local-6989586621679071976"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier hs-type">choice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679071976"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parsers, @ps@ to try, in order.</span></span><span>
</span><span id="line-80"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679071976"><span class="hs-identifier hs-type">a</span></a></span></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to parse one of @ps@.</span></span><span>
</span><span id="line-81"></span><span id="choice"><span class="annot"><span class="annottext">choice :: forall a. [Parsec a] -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier hs-var hs-var">choice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parsec a] -&gt; Parsec a
forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><span class="hs-identifier hs-var">asum</span></span><span>
</span><span id="line-82"></span><span>
</span><span id="line-83"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse each of @ps@ in order, discarding the results.

Given the parsers @ps@, consisting of @p1@ through @pn@, parses
each in order. If they all succeed, this combinator succeeds. If any of
the parsers fail, then the whole combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = skip [char'a', item, char 'c']
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-99"></span><span id="local-6989586621679071981"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier hs-type">skip</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679071981"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ parsers @ps@ to be sequenced.</span></span><span>
</span><span id="line-100"></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses each of @ps@, returning @()@.</span></span><span>
</span><span id="line-101"></span><span id="skip"><span class="annot"><span class="annottext">skip :: forall a. [Parsec a] -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier hs-var hs-var">skip</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parsec a] -&gt; Parsec ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Applicative f) =&gt;
t (f a) -&gt; f ()
</span><span class="hs-identifier hs-var">sequenceA_</span></span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span class="annot"><span class="hs-comment">{-|
This combinator tries to parse @p@, wrapping its result in a @Just@ if it succeeds, or returns @Nothing@ if it fails.

Tries to parse @p@. If @p@ succeeded, producing @x@, then @Just x@ is returned. Otherwise, if @p@ failed
__without consuming input__, then @Nothing@ is returned instead.

==== __Examples__
&gt;&gt;&gt; let p = option (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success Nothing
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success (Just &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-120"></span><span id="local-6989586621679071986"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier hs-type">option</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679071986"><span class="hs-identifier hs-type">a</span></a></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse</span></span><span>
</span><span id="line-121"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679071986"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-122"></span><span id="option"><span class="annot"><span class="annottext">option :: forall a. Parsec a -&gt; Parsec (Maybe a)
</span><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier hs-var hs-var">option</span></a></span></span><span> </span><span id="local-6989586621679072143"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072143"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; Parsec a -&gt; Parsec (Maybe a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072143"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a) -&gt; Parsec (Maybe a) -&gt; Parsec (Maybe a)
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; Parsec (Maybe a)
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-123"></span><span>
</span><span id="line-124"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse @p@ if possible, otherwise will do nothing.

Tries to parse @p@. If @p@ succeeds, or fails __without consuming input__ then this combinator is successful. Otherwise, if @p@ failed
having consumed input, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = optional (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-141"></span><span id="local-6989586621679071996"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-type">optional</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679071996"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse.</span></span><span>
</span><span id="line-142"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-143"></span><span id="optional"><span class="annot"><span class="annottext">optional :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-var hs-var">optional</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Parsec a -&gt; Parsec ()
forall b a. b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-var">optionalAs</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse @p@ if possible, otherwise will do nothing.

Tries to parse @p@. If @p@ succeeds, or fails __without consuming input__ then this combinator is successful and returns @x@. Otherwise,
if @p@ failed having consumed input, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = optionalAs 7 (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success 7
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success 7
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-162"></span><span id="local-6989586621679071998"><span id="local-6989586621679071999"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-type">optionalAs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679071998"><span class="hs-identifier hs-type">b</span></a></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ the value @x@ to return regardless of how @p@ performs.</span></span><span>
</span><span id="line-163"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679071999"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse.</span></span><span>
</span><span id="line-164"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679071998"><span class="hs-identifier hs-type">b</span></a></span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to parse @p@, returning @x@ regardless of success or failure.</span></span><span>
</span><span id="line-165"></span><span id="optionalAs"><span class="annot"><span class="annottext">optionalAs :: forall b a. b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-var hs-var">optionalAs</span></a></span></span><span> </span><span id="local-6989586621679072147"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679072147"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679072148"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072148"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072148"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; b -&gt; Parsec b
forall a b. Parsec a -&gt; b -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679072147"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec b -&gt; Parsec b -&gt; Parsec b
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; Parsec b
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679072147"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="hs-comment">-- TODO: collect</span><span>
</span><span id="line-168"></span><span class="annot"><span class="hs-comment">{-|
This combinator can eliminate an @Maybe@ from the result of the parser @p@.

First parse @p@, if it succeeds returning @Just x@, then return @x@. However,
if @p@ fails, or returned @Nothing@, then this combinator fails.

==== __Examples__
@decide (option p) = p@
-}</span></span><span>
</span><span id="line-177"></span><span id="local-6989586621679072004"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier hs-type">decide</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679072004"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to parse and extract the result from.</span></span><span>
</span><span id="line-178"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072004"><span class="hs-identifier hs-type">a</span></a></span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to extract the result from @p@.</span></span><span>
</span><span id="line-179"></span><span id="decide"><span class="annot"><span class="annottext">decide :: forall a. Parsec (Maybe a) -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier hs-var hs-var">decide</span></a></span></span><span> </span><span id="local-6989586621679072153"><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679072153"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679072153"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a) -&gt; (Maybe a -&gt; Parsec a) -&gt; Parsec a
forall a b. Parsec a -&gt; (a -&gt; Parsec b) -&gt; Parsec b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; (a -&gt; Parsec a) -&gt; Maybe a -&gt; Parsec a
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
forall a. Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><span class="hs-identifier hs-var">empty</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Parsec a
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span class="hs-comment">-- this is decide overload</span><span>
</span><span id="line-182"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses @q@ depending only if @p@ returns a @Nothing@.

First parses @p@. If @p@ returned @Just x@, then @x@ is returned.
Otherwise, if @p@ returned @Nothing@ then @q@ is parsed, producing @y@,
and @y@ is returned. If @p@ or @q@ fails, the combinator fails.

==== __Examples__
fromMaybe q (option p) = p &lt;|&gt; q

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-194"></span><span id="local-6989586621679072012"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier hs-type">fromMaybeS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072012"><span class="hs-identifier hs-type">a</span></a></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser to execute when @p@ returns @Nothing@, to provide a value of type @a@.</span></span><span>
</span><span id="line-195"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679072012"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the first parser @p@, which returns an @Maybe@ to eliminate.</span></span><span>
</span><span id="line-196"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072012"><span class="hs-identifier hs-type">a</span></a></span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser that either just parses @p@ or both @p@ and @q@ in order to return an @a@.</span></span><span>
</span><span id="line-197"></span><span id="fromMaybeS"><span class="annot"><span class="annottext">fromMaybeS :: forall a. Parsec a -&gt; Parsec (Maybe a) -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier hs-var hs-var">fromMaybeS</span></a></span></span><span> </span><span id="local-6989586621679072159"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072159"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621679072160"><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679072160"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Either () a) -&gt; Parsec (() -&gt; a) -&gt; Parsec a
forall a b. Parsec (Either a b) -&gt; Parsec (a -&gt; b) -&gt; Parsec b
forall (f :: * -&gt; *) a b.
Selective f =&gt;
f (Either a b) -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-identifier hs-var">select</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Either () a -&gt; (a -&gt; Either () a) -&gt; Maybe a -&gt; Either () a
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; Either () a
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; Either () a
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; Either () a)
-&gt; Parsec (Maybe a) -&gt; Parsec (Either () a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679072160"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072159"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __@n@__ or more times, collecting the results into a list.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will return all of the results, @x1@ through @xm@ (with @m &gt;= n@), in a list: @[x1, .., xm]@.
If @p@ was not successful at least @n@ times, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = manyN 2 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success [&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

==== Notes
* @many p == many 0 p@ and @some p == many 1 p@.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-223"></span><span id="local-6989586621679072022"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-type">manyN</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ the minimum number of @p@s required, @n@.</span></span><span>
</span><span id="line-224"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072022"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to execute multiple times.</span></span><span>
</span><span id="line-225"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072022"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning the list of all the successful results.</span></span><span>
</span><span id="line-226"></span><span id="manyN"><span class="annot"><span class="annottext">manyN :: forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var hs-var">manyN</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679072172"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072172"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072172"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-227"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span id="local-6989586621679072173"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072173"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">some</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072173"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-228"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span id="local-6989586621679072174"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072174"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679072175"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072175"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072175"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec a -&gt; Parsec [a]
forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072174"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072175"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed.

==== __Examples__
&gt;&gt;&gt; let p = skipMany (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-250"></span><span id="local-6989586621679072176"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-type">skipMany</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072176"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to execute multiple times.</span></span><span>
</span><span id="line-251"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-252"></span><span id="skipMany"><span class="annot"><span class="annottext">skipMany :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var hs-var">skipMany</span></a></span></span><span> </span><span id="local-6989586621679072177"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072177"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679072180"><span class="annot"><span class="annottext">go :: Parsec ()
</span><a href="#local-6989586621679072180"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072177"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679072180"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679072180"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The parser @p@ must succeed at least once.

==== __Examples__
&gt;&gt;&gt; let p = skipSome (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-274"></span><span id="local-6989586621679072181"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-type">skipSome</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072181"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-275"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-276"></span><span id="skipSome"><span class="annot"><span class="annottext">skipSome :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-var hs-var">skipSome</span></a></span></span><span> </span><span id="local-6989586621679072183"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072183"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072183"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var">skipMany</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072183"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __@n@__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The parser @p@ must succeed at least @n@ times.

==== __Examples__
&gt;&gt;&gt; let p = skipManyN 2 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-298"></span><span id="local-6989586621679072031"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-type">skipManyN</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @n@, the minimum number of times to execute.</span></span><span>
</span><span id="line-299"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072031"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-300"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-301"></span><span id="skipManyN"><span class="annot"><span class="annottext">skipManyN :: forall a. Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var hs-var">skipManyN</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679072191"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072191"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var">skipMany</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072191"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-302"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span id="local-6989586621679072192"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072192"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-var">skipSome</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072192"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-303"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span id="local-6989586621679072193"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072193"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679072194"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072194"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072194"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec a -&gt; Parsec ()
forall a. Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072193"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072194"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, returning how many times it succeeded.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The number of times @p@ succeeded is returned as the result.

==== __Examples__
&gt;&gt;&gt; let p = count (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success 0
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success 1
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-325"></span><span id="local-6989586621679072033"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier hs-type">count</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072033"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-326"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ successfully parses</span></span><span>
</span><span id="line-327"></span><span id="count"><span class="annot"><span class="annottext">count :: forall a. Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier hs-var hs-var">count</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int -&gt; a -&gt; Int) -&gt; Int -&gt; Parsec a -&gt; Parsec Int
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#manyl"><span class="hs-identifier hs-var">manyl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; Int -&gt; Int) -&gt; Int -&gt; a -&gt; Int
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Int -&gt; Int) -&gt; a -&gt; Int -&gt; Int
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-328"></span><span>
</span><span id="line-329"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, returning how many times it succeeded.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The parser @p@ must succeed at least once. The number of times @p@ succeeded is returned as the result.

==== __Examples__
&gt;&gt;&gt; let p = count1 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success 1
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-349"></span><span id="local-6989586621679072200"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier hs-type">count1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072200"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-350"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ successfully parses</span></span><span>
</span><span id="line-351"></span><span id="count1"><span class="annot"><span class="annottext">count1 :: forall a. Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier hs-var hs-var">count1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int -&gt; a -&gt; Int) -&gt; Int -&gt; Parsec a -&gt; Parsec Int
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#somel"><span class="hs-identifier hs-var">somel</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; Int -&gt; Int) -&gt; Int -&gt; a -&gt; Int
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Int -&gt; Int) -&gt; a -&gt; Int -&gt; Int
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-352"></span><span>
</span><span id="line-353"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated by @sep@.

Behaves just like @sepBy1@, except does not require an initial @p@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepBy int (string &quot;, &quot;)
&gt;&gt;&gt; parse @String args &quot;7, 3, 2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Success []
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1, 2, &quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-372"></span><span id="local-6989586621679072041"><span id="local-6989586621679072042"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier hs-type">sepBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072041"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-373"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072042"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-374"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072041"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-375"></span><span id="sepBy"><span class="annot"><span class="annottext">sepBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier hs-var hs-var">sepBy</span></a></span></span><span> </span><span id="local-6989586621679072206"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072206"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679072207"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072207"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-var">sepBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072206"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072207"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-376"></span><span>
</span><span id="line-377"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated by @sep@.

First parses a @p@. Then parses @sep@ followed by @p@ until there are no more @sep@s.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails. Requires at least
one @p@ to have been parsed.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepBy1 int (string &quot;, &quot;)
&gt;&gt;&gt; parse @String args &quot;7, 3, 2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1, 2, &quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-399"></span><span id="local-6989586621679072208"><span id="local-6989586621679072209"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-type">sepBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072208"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-400"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072209"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-401"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072208"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-402"></span><span id="sepBy1"><span class="annot"><span class="annottext">sepBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-var hs-var">sepBy1</span></a></span></span><span> </span><span id="local-6989586621679072212"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072212"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679072213"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072213"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072212"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072213"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep -&gt; Parsec a -&gt; Parsec a
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072212"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-403"></span><span>
</span><span id="line-404"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated and optionally ended by @sep@.

Behaves just like @sepEndBy1@, except does not require an initial @p@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepEndBy int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Success Nil
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-423"></span><span id="local-6989586621679072214"><span id="local-6989586621679072215"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier hs-type">sepEndBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072214"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-424"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072215"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-425"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072214"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-426"></span><span id="sepEndBy"><span class="annot"><span class="annottext">sepEndBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier hs-var hs-var">sepEndBy</span></a></span></span><span> </span><span id="local-6989586621679072218"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072218"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679072219"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072219"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-var">sepEndBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072218"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072219"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-427"></span><span>
</span><span id="line-428"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated and optionally ended by @sep@.

First parses a @p@. Then parses @sep@ followed by @p@ until there are no more: if a final @sep@ exists, this is parsed.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails. Requires at least
one @p@ to have been parsed.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepEndBy1 int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-450"></span><span id="local-6989586621679072220"><span id="local-6989586621679072221"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-type">sepEndBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072220"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-451"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072221"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-452"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072220"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-453"></span><span id="sepEndBy1"><span class="annot"><span class="annottext">sepEndBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-var hs-var">sepEndBy1</span></a></span></span><span> </span><span id="local-6989586621679072222"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072222"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679072223"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072223"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679072229"><span class="annot"><span class="annottext">seb1 :: Parsec [a]
</span><a href="#local-6989586621679072229"><span class="hs-identifier hs-var hs-var">seb1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072222"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072223"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep -&gt; Parsec [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679072229"><span class="hs-identifier hs-var">seb1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679072229"><span class="hs-identifier hs-var">seb1</span></a></span><span>
</span><span id="line-454"></span><span>
</span><span id="line-455"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated and ended by @sep@.

Behaves just like @endBy1@, except does not require an initial @p@ and @sep@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = endBy int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;&quot;
Success Nil
&gt;&gt;&gt; parse @String args &quot;1;\n&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-474"></span><span id="local-6989586621679072230"><span id="local-6989586621679072231"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier hs-type">endBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072230"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-475"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072231"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-476"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072230"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-477"></span><span id="endBy"><span class="annot"><span class="annottext">endBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier hs-var hs-var">endBy</span></a></span></span><span> </span><span id="local-6989586621679072234"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072234"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679072235"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072235"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-var">endBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072234"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072235"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-478"></span><span>
</span><span id="line-479"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated and ended by @sep@.

Parses @p@ followed by @sep@ one or more times.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = endBy1 int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1;\n&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-500"></span><span id="local-6989586621679072236"><span id="local-6989586621679072237"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-type">endBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072236"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-501"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072237"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-502"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072236"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-503"></span><span id="endBy1"><span class="annot"><span class="annottext">endBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-var hs-var">endBy1</span></a></span></span><span> </span><span id="local-6989586621679072240"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072240"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679072241"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072241"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">some</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072240"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec a
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec a
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679072241"><span class="hs-identifier hs-var">sep</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-504"></span><span>
</span><span id="line-505"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, until the @end@ parser succeeds, collecting the results into a list.

First tries to parse @end@, if it fails __without consuming input__, then parses @p@, which must succeed. This repeats until @end@ succeeds.
When @end@ does succeed, this combinator will return all of the results generated by @p@, @x1@ through @xn@ (with @n &gt;= 0@), in a
list: @[x1, .., xn]@. If @end@ could be parsed immediately, the empty list is returned.

==== __Examples__
This can be useful for scanning comments:

&gt;&gt;&gt; let comment = string &quot;--&quot; *&gt; manyUntil item endOfLine
&gt;&gt;&gt; parse @String p &quot;--hello world&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--hello world\n&quot;
Success ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
&gt;&gt;&gt; parse @String p &quot;--\n&quot;
Success Nil

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-525"></span><span id="local-6989586621679072243"><span id="local-6989586621679072244"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-type">manyTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072243"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-526"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072244"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @end@, the parser that stops the parsing of @p@.</span></span><span>
</span><span id="line-527"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072243"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until @end@ succeeds, returning the list of all the successful results.</span></span><span>
</span><span id="line-528"></span><span id="manyTill"><span class="annot"><span class="annottext">manyTill :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-var hs-var">manyTill</span></a></span></span><span> </span><span id="local-6989586621679072245"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072245"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679072246"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679072246"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679072248"><span class="annot"><span class="annottext">go :: Parsec [a]
</span><a href="#local-6989586621679072248"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679072246"><span class="hs-identifier hs-var">end</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end -&gt; [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; b -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072245"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679072248"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679072248"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-529"></span><span>
</span><span id="line-530"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, until the @end@ parser succeeds, collecting the results into a list.

First ensures that trying to parse @end@ fails, then tries to parse @p@. If it succeed then it will repeatedly: try to parse @end@, if it fails
__without consuming input__, then parses @p@, which must succeed. When @end@ does succeed, this combinator will return all of the results
generated by @p@, @x1@ through @xn@ (with @n &gt;= 1@), in a list: @[x1, .., xn]@. The parser @p@ must succeed at least once
before @end@ succeeds.

==== __Examples__
This can be useful for scanning comments:

&gt;&gt;&gt; let comment = string &quot;--&quot; *&gt; someUntil item endOfLine
&gt;&gt;&gt; parse @String p &quot;--hello world&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--hello world\n&quot;
Success ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
&gt;&gt;&gt; parse @String p &quot;--\n&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--a\n&quot;
Success ['a']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-553"></span><span id="local-6989586621679072249"><span id="local-6989586621679072250"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier hs-type">someTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072249"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-554"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072250"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @end@, the parser that stops the parsing of @p@.</span></span><span>
</span><span id="line-555"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072249"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until @end@ succeeds, returning the list of all the successful results.</span></span><span>
</span><span id="line-556"></span><span id="someTill"><span class="annot"><span class="annottext">someTill :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier hs-var hs-var">someTill</span></a></span></span><span> </span><span id="local-6989586621679072252"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072252"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679072253"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679072253"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec end -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier hs-var">notFollowedBy</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679072253"><span class="hs-identifier hs-var">end</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072252"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec end -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-var">manyTill</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072252"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679072253"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-557"></span><span>
</span><span id="line-558"></span><span class="hs-comment">-- this is ifP</span><span>
</span><span id="line-559"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses one of @thenP@ or @elseP@ depending on the result of parsing @condP@.

This is a lifted @if@-statement. First, parse @condP@: if it is successful and returns
@true@, then parse @thenP@; else, if it returned @false@, parse @elseP@; or, if @condP@ failed
then fail. If either of @thenP@ or @elseP@ fail, then this combinator also fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state.

==== __Examples__
&gt;&gt;&gt; ifP (pure true) p _ == p
&gt;&gt;&gt; ifP (pure false) _ p == p

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-575"></span><span id="local-6989586621679072061"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-type">ifS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @condP@, the parser that yields the condition value.</span></span><span>
</span><span id="line-576"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072061"><span class="hs-identifier hs-type">a</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @thenP@, the parser to execute if the condition is @true@.</span></span><span>
</span><span id="line-577"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072061"><span class="hs-identifier hs-type">a</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @elseP@, the parser to execute if the condition is @false.</span></span><span>
</span><span id="line-578"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072061"><span class="hs-identifier hs-type">a</span></a></span></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ a parser that conditionally parses @thenP@ or @elseP@ after @condP@.</span></span><span>
</span><span id="line-579"></span><span id="ifS"><span class="annot"><span class="annottext">ifS :: forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var hs-var">ifS</span></a></span></span><span> </span><span id="local-6989586621679072258"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679072258"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span id="local-6989586621679072259"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072259"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679072260"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072260"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Either () ())
-&gt; Parsec (() -&gt; a) -&gt; Parsec (() -&gt; a) -&gt; Parsec a
forall (f :: * -&gt; *) a b c.
Selective f =&gt;
f (Either a b) -&gt; f (a -&gt; c) -&gt; f (b -&gt; c) -&gt; f c
</span><span class="hs-identifier hs-var">branch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Either () ()
</span><a href="#local-6989586621679072261"><span class="hs-identifier hs-var">bool</span></a></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Either () ()) -&gt; Parsec Bool -&gt; Parsec (Either () ())
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679072258"><span class="hs-identifier hs-var">cond</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072260"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072259"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-580"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679072261"><span class="annot"><span class="annottext">bool :: Bool -&gt; Either () ()
</span><a href="#local-6989586621679072261"><span class="hs-identifier hs-var hs-var">bool</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Either () ()
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-581"></span><span>        </span><span class="annot"><a href="#local-6989586621679072261"><span class="hs-identifier hs-var">bool</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Either () ()
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-582"></span><span>
</span><span id="line-583"></span><span class="hs-comment">-- this is when</span><span>
</span><span id="line-584"></span><span class="annot"><span class="hs-comment">{-|
This combinator conditionally parses @thenP@ depending on the result of parsing @condP@.

This is a lifted @if@-statement. First, parse @condP@: if it is successful and returns
@true@, then parse @thenP@; else, if it returned @false@ do nothing; or, if @condP@ failed
then fail. If @thenP@ fails, then this combinator also fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state.

==== __Examples__
&gt;&gt;&gt; when (pure true) p == p
&gt;&gt;&gt; when (pure false) _ == unit

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-600"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-type">whenS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @condP@, the parser that yields the condition value.</span></span><span>
</span><span id="line-601"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @thenP@, the parser to execute if the condition is @true@.</span></span><span>
</span><span id="line-602"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that conditionally parses @thenP@ after @condP@.</span></span><span>
</span><span id="line-603"></span><span id="whenS"><span class="annot"><span class="annottext">whenS :: Parsec Bool -&gt; Parsec () -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-var hs-var">whenS</span></a></span></span><span> </span><span id="local-6989586621679072262"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679072262"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span id="local-6989586621679072263"><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679072263"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var">ifS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679072262"><span class="hs-identifier hs-var">cond</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679072263"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-604"></span><span>
</span><span id="line-605"></span><span class="hs-comment">-- this is guard</span><span>
</span><span id="line-606"></span><span class="annot"><span class="hs-comment">{-|
This combinator verfies that the given parser returns @true@, or else fails.

First, parse @p@; if it succeeds then, so long at returns @true@, this @guard p@ succeeds. Otherwise,
if @p@ either fails, or returns @false@, @guard p@ will fail.

==== __Examples__
&gt;&gt;&gt; guard (pure true) == unit
&gt;&gt;&gt; guard (pure false) == empty
&gt;&gt;&gt; when (not &lt;$&gt; p) empty == guard p

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-619"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier hs-type">guardS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser that yields the condition value.</span></span><span>
</span><span id="line-620"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-621"></span><span id="guardS"><span class="annot"><span class="annottext">guardS :: Parsec Bool -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier hs-var hs-var">guardS</span></a></span></span><span> </span><span id="local-6989586621679072264"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679072264"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var">ifS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679072264"><span class="hs-identifier hs-var">cond</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
forall a. Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><span class="hs-identifier hs-var">empty</span></span><span>
</span><span id="line-622"></span><span>
</span><span id="line-623"></span><span class="hs-comment">-- this is whileP</span><span>
</span><span id="line-624"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses @p@ so long as it returns @true@.

This is a lifted @while@-loop. First, parse @p@: if it is successful and
returns @true@, then repeat; else if it returned @false@ stop; or, if it
failed then this combinator fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state. In particular, this can be used to define the @forP@ combinator.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-636"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier hs-type">whileS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeatedly parse.</span></span><span>
</span><span id="line-637"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that continues to parse @p@ until it returns @false@.</span></span><span>
</span><span id="line-638"></span><span id="whileS"><span class="annot"><span class="annottext">whileS :: Parsec Bool -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier hs-var hs-var">whileS</span></a></span></span><span> </span><span id="local-6989586621679072265"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679072265"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679072266"><span class="annot"><span class="annottext">go :: Parsec ()
</span><a href="#local-6989586621679072266"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-var">whenS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679072265"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679072266"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679072266"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-639"></span><span>
</span><span id="line-640"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses exactly @n@ occurrences of @p@, returning these @n@ results in a list.

Parses @p@ repeatedly up to @n@ times. If @p@ fails before @n@ is reached, then this combinator
fails. It is not required for @p@ to fail after the @n@th parse. The results produced by
@p@, @x1@ through @xn@, are returned as @[x1, .., xn]@.

==== __Examples__
&gt;&gt;&gt; let p = exactly 3 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ['a', 'b', 'c']
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ['a', 'b', 'c']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-658"></span><span id="local-6989586621679072267"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier hs-type">exactly</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @n@, the number of times to repeat @p@.</span></span><span>
</span><span id="line-659"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072267"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-660"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072267"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ exactly @n@ times, returning a list of the results.</span></span><span>
</span><span id="line-661"></span><span id="exactly"><span class="annot"><span class="annottext">exactly :: forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier hs-var hs-var">exactly</span></a></span></span><span> </span><span id="local-6989586621679072268"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072268"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-var">range</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072268"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072268"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-662"></span><span>
</span><span id="line-663"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@, returning these @n@ results in a list.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@^th^ parse.
The results produced by @p@, @xmin@ through @xmax@, are returned as @[xmin, .., xmax]@.

==== __Examples__
&gt;&gt;&gt; let p = range 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ['a', 'b', 'c']
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ['a', 'b', 'c', 'd']
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success ['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success ['a', 'b', 'c', 'd', 'e']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-685"></span><span id="local-6989586621679072068"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-type">range</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-686"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-687"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072068"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-688"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679072068"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the results of the successful parses of @p@.</span></span><span>
</span><span id="line-689"></span><span id="range"><span class="annot"><span class="annottext">range :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-var hs-var">range</span></a></span></span><span> </span><span id="local-6989586621679072278"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072278"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679072279"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072279"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679072280"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072280"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-690"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072278"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072279"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072278"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-691"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec [a]
forall {t} {t}. (Eq t, Eq t, Num t, Num t) =&gt; t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679072283"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072278"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072279"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-692"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-693"></span><span>    </span><span id="local-6989586621679072283"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679072283"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-694"></span><span>    </span><span class="annot"><a href="#local-6989586621679072283"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679072304"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072304"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072280"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679072283"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072304"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-695"></span><span>    </span><span class="annot"><a href="#local-6989586621679072283"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679072305"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072305"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679072306"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072306"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072280"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679072283"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072305"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072306"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-696"></span><span>
</span><span id="line-697"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@ but ignoring the results.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@th parse.
The results are discarded and @()@ is returned instead.

==== __Examples__
&gt;&gt;&gt; let p = range_ 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success ()

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-719"></span><span id="local-6989586621679072073"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier hs-type">range_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-720"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-721"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072073"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-722"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-723"></span><span id="range_"><span class="annot"><span class="annottext">range_ :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier hs-var hs-var">range_</span></a></span></span><span> </span><span id="local-6989586621679072314"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072314"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679072315"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072315"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679072316"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072316"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-724"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072314"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072315"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072314"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-725"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec ()
forall {t} {t}. (Eq t, Eq t, Num t, Num t) =&gt; t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679072317"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072314"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072315"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-726"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-727"></span><span>    </span><span id="local-6989586621679072317"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679072317"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-728"></span><span>    </span><span class="annot"><a href="#local-6989586621679072317"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679072337"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072337"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-var">optional</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072316"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679072317"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072337"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-729"></span><span>    </span><span class="annot"><a href="#local-6989586621679072317"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679072338"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072338"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679072339"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072339"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072316"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679072317"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072338"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072339"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-730"></span><span>
</span><span id="line-731"></span><span class="hs-comment">-- this is count overloading</span><span>
</span><span id="line-732"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@, returning the number of successes.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@th parse.
The results are discarded and the number of successful parses of @p@, @n@, is returned instead, such that
@min &lt;= n &lt;= max@.

==== __Examples__
&gt;&gt;&gt; let p = count 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success 3
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success 5
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success 5

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-755"></span><span id="local-6989586621679072077"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier hs-type">countRange</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-756"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-757"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679072077"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-758"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ parsed successfully.</span></span><span>
</span><span id="line-759"></span><span id="countRange"><span class="annot"><span class="annottext">countRange :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier hs-var hs-var">countRange</span></a></span></span><span> </span><span id="local-6989586621679072350"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072350"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679072351"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072351"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679072352"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072352"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-760"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072350"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072351"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072350"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec Int
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-761"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec Int
forall {t} {t} {a}.
(Eq t, Eq t, Num t, Num t, Num a) =&gt;
t -&gt; t -&gt; Parsec a
</span><a href="#local-6989586621679072353"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072350"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679072351"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-762"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-763"></span><span>    </span><span id="local-6989586621679072353"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec a
</span><a href="#local-6989586621679072353"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Parsec a
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">0</span></span><span>
</span><span id="line-764"></span><span>    </span><span class="annot"><a href="#local-6989586621679072353"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679072383"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072383"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; a) -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
forall a b c. (a -&gt; b -&gt; c) -&gt; Parsec a -&gt; Parsec b -&gt; Parsec c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; a -&gt; a -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072352"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec a
</span><a href="#local-6989586621679072353"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072383"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec a -&gt; Parsec a
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Parsec a
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">0</span></span><span>
</span><span id="line-765"></span><span>    </span><span class="annot"><a href="#local-6989586621679072353"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679072384"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072384"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679072385"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072385"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; a) -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
forall a b c. (a -&gt; b -&gt; c) -&gt; Parsec a -&gt; Parsec b -&gt; Parsec c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; a -&gt; a -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679072352"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec a
</span><a href="#local-6989586621679072353"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072384"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679072385"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-766"></span></pre></body></html>