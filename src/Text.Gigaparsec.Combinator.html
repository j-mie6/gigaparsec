<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span>
</span><span id="line-2"></span><span class="annot"><span class="hs-comment">{-|
Module      : Text.Gigaparsec.Combinator
Description : This module contains a huge number of pre-made combinators that are
              very useful for a variety of purposes.
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : stable

This module contains a huge number of pre-made combinators that are very useful for a variety of purposes.

In particular, it contains combinators for: performing a parser iteratively, collecting all the results;
querying whether or not any input is left; optionally performing parsers; parsing delimited constructions;
handling multiple possible alternatives or parsers to sequence; handling more complex conditional execution;
and more.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-19"></span><span class="hs-keyword">module</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html"><span class="hs-identifier">Text.Gigaparsec.Combinator</span></a></span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-20"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Iterative Combinators</span></span><span>
</span><span id="line-21"></span><span>  </span><span class="hs-comment">-- | These combinators all execute a given parser an unbounded number of times, until either it fails, or another</span><span>
</span><span id="line-22"></span><span>  </span><span class="hs-comment">-- parser succeeds, depending on the combinator. Depending on the combinator, all of the results produced by the</span><span>
</span><span id="line-23"></span><span>  </span><span class="hs-comment">-- repeated execution of the parser may be returned in a @[]@. These are almost essential for any practical parsing</span><span>
</span><span id="line-24"></span><span>  </span><span class="hs-comment">-- task.</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier">manyN</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier">skipMany</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier">skipSome</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier">skipManyN</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier">count</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier">count1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier">manyTill</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier">someTill</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyTill"><span class="hs-identifier">skipManyTill</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSomeTill"><span class="hs-identifier">skipSomeTill</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Optional Parsing Combinators</span></span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the /possible/ parsing of some parser. If the parser succeeds, that is ok</span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-comment">-- so long as it __did not consume input__. Be aware that the result of the success may be replaced with</span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-comment">-- these combinators, with the exception of &quot;option&quot;, which still preserves the result.</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier">option</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier">optional</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier">optionalAs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier">decide</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier">fromMaybeS</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>
</span><span id="line-33"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Separated Values Combinators</span></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-comment">-- | These combinators are concerned with delimited parsing, where one parser is repeated but delimited by another one.</span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-comment">-- In each of these cases @p@ is the parser of interest and @sep@ is the delimeter. These combinators mainly differ</span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-comment">-- in either the number of @p@s they require, or exactly where the delimeters are allowed (only between, always</span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-comment">-- trailing, or either). In all cases, they return the list of results generated by the repeated parses of @p@.</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier">sepBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier">sepBy1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier">sepEndBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier">sepEndBy1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier">endBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier">endBy1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Multiple Branching/Sequencing Combinators</span></span><span>
</span><span id="line-41"></span><span>  </span><span class="annot"><span class="hs-comment">-- | These combinators allow for testing or sequencing a large number of parsers in one go.</span></span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier">choice</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">sequence</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">traverse</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier">skip</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Range Combinators</span></span><span>
</span><span id="line-45"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the parsing of a specific parser either a specific number of times, or between a certain</span><span>
</span><span id="line-46"></span><span>  </span><span class="hs-comment">-- amount of times.</span><span>
</span><span id="line-47"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier">exactly</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier">range</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier">range_</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier">countRange</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Selective Combinators</span></span><span>
</span><span id="line-50"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the conditional extraction of a result, or the execution of a parser</span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-comment">-- based on another. They are derived from 'Text.Gigaparsec.branch'.</span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier">ifS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier">whenS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier">guardS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier">whileS</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html"><span class="hs-identifier">Text.Gigaparsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier">Parsec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator">($&gt;)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator">(&lt;:&gt;)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword">unit</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#manyl"><span class="hs-identifier">manyl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#somel"><span class="hs-identifier">somel</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier">notFollowedBy</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">liftA2</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">many</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">some</span></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Selective</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">select</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">branch</span></span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Functor</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">void</span></span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">asum</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">sequenceA_</span></span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>
</span><span id="line-61"></span><span class="annot"><span class="hs-comment">{-|
This combinator tries to parse each of the parsers @ps@ in order, until one of them succeeds.

Finds the first parser in @ps@ which succeeds, returning its result. If Nothing of the parsers
succeed, then this combinator fails. If a parser fails having consumed input, this combinator
fails __immediately__.

==== __Examples__
&gt;&gt;&gt; let p = choice [string &quot;abc&quot;, string &quot;ab&quot;, string &quot;bc&quot;, string &quot;d&quot;]
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success &quot;abc&quot;
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;bc&quot;
Success &quot;bc&quot;
&gt;&gt;&gt; parse @String p &quot;x&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-81"></span><span id="local-6989586621679247854"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier hs-type">choice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247854"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parsers, @ps@ to try, in order.</span></span><span>
</span><span id="line-82"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247854"><span class="hs-identifier hs-type">a</span></a></span></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to parse one of @ps@.</span></span><span>
</span><span id="line-83"></span><span id="choice"><span class="annot"><span class="annottext">choice :: forall a. [Parsec a] -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier hs-var hs-var">choice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parsec a] -&gt; Parsec a
forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><span class="hs-identifier hs-var">asum</span></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse each of @ps@ in order, discarding the results.

Given the parsers @ps@, consisting of @p1@ through @pn@, parses
each in order. If they all succeed, this combinator succeeds. If any of
the parsers fail, then the whole combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = skip [char'a', item, char 'c']
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-101"></span><span id="local-6989586621679247859"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier hs-type">skip</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247859"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ parsers @ps@ to be sequenced.</span></span><span>
</span><span id="line-102"></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses each of @ps@, returning @()@.</span></span><span>
</span><span id="line-103"></span><span id="skip"><span class="annot"><span class="annottext">skip :: forall a. [Parsec a] -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier hs-var hs-var">skip</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parsec a] -&gt; Parsec ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Applicative f) =&gt;
t (f a) -&gt; f ()
</span><span class="hs-identifier hs-var">sequenceA_</span></span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span class="annot"><span class="hs-comment">{-|
This combinator tries to parse @p@, wrapping its result in a @Just@ if it succeeds, or returns @Nothing@ if it fails.

Tries to parse @p@. If @p@ succeeded, producing @x@, then @Just x@ is returned. Otherwise, if @p@ failed
__without consuming input__, then @Nothing@ is returned instead.

==== __Examples__
&gt;&gt;&gt; let p = option (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success Nothing
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success (Just &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-122"></span><span id="local-6989586621679247864"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier hs-type">option</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247864"><span class="hs-identifier hs-type">a</span></a></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse</span></span><span>
</span><span id="line-123"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679247864"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-124"></span><span id="option"><span class="annot"><span class="annottext">option :: forall a. Parsec a -&gt; Parsec (Maybe a)
</span><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier hs-var hs-var">option</span></a></span></span><span> </span><span id="local-6989586621679248034"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248034"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; Parsec a -&gt; Parsec (Maybe a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248034"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a) -&gt; Parsec (Maybe a) -&gt; Parsec (Maybe a)
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; Parsec (Maybe a)
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse @p@ if possible, otherwise will do nothing.

Tries to parse @p@. If @p@ succeeds, or fails __without consuming input__ then this combinator is successful. Otherwise, if @p@ failed
having consumed input, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = optional (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-143"></span><span id="local-6989586621679247874"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-type">optional</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247874"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse.</span></span><span>
</span><span id="line-144"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-145"></span><span id="optional"><span class="annot"><span class="annottext">optional :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-var hs-var">optional</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Parsec a -&gt; Parsec ()
forall b a. b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-var">optionalAs</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-146"></span><span>
</span><span id="line-147"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse @p@ if possible, otherwise will do nothing.

Tries to parse @p@. If @p@ succeeds, or fails __without consuming input__ then this combinator is successful and returns @x@. Otherwise,
if @p@ failed having consumed input, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = optionalAs 7 (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success 7
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success 7
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-164"></span><span id="local-6989586621679247876"><span id="local-6989586621679247877"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-type">optionalAs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679247876"><span class="hs-identifier hs-type">b</span></a></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ the value @x@ to return regardless of how @p@ performs.</span></span><span>
</span><span id="line-165"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247877"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse.</span></span><span>
</span><span id="line-166"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247876"><span class="hs-identifier hs-type">b</span></a></span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to parse @p@, returning @x@ regardless of success or failure.</span></span><span>
</span><span id="line-167"></span><span id="optionalAs"><span class="annot"><span class="annottext">optionalAs :: forall b a. b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-var hs-var">optionalAs</span></a></span></span><span> </span><span id="local-6989586621679248038"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679248038"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679248039"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248039"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248039"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; b -&gt; Parsec b
forall a b. Parsec a -&gt; b -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679248038"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec b -&gt; Parsec b -&gt; Parsec b
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; Parsec b
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679248038"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-168"></span><span>
</span><span id="line-169"></span><span class="hs-comment">-- TODO: collect</span><span>
</span><span id="line-170"></span><span class="annot"><span class="hs-comment">{-|
This combinator can eliminate a @Maybe@ from the result of the parser @p@.

First parse @p@, if it succeeds returning @Just x@, then return @x@. However,
if @p@ fails, or returned @Nothing@, then this combinator fails.

==== __Examples__
@decide (option p) = p@
-}</span></span><span>
</span><span id="line-179"></span><span id="local-6989586621679247882"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier hs-type">decide</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679247882"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to parse and extract the result from.</span></span><span>
</span><span id="line-180"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247882"><span class="hs-identifier hs-type">a</span></a></span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to extract the result from @p@.</span></span><span>
</span><span id="line-181"></span><span id="decide"><span class="annot"><span class="annottext">decide :: forall a. Parsec (Maybe a) -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier hs-var hs-var">decide</span></a></span></span><span> </span><span id="local-6989586621679248044"><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679248044"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679248044"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a) -&gt; (Maybe a -&gt; Parsec a) -&gt; Parsec a
forall a b. Parsec a -&gt; (a -&gt; Parsec b) -&gt; Parsec b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; (a -&gt; Parsec a) -&gt; Maybe a -&gt; Parsec a
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
forall a. Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><span class="hs-identifier hs-var">empty</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Parsec a
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-182"></span><span>
</span><span id="line-183"></span><span class="hs-comment">-- this is decide overload</span><span>
</span><span id="line-184"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses @q@ depending only if @p@ returns a @Nothing@.

First parses @p@. If @p@ returned @Just x@, then @x@ is returned.
Otherwise, if @p@ returned @Nothing@ then @q@ is parsed, producing @y@,
and @y@ is returned. If @p@ or @q@ fails, the combinator fails.

==== __Examples__
fromMaybe q (option p) = p &lt;|&gt; q

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-196"></span><span id="local-6989586621679247890"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier hs-type">fromMaybeS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247890"><span class="hs-identifier hs-type">a</span></a></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser to execute when @p@ returns @Nothing@, to provide a value of type @a@.</span></span><span>
</span><span id="line-197"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679247890"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the first parser @p@, which returns an @Maybe@ to eliminate.</span></span><span>
</span><span id="line-198"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247890"><span class="hs-identifier hs-type">a</span></a></span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser that either just parses @p@ or both @p@ and @q@ in order to return an @a@.</span></span><span>
</span><span id="line-199"></span><span id="fromMaybeS"><span class="annot"><span class="annottext">fromMaybeS :: forall a. Parsec a -&gt; Parsec (Maybe a) -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier hs-var hs-var">fromMaybeS</span></a></span></span><span> </span><span id="local-6989586621679248050"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248050"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621679248051"><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679248051"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Either () a) -&gt; Parsec (() -&gt; a) -&gt; Parsec a
forall a b. Parsec (Either a b) -&gt; Parsec (a -&gt; b) -&gt; Parsec b
forall (f :: * -&gt; *) a b.
Selective f =&gt;
f (Either a b) -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-identifier hs-var">select</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Either () a -&gt; (a -&gt; Either () a) -&gt; Maybe a -&gt; Either () a
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; Either () a
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; Either () a
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; Either () a)
-&gt; Parsec (Maybe a) -&gt; Parsec (Either () a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679248051"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248050"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __@n@__ or more times, collecting the results into a list.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will return all of the results, @x1@ through @xm@ (with @m &gt;= n@), in a list: @[x1, .., xm]@.
If @p@ was not successful at least @n@ times, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = manyN 2 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success [&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

==== Notes
* @many p == many 0 p@ and @some p == many 1 p@.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-225"></span><span id="local-6989586621679247900"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-type">manyN</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ the minimum number of @p@s required, @n@.</span></span><span>
</span><span id="line-226"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247900"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to execute multiple times.</span></span><span>
</span><span id="line-227"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679247900"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning the list of all the successful results.</span></span><span>
</span><span id="line-228"></span><span id="manyN"><span class="annot"><span class="annottext">manyN :: forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var hs-var">manyN</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679248063"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248063"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248063"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-229"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span id="local-6989586621679248064"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248064"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">some</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248064"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-230"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span id="local-6989586621679248065"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248065"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679248066"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248066"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248066"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec a -&gt; Parsec [a]
forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248065"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248066"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-231"></span><span>
</span><span id="line-232"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed.

==== __Examples__
&gt;&gt;&gt; let p = skipMany (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-252"></span><span id="local-6989586621679248067"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-type">skipMany</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248067"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to execute multiple times.</span></span><span>
</span><span id="line-253"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-254"></span><span id="skipMany"><span class="annot"><span class="annottext">skipMany :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var hs-var">skipMany</span></a></span></span><span> </span><span id="local-6989586621679248068"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248068"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679248071"><span class="annot"><span class="annottext">go :: Parsec ()
</span><a href="#local-6989586621679248071"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248068"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679248071"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679248071"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-255"></span><span>
</span><span id="line-256"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The parser @p@ must succeed at least once.

==== __Examples__
&gt;&gt;&gt; let p = skipSome (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-276"></span><span id="local-6989586621679248072"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-type">skipSome</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248072"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-277"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-278"></span><span id="skipSome"><span class="annot"><span class="annottext">skipSome :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-var hs-var">skipSome</span></a></span></span><span> </span><span id="local-6989586621679248074"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248074"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248074"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var">skipMany</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248074"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-279"></span><span>
</span><span id="line-280"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __@n@__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The parser @p@ must succeed at least @n@ times.

==== __Examples__
&gt;&gt;&gt; let p = skipManyN 2 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-300"></span><span id="local-6989586621679247910"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-type">skipManyN</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @n@, the minimum number of times to execute.</span></span><span>
</span><span id="line-301"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247910"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-302"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-303"></span><span id="skipManyN"><span class="annot"><span class="annottext">skipManyN :: forall a. Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var hs-var">skipManyN</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679248082"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248082"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var">skipMany</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248082"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-304"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span id="local-6989586621679248083"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248083"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-var">skipSome</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248083"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-305"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span id="local-6989586621679248084"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248084"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679248085"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248085"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248085"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec a -&gt; Parsec ()
forall a. Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248084"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248085"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-306"></span><span>
</span><span id="line-307"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, returning how many times it succeeded.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The number of times @p@ succeeded is returned as the result.

==== __Examples__
&gt;&gt;&gt; let p = count (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success 0
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success 1
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-327"></span><span id="local-6989586621679247912"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier hs-type">count</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247912"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-328"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ successfully parses</span></span><span>
</span><span id="line-329"></span><span id="count"><span class="annot"><span class="annottext">count :: forall a. Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier hs-var hs-var">count</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int -&gt; a -&gt; Int) -&gt; Int -&gt; Parsec a -&gt; Parsec Int
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#manyl"><span class="hs-identifier hs-var">manyl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; Int -&gt; Int) -&gt; Int -&gt; a -&gt; Int
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Int -&gt; Int) -&gt; a -&gt; Int -&gt; Int
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-330"></span><span>
</span><span id="line-331"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, returning how many times it succeeded.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The number of times @p@ succeeded is returned as the result.

The parser @p@ must succeed at least once.

==== __Examples__
&gt;&gt;&gt; let p = count1 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success 1
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-353"></span><span id="local-6989586621679248091"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier hs-type">count1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248091"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-354"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ successfully parses</span></span><span>
</span><span id="line-355"></span><span id="count1"><span class="annot"><span class="annottext">count1 :: forall a. Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier hs-var hs-var">count1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int -&gt; a -&gt; Int) -&gt; Int -&gt; Parsec a -&gt; Parsec Int
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#somel"><span class="hs-identifier hs-var">somel</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; Int -&gt; Int) -&gt; Int -&gt; a -&gt; Int
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Int -&gt; Int) -&gt; a -&gt; Int -&gt; Int
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-356"></span><span>
</span><span id="line-357"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated by @sep@.

Behaves just like 'sepBy1', except does not require an initial @p@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepBy int (string &quot;, &quot;)
&gt;&gt;&gt; parse @String args &quot;7, 3, 2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Success []
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1, 2, &quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-376"></span><span id="local-6989586621679247921"><span id="local-6989586621679247922"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier hs-type">sepBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247921"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-377"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247922"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-378"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679247921"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-379"></span><span id="sepBy"><span class="annot"><span class="annottext">sepBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier hs-var hs-var">sepBy</span></a></span></span><span> </span><span id="local-6989586621679248097"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248097"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248098"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248098"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-var">sepBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248097"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248098"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-380"></span><span>
</span><span id="line-381"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated by @sep@.

First parses a @p@. Then parses @sep@ followed by @p@ until there are no more @sep@s.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails. 

Requires at least one @p@ to have been parsed.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepBy1 int (string &quot;, &quot;)
&gt;&gt;&gt; parse @String args &quot;7, 3, 2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1, 2, &quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-404"></span><span id="local-6989586621679248099"><span id="local-6989586621679248100"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-type">sepBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248099"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-405"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248100"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-406"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679248099"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-407"></span><span id="sepBy1"><span class="annot"><span class="annottext">sepBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-var hs-var">sepBy1</span></a></span></span><span> </span><span id="local-6989586621679248103"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248103"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248104"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248104"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248103"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248104"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep -&gt; Parsec a -&gt; Parsec a
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248103"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-408"></span><span>
</span><span id="line-409"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated and optionally ended by @sep@.

Behaves just like 'sepEndBy1', except does not require an initial @p@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepEndBy int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Success Nil
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-428"></span><span id="local-6989586621679248105"><span id="local-6989586621679248106"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier hs-type">sepEndBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248105"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-429"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248106"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-430"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679248105"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-431"></span><span id="sepEndBy"><span class="annot"><span class="annottext">sepEndBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier hs-var hs-var">sepEndBy</span></a></span></span><span> </span><span id="local-6989586621679248109"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248109"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248110"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248110"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-var">sepEndBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248109"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248110"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-432"></span><span>
</span><span id="line-433"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated and optionally ended by @sep@.

First parses a @p@. Then parses @sep@ followed by @p@ until there are no more: if a final @sep@ exists, this is parsed.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails. 

Requires at least one @p@ to have been parsed.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepEndBy1 int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-456"></span><span id="local-6989586621679248111"><span id="local-6989586621679248112"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-type">sepEndBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248111"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-457"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248112"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-458"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679248111"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-459"></span><span id="sepEndBy1"><span class="annot"><span class="annottext">sepEndBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-var hs-var">sepEndBy1</span></a></span></span><span> </span><span id="local-6989586621679248113"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248113"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248114"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248114"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679248120"><span class="annot"><span class="annottext">seb1 :: Parsec [a]
</span><a href="#local-6989586621679248120"><span class="hs-identifier hs-var hs-var">seb1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248113"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248114"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep -&gt; Parsec [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679248120"><span class="hs-identifier hs-var">seb1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679248120"><span class="hs-identifier hs-var">seb1</span></a></span><span>
</span><span id="line-460"></span><span>
</span><span id="line-461"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated and ended by @sep@.

Behaves just like 'endBy1', except does not require an initial @p@ and @sep@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = endBy int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;&quot;
Success Nil
&gt;&gt;&gt; parse @String args &quot;1;\n&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-480"></span><span id="local-6989586621679248121"><span id="local-6989586621679248122"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier hs-type">endBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248121"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-481"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248122"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-482"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679248121"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-483"></span><span id="endBy"><span class="annot"><span class="annottext">endBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier hs-var hs-var">endBy</span></a></span></span><span> </span><span id="local-6989586621679248125"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248125"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248126"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248126"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-var">endBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248125"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248126"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-484"></span><span>
</span><span id="line-485"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated and ended by @sep@.

Parses @p@ followed by @sep@ one or more times.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails.

Requires at least one @p@ to have been parsed.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = endBy1 int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1;\n&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-508"></span><span id="local-6989586621679248127"><span id="local-6989586621679248128"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-type">endBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248127"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-509"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248128"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-510"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679248127"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-511"></span><span id="endBy1"><span class="annot"><span class="annottext">endBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-var hs-var">endBy1</span></a></span></span><span> </span><span id="local-6989586621679248131"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248131"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248132"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248132"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">some</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248131"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec a
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec a
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679248132"><span class="hs-identifier hs-var">sep</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-512"></span><span>
</span><span id="line-513"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, until the @end@ parser succeeds, collecting the results into a list.

First tries to parse @end@, if it fails __without consuming input__, then parses @p@, which must succeed. This repeats until @end@ succeeds.
When @end@ does succeed, this combinator will return all of the results generated by @p@, @x1@ through @xn@ (with @n &gt;= 0@), in a
list: @[x1, .., xn]@. If @end@ could be parsed immediately, the empty list is returned.

==== __Examples__
This can be useful for scanning comments:

&gt;&gt;&gt; let comment = string &quot;--&quot; *&gt; manyUntil item endOfLine
&gt;&gt;&gt; parse @String p &quot;--hello world&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--hello world\n&quot;
Success ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
&gt;&gt;&gt; parse @String p &quot;--\n&quot;
Success Nil

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-533"></span><span id="local-6989586621679248134"><span id="local-6989586621679248135"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-type">manyTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248134"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-534"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248135"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @end@, the parser that stops the parsing of @p@.</span></span><span>
</span><span id="line-535"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679248134"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until @end@ succeeds, returning the list of all the successful results.</span></span><span>
</span><span id="line-536"></span><span id="manyTill"><span class="annot"><span class="annottext">manyTill :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-var hs-var">manyTill</span></a></span></span><span> </span><span id="local-6989586621679248136"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248136"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248137"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248137"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679248139"><span class="annot"><span class="annottext">go :: Parsec [a]
</span><a href="#local-6989586621679248139"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248137"><span class="hs-identifier hs-var">end</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end -&gt; [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; b -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248136"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679248139"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679248139"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-537"></span><span>
</span><span id="line-538"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, until the @end@ parser succeeds, collecting the results into a list.

First ensures that trying to parse @end@ fails, then tries to parse @p@. If it succeeds then it will repeatedly: try to parse @end@, if it fails
__without consuming input__, then parses @p@, which must succeed. When @end@ does succeed, this combinator will return all of the results
generated by @p@, @x1@ through @xn@ (with @n &gt;= 1@), in a list: @[x1, .., xn]@. 

The parser @p@ must succeed at least once before @end@ succeeds.

==== __Examples__
This can be useful for scanning comments:

&gt;&gt;&gt; let comment = string &quot;--&quot; *&gt; someUntil item endOfLine
&gt;&gt;&gt; parse @String p &quot;--hello world&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--hello world\n&quot;
Success ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
&gt;&gt;&gt; parse @String p &quot;--\n&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--a\n&quot;
Success ['a']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-562"></span><span id="local-6989586621679248140"><span id="local-6989586621679248141"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier hs-type">someTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248140"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times, at least once.</span></span><span>
</span><span id="line-563"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248141"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @end@, the parser that stops the parsing of @p@.</span></span><span>
</span><span id="line-564"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679248140"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until @end@ succeeds, returning the list of all the successful results.</span></span><span>
</span><span id="line-565"></span><span id="someTill"><span class="annot"><span class="annottext">someTill :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier hs-var hs-var">someTill</span></a></span></span><span> </span><span id="local-6989586621679248143"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248143"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248144"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248144"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec end -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier hs-var">notFollowedBy</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248144"><span class="hs-identifier hs-var">end</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248143"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec end -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-var">manyTill</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248143"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248144"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-566"></span><span>
</span><span id="line-567"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, until the @end@ parser succeeds, discarding any results from @p@.

Behaves like 'manyTill', except the results of parsing @p@ are ignored.

First tries to parse @end@, if it fails __without consuming input__, then parses @p@, which must succeed. This repeats until @end@ succeeds.
When @end@ does succeed (even of the first try), this combinator will discard any results generated by @p@. 

-}</span></span><span>
</span><span id="line-576"></span><span id="local-6989586621679247941"><span id="local-6989586621679247942"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyTill"><span class="hs-identifier hs-type">skipManyTill</span></a></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247941"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times</span></span><span>
</span><span id="line-577"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247942"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @end@, the parser that stops the parsing of @p@</span></span><span>
</span><span id="line-578"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until @end@ succeeds, returning unit.</span></span><span>
</span><span id="line-579"></span><span id="skipManyTill"><span class="annot"><span class="annottext">skipManyTill :: forall a end. Parsec a -&gt; Parsec end -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipManyTill"><span class="hs-identifier hs-var hs-var">skipManyTill</span></a></span></span><span> </span><span id="local-6989586621679248146"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248146"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248147"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248147"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec end -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-var">manyTill</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248146"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248147"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-580"></span><span>
</span><span id="line-581"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, until the @end@ parser succeeds, discarding any results from @p@, and returns unit.

Behaves like 'someTill', except the results of parsing @p@ are ignored.

First ensures that trying to parse @end@ fails, then tries to parse @p@. If it succeeds then it will repeatedly: try to parse @end@, if it fails
__without consuming input__, then parses @p@, which must succeed. 
When @end@ does succeed, this combinator will discard any results generated by @p@, returning unit. 

The parser @p@ must succeed at least once before @end@ succeeds.
-}</span></span><span>
</span><span id="line-592"></span><span id="local-6989586621679248148"><span id="local-6989586621679248149"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSomeTill"><span class="hs-identifier hs-type">skipSomeTill</span></a></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248148"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times, at least once.</span></span><span>
</span><span id="line-593"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248149"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @end@, the parser that stops the parsing of @p@.</span></span><span>
</span><span id="line-594"></span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until @end@ succeeds, returning unit.</span></span><span>
</span><span id="line-595"></span><span id="skipSomeTill"><span class="annot"><span class="annottext">skipSomeTill :: forall a end. Parsec a -&gt; Parsec end -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipSomeTill"><span class="hs-identifier hs-var hs-var">skipSomeTill</span></a></span></span><span> </span><span id="local-6989586621679248151"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248151"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679248152"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248152"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec end -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier hs-var">someTill</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248151"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679248152"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-596"></span><span>
</span><span id="line-597"></span><span class="hs-comment">-- this is ifP</span><span>
</span><span id="line-598"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses one of @thenP@ or @elseP@ depending on the result of parsing @condP@.

This is a lifted @if@-statement. First, parse @condP@: if it is successful and returns
@True@, then parse @thenP@; else, if it returned @False@, parse @elseP@; or, if @condP@ failed
then fail. If either of @thenP@ or @elseP@ fail, then this combinator also fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state.

==== __Examples__
&gt;&gt;&gt; ifP (pure True) p _ == p
&gt;&gt;&gt; ifP (pure False) _ p == p

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-614"></span><span id="local-6989586621679247949"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-type">ifS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @condP@, the parser that yields the condition value.</span></span><span>
</span><span id="line-615"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247949"><span class="hs-identifier hs-type">a</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @thenP@, the parser to execute if the condition is @True@.</span></span><span>
</span><span id="line-616"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247949"><span class="hs-identifier hs-type">a</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @elseP@, the parser to execute if the condition is @False@.</span></span><span>
</span><span id="line-617"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247949"><span class="hs-identifier hs-type">a</span></a></span></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ a parser that conditionally parses @thenP@ or @elseP@ after @condP@.</span></span><span>
</span><span id="line-618"></span><span id="ifS"><span class="annot"><span class="annottext">ifS :: forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var hs-var">ifS</span></a></span></span><span> </span><span id="local-6989586621679248157"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679248157"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span id="local-6989586621679248158"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248158"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679248159"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248159"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Either () ())
-&gt; Parsec (() -&gt; a) -&gt; Parsec (() -&gt; a) -&gt; Parsec a
forall (f :: * -&gt; *) a b c.
Selective f =&gt;
f (Either a b) -&gt; f (a -&gt; c) -&gt; f (b -&gt; c) -&gt; f c
</span><span class="hs-identifier hs-var">branch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Either () ()
</span><a href="#local-6989586621679248160"><span class="hs-identifier hs-var">bool</span></a></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Either () ()) -&gt; Parsec Bool -&gt; Parsec (Either () ())
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679248157"><span class="hs-identifier hs-var">cond</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248159"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248158"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-619"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679248160"><span class="annot"><span class="annottext">bool :: Bool -&gt; Either () ()
</span><a href="#local-6989586621679248160"><span class="hs-identifier hs-var hs-var">bool</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Either () ()
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-620"></span><span>        </span><span class="annot"><a href="#local-6989586621679248160"><span class="hs-identifier hs-var">bool</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Either () ()
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-621"></span><span>
</span><span id="line-622"></span><span class="hs-comment">-- this is when</span><span>
</span><span id="line-623"></span><span class="annot"><span class="hs-comment">{-|
This combinator conditionally parses @thenP@ depending on the result of parsing @condP@.

This is a lifted @if@-statement. First, parse @condP@: if it is successful and returns
@True@, then parse @thenP@; else, if it returned @False@ do nothing; or, if @condP@ failed
then fail. If @thenP@ fails, then this combinator also fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state.

==== __Examples__
&gt;&gt;&gt; when (pure True) p == p
&gt;&gt;&gt; when (pure False) _ == unit

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-639"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-type">whenS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @condP@, the parser that yields the condition value.</span></span><span>
</span><span id="line-640"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @thenP@, the parser to execute if the condition is @True@.</span></span><span>
</span><span id="line-641"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that conditionally parses @thenP@ after @condP@.</span></span><span>
</span><span id="line-642"></span><span id="whenS"><span class="annot"><span class="annottext">whenS :: Parsec Bool -&gt; Parsec () -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-var hs-var">whenS</span></a></span></span><span> </span><span id="local-6989586621679248161"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679248161"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span id="local-6989586621679248162"><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679248162"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var">ifS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679248161"><span class="hs-identifier hs-var">cond</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679248162"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-643"></span><span>
</span><span id="line-644"></span><span class="hs-comment">-- this is guard</span><span>
</span><span id="line-645"></span><span class="annot"><span class="hs-comment">{-|
This combinator verfies that the given parser returns @True@, or else fails.

First, parse @p@; if it succeeds then, so long at returns @True@, this @guard p@ succeeds. Otherwise,
if @p@ either fails, or returns @False@, @guard p@ will fail.

==== __Examples__
&gt;&gt;&gt; guard (pure True) == unit
&gt;&gt;&gt; guard (pure False) == empty
&gt;&gt;&gt; when (not &lt;$&gt; p) empty == guard p

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-658"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier hs-type">guardS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser that yields the condition value.</span></span><span>
</span><span id="line-659"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-660"></span><span id="guardS"><span class="annot"><span class="annottext">guardS :: Parsec Bool -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier hs-var hs-var">guardS</span></a></span></span><span> </span><span id="local-6989586621679248163"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679248163"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var">ifS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679248163"><span class="hs-identifier hs-var">cond</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
forall a. Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><span class="hs-identifier hs-var">empty</span></span><span>
</span><span id="line-661"></span><span>
</span><span id="line-662"></span><span class="hs-comment">-- this is whileP</span><span>
</span><span id="line-663"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses @p@ so long as it returns @True@.

This is a lifted @while@-loop. First, parse @p@: if it is successful and
returns @True@, then repeat; else if it returned @False@ stop; or, if it
failed then this combinator fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state. In particular, this can be used to define the @forP@ combinator.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-675"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier hs-type">whileS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeatedly parse.</span></span><span>
</span><span id="line-676"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that continues to parse @p@ until it returns @False@.</span></span><span>
</span><span id="line-677"></span><span id="whileS"><span class="annot"><span class="annottext">whileS :: Parsec Bool -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier hs-var hs-var">whileS</span></a></span></span><span> </span><span id="local-6989586621679248164"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679248164"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679248165"><span class="annot"><span class="annottext">go :: Parsec ()
</span><a href="#local-6989586621679248165"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-var">whenS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679248164"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679248165"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679248165"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-678"></span><span>
</span><span id="line-679"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses exactly @n@ occurrences of @p@, returning these @n@ results in a list.

Parses @p@ repeatedly up to @n@ times. If @p@ fails before @n@ is reached, then this combinator
fails. It is not required for @p@ to fail after the @n@th parse. The results produced by
@p@, @x1@ through @xn@, are returned as @[x1, .., xn]@.

==== __Examples__
&gt;&gt;&gt; let p = exactly 3 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ['a', 'b', 'c']
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ['a', 'b', 'c']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-697"></span><span id="local-6989586621679248166"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier hs-type">exactly</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @n@, the number of times to repeat @p@.</span></span><span>
</span><span id="line-698"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679248166"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-699"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679248166"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ exactly @n@ times, returning a list of the results.</span></span><span>
</span><span id="line-700"></span><span id="exactly"><span class="annot"><span class="annottext">exactly :: forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier hs-var hs-var">exactly</span></a></span></span><span> </span><span id="local-6989586621679248167"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248167"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-var">range</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248167"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248167"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-701"></span><span>
</span><span id="line-702"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@, returning these @n@ results in a list.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@^th^ parse.
The results produced by @p@, @xmin@ through @xmax@, are returned as @[xmin, .., xmax]@.

==== __Examples__
&gt;&gt;&gt; let p = range 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ['a', 'b', 'c']
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ['a', 'b', 'c', 'd']
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success ['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success ['a', 'b', 'c', 'd', 'e']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-724"></span><span id="local-6989586621679247956"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-type">range</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-725"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-726"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247956"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-727"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679247956"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the results of the successful parses of @p@.</span></span><span>
</span><span id="line-728"></span><span id="range"><span class="annot"><span class="annottext">range :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-var hs-var">range</span></a></span></span><span> </span><span id="local-6989586621679248177"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248177"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679248178"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248178"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679248179"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248179"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-729"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248177"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248178"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248177"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-730"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec [a]
forall {t} {t}. (Eq t, Eq t, Num t, Num t) =&gt; t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679248182"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248177"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248178"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-731"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-732"></span><span>    </span><span id="local-6989586621679248182"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679248182"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-733"></span><span>    </span><span class="annot"><a href="#local-6989586621679248182"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679248203"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248203"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248179"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679248182"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248203"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-734"></span><span>    </span><span class="annot"><a href="#local-6989586621679248182"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679248204"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248204"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679248205"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248205"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248179"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679248182"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248204"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248205"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-735"></span><span>
</span><span id="line-736"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@ but ignoring the results.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@th parse.
The results are discarded and @()@ is returned instead.

==== __Examples__
&gt;&gt;&gt; let p = range_ 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success ()

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-758"></span><span id="local-6989586621679247961"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier hs-type">range_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-759"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-760"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247961"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-761"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-762"></span><span id="range_"><span class="annot"><span class="annottext">range_ :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier hs-var hs-var">range_</span></a></span></span><span> </span><span id="local-6989586621679248213"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248213"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679248214"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248214"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679248215"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248215"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-763"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248213"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248214"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248213"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-764"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec ()
forall {t} {t}. (Eq t, Eq t, Num t, Num t) =&gt; t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679248216"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248213"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248214"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-765"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-766"></span><span>    </span><span id="local-6989586621679248216"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679248216"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-767"></span><span>    </span><span class="annot"><a href="#local-6989586621679248216"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679248236"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248236"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-var">optional</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248215"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679248216"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248236"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-768"></span><span>    </span><span class="annot"><a href="#local-6989586621679248216"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679248237"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248237"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679248238"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248238"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248215"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679248216"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248237"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248238"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-769"></span><span>
</span><span id="line-770"></span><span class="hs-comment">-- this is count overloading</span><span>
</span><span id="line-771"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@, returning the number of successes.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@th parse.
The results are discarded and the number of successful parses of @p@, @n@, is returned instead, such that
@min &lt;= n &lt;= max@.

==== __Examples__
&gt;&gt;&gt; let p = count 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success 3
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success 5
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success 5

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-794"></span><span id="local-6989586621679247965"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier hs-type">countRange</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-795"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-796"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679247965"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-797"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ parsed successfully.</span></span><span>
</span><span id="line-798"></span><span id="countRange"><span class="annot"><span class="annottext">countRange :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier hs-var hs-var">countRange</span></a></span></span><span> </span><span id="local-6989586621679248249"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248249"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679248250"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248250"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679248251"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248251"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-799"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248249"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248250"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248249"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec Int
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-800"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec Int
forall {t} {t} {b}.
(Eq t, Eq t, Num t, Num t, Num b) =&gt;
t -&gt; t -&gt; Parsec b
</span><a href="#local-6989586621679248252"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248249"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679248250"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-801"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-802"></span><span>    </span><span id="local-6989586621679248252"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec b
</span><a href="#local-6989586621679248252"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">b -&gt; Parsec b
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">b
</span><span class="hs-number">0</span></span><span>
</span><span id="line-803"></span><span>    </span><span class="annot"><a href="#local-6989586621679248252"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679248282"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248282"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b -&gt; b) -&gt; Parsec a -&gt; Parsec b -&gt; Parsec b
forall a b c. (a -&gt; b -&gt; c) -&gt; Parsec a -&gt; Parsec b -&gt; Parsec c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(b -&gt; b) -&gt; a -&gt; b -&gt; b
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b -&gt; b -&gt; b
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">b
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248251"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec b
</span><a href="#local-6989586621679248252"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248282"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec b -&gt; Parsec b -&gt; Parsec b
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; Parsec b
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">b
</span><span class="hs-number">0</span></span><span>
</span><span id="line-804"></span><span>    </span><span class="annot"><a href="#local-6989586621679248252"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679248283"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248283"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679248284"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248284"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; b -&gt; b) -&gt; Parsec a -&gt; Parsec b -&gt; Parsec b
forall a b c. (a -&gt; b -&gt; c) -&gt; Parsec a -&gt; Parsec b -&gt; Parsec c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(b -&gt; b) -&gt; a -&gt; b -&gt; b
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">b -&gt; b -&gt; b
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">b
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679248251"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec b
</span><a href="#local-6989586621679248252"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248283"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679248284"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-805"></span></pre></body></html>