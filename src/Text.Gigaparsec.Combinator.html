<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Safe #-}</span><span>
</span><span id="line-2"></span><span class="annot"><span class="hs-comment">{-|
Module      : Text.Gigaparsec.Combinator
Description : This module contains a huge number of pre-made combinators that are
              very useful for a variety of purposes.
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : stable

This module contains a huge number of pre-made combinators that are very useful for a variety of purposes.

In particular, it contains combinators for: performing a parser iteratively, collecting all the results;
querying whether or not any input is left; optionally performing parsers; parsing delimited constructions;
handling multiple possible alternatives or parsers to sequence; handling more complex conditional execution;
and more.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-19"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Text.Gigaparsec.Combinator</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-20"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Iterative Combinators</span></span><span>
</span><span id="line-21"></span><span>  </span><span class="hs-comment">-- | These combinators all execute a given parser an unbounded number of times, until either it fails, or another</span><span>
</span><span id="line-22"></span><span>  </span><span class="hs-comment">-- parser succeeds, depending on the combinator. Depending on the combinator, all of the results produced by the</span><span>
</span><span id="line-23"></span><span>  </span><span class="hs-comment">-- repeated execution of the parser may be returned in a @[]@. These are almost essential for any practical parsing</span><span>
</span><span id="line-24"></span><span>  </span><span class="hs-comment">-- task.</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier">manyN</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier">skipMany</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier">skipSome</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier">skipManyN</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier">count</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier">count1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier">manyTill</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier">someTill</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyTill"><span class="hs-identifier">skipManyTill</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSomeTill"><span class="hs-identifier">skipSomeTill</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Optional Parsing Combinators</span></span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the /possible/ parsing of some parser. If the parser succeeds, that is ok</span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-comment">-- so long as it __did not consume input__. Be aware that the result of the success may be replaced with</span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-comment">-- these combinators, with the exception of &quot;option&quot;, which still preserves the result.</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier">option</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier">optional</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier">optionalAs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier">decide</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier">fromMaybeS</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>
</span><span id="line-33"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Separated Values Combinators</span></span><span>
</span><span id="line-34"></span><span>  </span><span class="hs-comment">-- | These combinators are concerned with delimited parsing, where one parser is repeated but delimited by another one.</span><span>
</span><span id="line-35"></span><span>  </span><span class="hs-comment">-- In each of these cases @p@ is the parser of interest and @sep@ is the delimeter. These combinators mainly differ</span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-comment">-- in either the number of @p@s they require, or exactly where the delimeters are allowed (only between, always</span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-comment">-- trailing, or either). In all cases, they return the list of results generated by the repeated parses of @p@.</span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier">sepBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier">sepBy1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier">sepEndBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier">sepEndBy1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier">endBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier">endBy1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-39"></span><span>
</span><span id="line-40"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Multiple Branching/Sequencing Combinators</span></span><span>
</span><span id="line-41"></span><span>  </span><span class="annot"><span class="hs-comment">-- | These combinators allow for testing or sequencing a large number of parsers in one go.</span></span><span>
</span><span id="line-42"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier">choice</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">sequence</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">traverse</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier">skip</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Range Combinators</span></span><span>
</span><span id="line-45"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the parsing of a specific parser either a specific number of times, or between a certain</span><span>
</span><span id="line-46"></span><span>  </span><span class="hs-comment">-- amount of times.</span><span>
</span><span id="line-47"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier">exactly</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier">range</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier">range_</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier">countRange</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Selective Combinators</span></span><span>
</span><span id="line-50"></span><span>  </span><span class="hs-comment">-- | These combinators allow for the conditional extraction of a result, or the execution of a parser</span><span>
</span><span id="line-51"></span><span>  </span><span class="hs-comment">-- based on another. They are derived from &quot;branch&quot;.</span><span>
</span><span id="line-52"></span><span>    </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier">ifS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier">whenS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier">guardS</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier">whileS</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-53"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-54"></span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html"><span class="hs-identifier">Text.Gigaparsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier">Parsec</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">many</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">some</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator">($&gt;)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator">(&lt;:&gt;)</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">select</span></span><span class="hs-special">,</span><span>
</span><span id="line-56"></span><span>                        </span><span class="annot"><span class="hs-identifier">branch</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">empty</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword">unit</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#manyl"><span class="hs-identifier">manyl</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#somel"><span class="hs-identifier">somel</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier">notFollowedBy</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">liftA2</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">void</span></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">asum</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">sequenceA_</span></span><span class="hs-special">)</span><span>
</span><span id="line-58"></span><span>
</span><span id="line-59"></span><span class="annot"><span class="hs-comment">{-|
This combinator tries to parse each of the parsers @ps@ in order, until one of them succeeds.

Finds the first parser in @ps@ which succeeds, returning its result. If Nothing of the parsers
succeed, then this combinator fails. If a parser fails having consumed input, this combinator
fails __immediately__.

==== __Examples__
&gt;&gt;&gt; let p = choice [string &quot;abc&quot;, string &quot;ab&quot;, string &quot;bc&quot;, string &quot;d&quot;]
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success &quot;abc&quot;
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;bc&quot;
Success &quot;bc&quot;
&gt;&gt;&gt; parse @String p &quot;x&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-79"></span><span id="local-6989586621679234977"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier hs-type">choice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679234977"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parsers, @ps@ to try, in order.</span></span><span>
</span><span id="line-80"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679234977"><span class="hs-identifier hs-type">a</span></a></span></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to parse one of @ps@.</span></span><span>
</span><span id="line-81"></span><span id="choice"><span class="annot"><span class="annottext">choice :: forall a. [Parsec a] -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#choice"><span class="hs-identifier hs-var hs-var">choice</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parsec a] -&gt; Parsec a
forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Alternative f) =&gt;
t (f a) -&gt; f a
</span><span class="hs-identifier hs-var">asum</span></span><span>
</span><span id="line-82"></span><span>
</span><span id="line-83"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse each of @ps@ in order, discarding the results.

Given the parsers @ps@, consisting of @p1@ through @pn@, parses
each in order. If they all succeed, this combinator succeeds. If any of
the parsers fail, then the whole combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = skip [char'a', item, char 'c']
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-99"></span><span id="local-6989586621679234982"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier hs-type">skip</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679234982"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ parsers @ps@ to be sequenced.</span></span><span>
</span><span id="line-100"></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses each of @ps@, returning @()@.</span></span><span>
</span><span id="line-101"></span><span id="skip"><span class="annot"><span class="annottext">skip :: forall a. [Parsec a] -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skip"><span class="hs-identifier hs-var hs-var">skip</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Parsec a] -&gt; Parsec ()
forall (t :: * -&gt; *) (f :: * -&gt; *) a.
(Foldable t, Applicative f) =&gt;
t (f a) -&gt; f ()
</span><span class="hs-identifier hs-var">sequenceA_</span></span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span class="annot"><span class="hs-comment">{-|
This combinator tries to parse @p@, wrapping its result in a @Just@ if it succeeds, or returns @Nothing@ if it fails.

Tries to parse @p@. If @p@ succeeded, producing @x@, then @Just x@ is returned. Otherwise, if @p@ failed
__without consuming input__, then @Nothing@ is returned instead.

==== __Examples__
&gt;&gt;&gt; let p = option (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success Nothing
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success (Just &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-120"></span><span id="local-6989586621679234987"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier hs-type">option</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679234987"><span class="hs-identifier hs-type">a</span></a></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse</span></span><span>
</span><span id="line-121"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679234987"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-122"></span><span id="option"><span class="annot"><span class="annottext">option :: forall a. Parsec a -&gt; Parsec (Maybe a)
</span><a href="Text.Gigaparsec.Combinator.html#option"><span class="hs-identifier hs-var hs-var">option</span></a></span></span><span> </span><span id="local-6989586621679235155"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235155"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; Maybe a) -&gt; Parsec a -&gt; Parsec (Maybe a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235155"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a) -&gt; Parsec (Maybe a) -&gt; Parsec (Maybe a)
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Maybe a -&gt; Parsec (Maybe a)
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-123"></span><span>
</span><span id="line-124"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse @p@ if possible, otherwise will do nothing.

Tries to parse @p@. If @p@ succeeds, or fails __without consuming input__ then this combinator is successful. Otherwise, if @p@ failed
having consumed input, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = optional (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-141"></span><span id="local-6989586621679234997"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-type">optional</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679234997"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse.</span></span><span>
</span><span id="line-142"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-143"></span><span id="optional"><span class="annot"><span class="annottext">optional :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-var hs-var">optional</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Parsec a -&gt; Parsec ()
forall b a. b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-var">optionalAs</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-144"></span><span>
</span><span id="line-145"></span><span class="annot"><span class="hs-comment">{-|
This combinator will parse @p@ if possible, otherwise will do nothing.

Tries to parse @p@. If @p@ succeeds, or fails __without consuming input__ then this combinator is successful and returns @x@. Otherwise,
if @p@ failed having consumed input, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = optionalAs 7 (string &quot;abc&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success 7
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success 7
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-162"></span><span id="local-6989586621679234999"><span id="local-6989586621679235000"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-type">optionalAs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679234999"><span class="hs-identifier hs-type">b</span></a></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ the value @x@ to return regardless of how @p@ performs.</span></span><span>
</span><span id="line-163"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235000"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to try to parse.</span></span><span>
</span><span id="line-164"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679234999"><span class="hs-identifier hs-type">b</span></a></span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to parse @p@, returning @x@ regardless of success or failure.</span></span><span>
</span><span id="line-165"></span><span id="optionalAs"><span class="annot"><span class="annottext">optionalAs :: forall b a. b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.Combinator.html#optionalAs"><span class="hs-identifier hs-var hs-var">optionalAs</span></a></span></span><span> </span><span id="local-6989586621679235159"><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679235159"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679235160"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235160"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235160"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; b -&gt; Parsec b
forall a b. Parsec a -&gt; b -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679235159"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec b -&gt; Parsec b -&gt; Parsec b
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">b -&gt; Parsec b
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">b
</span><a href="#local-6989586621679235159"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="hs-comment">-- TODO: collect</span><span>
</span><span id="line-168"></span><span class="annot"><span class="hs-comment">{-|
This combinator can eliminate an @Maybe@ from the result of the parser @p@.

First parse @p@, if it succeeds returning @Just x@, then return @x@. However,
if @p@ fails, or returned @Nothing@, then this combinator fails.

==== __Examples__
@decide (option p) = p@
-}</span></span><span>
</span><span id="line-177"></span><span id="local-6989586621679235005"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier hs-type">decide</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679235005"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to parse and extract the result from.</span></span><span>
</span><span id="line-178"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235005"><span class="hs-identifier hs-type">a</span></a></span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser that tries to extract the result from @p@.</span></span><span>
</span><span id="line-179"></span><span id="decide"><span class="annot"><span class="annottext">decide :: forall a. Parsec (Maybe a) -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#decide"><span class="hs-identifier hs-var hs-var">decide</span></a></span></span><span> </span><span id="local-6989586621679235165"><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679235165"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679235165"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a) -&gt; (Maybe a -&gt; Parsec a) -&gt; Parsec a
forall a b. Parsec a -&gt; (a -&gt; Parsec b) -&gt; Parsec b
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; (a -&gt; Parsec a) -&gt; Maybe a -&gt; Parsec a
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
forall a. Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><span class="hs-identifier hs-var">empty</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Parsec a
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span>
</span><span id="line-180"></span><span>
</span><span id="line-181"></span><span class="hs-comment">-- this is decide overload</span><span>
</span><span id="line-182"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses @q@ depending only if @p@ returns a @Nothing@.

First parses @p@. If @p@ returned @Just x@, then @x@ is returned.
Otherwise, if @p@ returned @Nothing@ then @q@ is parsed, producing @y@,
and @y@ is returned. If @p@ or @q@ fails, the combinator fails.

==== __Examples__
fromMaybe q (option p) = p &lt;|&gt; q

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-194"></span><span id="local-6989586621679235013"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier hs-type">fromMaybeS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235013"><span class="hs-identifier hs-type">a</span></a></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser to execute when @p@ returns @Nothing@, to provide a value of type @a@.</span></span><span>
</span><span id="line-195"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679235013"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-comment">-- ^ the first parser @p@, which returns an @Maybe@ to eliminate.</span></span><span>
</span><span id="line-196"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235013"><span class="hs-identifier hs-type">a</span></a></span></span><span>         </span><span class="annot"><span class="hs-comment">-- ^ a parser that either just parses @p@ or both @p@ and @q@ in order to return an @a@.</span></span><span>
</span><span id="line-197"></span><span id="fromMaybeS"><span class="annot"><span class="annottext">fromMaybeS :: forall a. Parsec a -&gt; Parsec (Maybe a) -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#fromMaybeS"><span class="hs-identifier hs-var hs-var">fromMaybeS</span></a></span></span><span> </span><span id="local-6989586621679235171"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235171"><span class="hs-identifier hs-var">q</span></a></span></span><span> </span><span id="local-6989586621679235172"><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679235172"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Either () a) -&gt; Parsec (() -&gt; a) -&gt; Parsec a
forall a b. Parsec (Either a b) -&gt; Parsec (a -&gt; b) -&gt; Parsec b
forall (f :: * -&gt; *) a b.
Selective f =&gt;
f (Either a b) -&gt; f (a -&gt; b) -&gt; f b
</span><span class="hs-identifier hs-var">select</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Either () a -&gt; (a -&gt; Either () a) -&gt; Maybe a -&gt; Either () a
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">() -&gt; Either () a
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">a -&gt; Either () a
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">(Maybe a -&gt; Either () a)
-&gt; Parsec (Maybe a) -&gt; Parsec (Either () a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec (Maybe a)
</span><a href="#local-6989586621679235172"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235171"><span class="hs-identifier hs-var">q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __@n@__ or more times, collecting the results into a list.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will return all of the results, @x1@ through @xm@ (with @m &gt;= n@), in a list: @[x1, .., xm]@.
If @p@ was not successful at least @n@ times, this combinator fails.

==== __Examples__
&gt;&gt;&gt; let p = manyN 2 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success [&quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;, &quot;ab&quot;]
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

==== Notes
* @many p == many 0 p@ and @some p == many 1 p@.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-223"></span><span id="local-6989586621679235023"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-type">manyN</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ the minimum number of @p@s required, @n@.</span></span><span>
</span><span id="line-224"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235023"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to execute multiple times.</span></span><span>
</span><span id="line-225"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235023"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning the list of all the successful results.</span></span><span>
</span><span id="line-226"></span><span id="manyN"><span class="annot"><span class="annottext">manyN :: forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var hs-var">manyN</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679235184"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235184"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235184"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-227"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span id="local-6989586621679235185"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235185"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">some</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235185"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-228"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span id="local-6989586621679235186"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235186"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679235187"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235187"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235187"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec a -&gt; Parsec [a]
forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyN"><span class="hs-identifier hs-var">manyN</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235186"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235187"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed.

==== __Examples__
&gt;&gt;&gt; let p = skipMany (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-250"></span><span id="local-6989586621679235188"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-type">skipMany</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235188"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ the parser @p@ to execute multiple times.</span></span><span>
</span><span id="line-251"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-252"></span><span id="skipMany"><span class="annot"><span class="annottext">skipMany :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var hs-var">skipMany</span></a></span></span><span> </span><span id="local-6989586621679235189"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235189"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679235192"><span class="annot"><span class="annottext">go :: Parsec ()
</span><a href="#local-6989586621679235192"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235189"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679235192"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679235192"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The parser @p@ must succeed at least once.

==== __Examples__
&gt;&gt;&gt; let p = skipSome (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-274"></span><span id="local-6989586621679235193"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-type">skipSome</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235193"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-275"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-276"></span><span id="skipSome"><span class="annot"><span class="annottext">skipSome :: forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-var hs-var">skipSome</span></a></span></span><span> </span><span id="local-6989586621679235195"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235195"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235195"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var">skipMany</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235195"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __@n@__ or more times, ignoring the results.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The parser @p@ must succeed at least @n@ times.

==== __Examples__
&gt;&gt;&gt; let p = skipManyN 2 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-298"></span><span id="local-6989586621679235032"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-type">skipManyN</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @n@, the minimum number of times to execute.</span></span><span>
</span><span id="line-299"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235032"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-300"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until it fails, returning unit.</span></span><span>
</span><span id="line-301"></span><span id="skipManyN"><span class="annot"><span class="annottext">skipManyN :: forall a. Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var hs-var">skipManyN</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679235203"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235203"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipMany"><span class="hs-identifier hs-var">skipMany</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235203"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-302"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span> </span><span id="local-6989586621679235204"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235204"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipSome"><span class="hs-identifier hs-var">skipSome</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235204"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-303"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span id="local-6989586621679235205"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235205"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679235206"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235206"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235206"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec a -&gt; Parsec ()
forall a. Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipManyN"><span class="hs-identifier hs-var">skipManyN</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235205"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235206"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, returning how many times it succeeded.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The number of times @p@ succeeded is returned as the result.

==== __Examples__
&gt;&gt;&gt; let p = count (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Success 0
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success 1
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-325"></span><span id="local-6989586621679235034"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier hs-type">count</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235034"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-326"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ successfully parses</span></span><span>
</span><span id="line-327"></span><span id="count"><span class="annot"><span class="annottext">count :: forall a. Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#count"><span class="hs-identifier hs-var hs-var">count</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int -&gt; a -&gt; Int) -&gt; Int -&gt; Parsec a -&gt; Parsec Int
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#manyl"><span class="hs-identifier hs-var">manyl</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; Int -&gt; Int) -&gt; Int -&gt; a -&gt; Int
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Int -&gt; Int) -&gt; a -&gt; Int -&gt; Int
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-328"></span><span>
</span><span id="line-329"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, returning how many times it succeeded.

Parses a given parser, @p@, repeatedly until it fails. If @p@ failed having consumed input,
this combinator fails. Otherwise when @p@ fails __without consuming input__, this combinator
will succeed. The parser @p@ must succeed at least once. The number of times @p@ succeeded is returned as the result.

==== __Examples__
&gt;&gt;&gt; let p = count1 (string &quot;ab&quot;)
&gt;&gt;&gt; parse @String p &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Success 1
&gt;&gt;&gt; parse @String p &quot;abababab&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;aba&quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-349"></span><span id="local-6989586621679235212"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier hs-type">count1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235212"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-350"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ successfully parses</span></span><span>
</span><span id="line-351"></span><span id="count1"><span class="annot"><span class="annottext">count1 :: forall a. Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#count1"><span class="hs-identifier hs-var hs-var">count1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Int -&gt; a -&gt; Int) -&gt; Int -&gt; Parsec a -&gt; Parsec Int
forall b a. (b -&gt; a -&gt; b) -&gt; b -&gt; Parsec a -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#somel"><span class="hs-identifier hs-var">somel</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; Int -&gt; Int) -&gt; Int -&gt; a -&gt; Int
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Int -&gt; Int) -&gt; a -&gt; Int -&gt; Int
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Int
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-352"></span><span>
</span><span id="line-353"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated by @sep@.

Behaves just like @sepBy1@, except does not require an initial @p@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepBy int (string &quot;, &quot;)
&gt;&gt;&gt; parse @String args &quot;7, 3, 2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Success []
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1, 2, &quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-372"></span><span id="local-6989586621679235042"><span id="local-6989586621679235043"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier hs-type">sepBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235042"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-373"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235043"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-374"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235042"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-375"></span><span id="sepBy"><span class="annot"><span class="annottext">sepBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy"><span class="hs-identifier hs-var hs-var">sepBy</span></a></span></span><span> </span><span id="local-6989586621679235218"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235218"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235219"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235219"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-var">sepBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235218"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235219"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-376"></span><span>
</span><span id="line-377"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated by @sep@.

First parses a @p@. Then parses @sep@ followed by @p@ until there are no more @sep@s.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails. Requires at least
one @p@ to have been parsed.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepBy1 int (string &quot;, &quot;)
&gt;&gt;&gt; parse @String args &quot;7, 3, 2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1, 2, &quot;
Failure ..

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-399"></span><span id="local-6989586621679235220"><span id="local-6989586621679235221"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-type">sepBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235220"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-400"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235221"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-401"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235220"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-402"></span><span id="sepBy1"><span class="annot"><span class="annottext">sepBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepBy1"><span class="hs-identifier hs-var hs-var">sepBy1</span></a></span></span><span> </span><span id="local-6989586621679235224"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235224"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235225"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235225"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235224"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">many</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235225"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep -&gt; Parsec a -&gt; Parsec a
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235224"><span class="hs-identifier hs-var">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-403"></span><span>
</span><span id="line-404"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated and optionally ended by @sep@.

Behaves just like @sepEndBy1@, except does not require an initial @p@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepEndBy int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Success Nil
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-423"></span><span id="local-6989586621679235226"><span id="local-6989586621679235227"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier hs-type">sepEndBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235226"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-424"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235227"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-425"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235226"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-426"></span><span id="sepEndBy"><span class="annot"><span class="annottext">sepEndBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy"><span class="hs-identifier hs-var hs-var">sepEndBy</span></a></span></span><span> </span><span id="local-6989586621679235230"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235230"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235231"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235231"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-var">sepEndBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235230"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235231"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-427"></span><span>
</span><span id="line-428"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated and optionally ended by @sep@.

First parses a @p@. Then parses @sep@ followed by @p@ until there are no more: if a final @sep@ exists, this is parsed.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails. Requires at least
one @p@ to have been parsed.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = sepEndBy1 int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Success [7, 3, 2]
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-450"></span><span id="local-6989586621679235232"><span id="local-6989586621679235233"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-type">sepEndBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235232"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-451"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235233"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-452"></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235232"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-453"></span><span id="sepEndBy1"><span class="annot"><span class="annottext">sepEndBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#sepEndBy1"><span class="hs-identifier hs-var hs-var">sepEndBy1</span></a></span></span><span> </span><span id="local-6989586621679235234"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235234"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235235"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235235"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679235241"><span class="annot"><span class="annottext">seb1 :: Parsec [a]
</span><a href="#local-6989586621679235241"><span class="hs-identifier hs-var hs-var">seb1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235234"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235235"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep -&gt; Parsec [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679235241"><span class="hs-identifier hs-var">seb1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679235241"><span class="hs-identifier hs-var">seb1</span></a></span><span>
</span><span id="line-454"></span><span>
</span><span id="line-455"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __zero__ or more occurrences of @p@, separated and ended by @sep@.

Behaves just like @endBy1@, except does not require an initial @p@ and @sep@, returning the empty list instead.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = endBy int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;&quot;
Success Nil
&gt;&gt;&gt; parse @String args &quot;1;\n&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-474"></span><span id="local-6989586621679235242"><span id="local-6989586621679235243"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier hs-type">endBy</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235242"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-475"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235243"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-476"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235242"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-477"></span><span id="endBy"><span class="annot"><span class="annottext">endBy :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy"><span class="hs-identifier hs-var hs-var">endBy</span></a></span></span><span> </span><span id="local-6989586621679235246"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235246"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235247"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235247"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-var">endBy1</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235246"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235247"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-478"></span><span>
</span><span id="line-479"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses __one__ or more occurrences of @p@, separated and ended by @sep@.

Parses @p@ followed by @sep@ one or more times.
The results of the @p@'s, @x1@ through @xn@, are returned as @[x1, .., xn]@.
If @p@ or @sep@ fails having consumed input, the whole parser fails.

==== __Examples__
&gt;&gt;&gt; ...
&gt;&gt;&gt; let args = endBy1 int (string &quot;;\n&quot;)
&gt;&gt;&gt; parse @String args &quot;7;\n3;\n2&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;&quot;
Failure ..
&gt;&gt;&gt; parse @String args &quot;1;\n&quot;
Success [1]
&gt;&gt;&gt; parse @String args &quot;1;\n2;\n&quot;
Success [1, 2]

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-500"></span><span id="local-6989586621679235248"><span id="local-6989586621679235249"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-type">endBy1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235248"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser whose results are collected into a list.</span></span><span>
</span><span id="line-501"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235249"><span class="hs-identifier hs-type">sep</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @sep@, the delimiter that must be parsed between every @p@.</span></span><span>
</span><span id="line-502"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235248"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ delimited by @sep@, returning the list of @p@'s results.</span></span><span>
</span><span id="line-503"></span><span id="endBy1"><span class="annot"><span class="annottext">endBy1 :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#endBy1"><span class="hs-identifier hs-var hs-var">endBy1</span></a></span></span><span> </span><span id="local-6989586621679235252"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235252"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235253"><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235253"><span class="hs-identifier hs-var">sep</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a]
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f [a]
</span><span class="hs-identifier hs-var">some</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235252"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec sep -&gt; Parsec a
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec a
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f a
</span><span class="hs-operator hs-var">&lt;*</span></span><span> </span><span class="annot"><span class="annottext">Parsec sep
</span><a href="#local-6989586621679235253"><span class="hs-identifier hs-var">sep</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-504"></span><span>
</span><span id="line-505"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __zero__ or more times, until the @end@ parser succeeds, collecting the results into a list.

First tries to parse @end@, if it fails __without consuming input__, then parses @p@, which must succeed. This repeats until @end@ succeeds.
When @end@ does succeed, this combinator will return all of the results generated by @p@, @x1@ through @xn@ (with @n &gt;= 0@), in a
list: @[x1, .., xn]@. If @end@ could be parsed immediately, the empty list is returned.

==== __Examples__
This can be useful for scanning comments:

&gt;&gt;&gt; let comment = string &quot;--&quot; *&gt; manyUntil item endOfLine
&gt;&gt;&gt; parse @String p &quot;--hello world&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--hello world\n&quot;
Success ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
&gt;&gt;&gt; parse @String p &quot;--\n&quot;
Success Nil

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-525"></span><span id="local-6989586621679235255"><span id="local-6989586621679235256"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-type">manyTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235255"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-526"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235256"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @end@, the parser that stops the parsing of @p@.</span></span><span>
</span><span id="line-527"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235255"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until @end@ succeeds, returning the list of all the successful results.</span></span><span>
</span><span id="line-528"></span><span id="manyTill"><span class="annot"><span class="annottext">manyTill :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-var hs-var">manyTill</span></a></span></span><span> </span><span id="local-6989586621679235257"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235257"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235258"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235258"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679235260"><span class="annot"><span class="annottext">go :: Parsec [a]
</span><a href="#local-6989586621679235260"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235258"><span class="hs-identifier hs-var">end</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end -&gt; [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; b -&gt; Parsec b
</span><a href="Text.Gigaparsec.html#%24%3E"><span class="hs-operator hs-var">$&gt;</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235257"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679235260"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec [a]
</span><a href="#local-6989586621679235260"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-529"></span><span>
</span><span id="line-530"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses a given parser __one__ or more times, until the @end@ parser succeeds, collecting the results into a list.

First ensures that trying to parse @end@ fails, then tries to parse @p@. If it succeed then it will repeatedly: try to parse @end@, if it fails
__without consuming input__, then parses @p@, which must succeed. When @end@ does succeed, this combinator will return all of the results
generated by @p@, @x1@ through @xn@ (with @n &gt;= 1@), in a list: @[x1, .., xn]@. The parser @p@ must succeed at least once
before @end@ succeeds.

==== __Examples__
This can be useful for scanning comments:

&gt;&gt;&gt; let comment = string &quot;--&quot; *&gt; someUntil item endOfLine
&gt;&gt;&gt; parse @String p &quot;--hello world&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--hello world\n&quot;
Success ['h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']
&gt;&gt;&gt; parse @String p &quot;--\n&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;--a\n&quot;
Success ['a']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-553"></span><span id="local-6989586621679235261"><span id="local-6989586621679235262"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier hs-type">someTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235261"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to execute multiple times.</span></span><span>
</span><span id="line-554"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235262"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @end@, the parser that stops the parsing of @p@.</span></span><span>
</span><span id="line-555"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235261"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ until @end@ succeeds, returning the list of all the successful results.</span></span><span>
</span><span id="line-556"></span><span id="someTill"><span class="annot"><span class="annottext">someTill :: forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier hs-var hs-var">someTill</span></a></span></span><span> </span><span id="local-6989586621679235264"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235264"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235265"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235265"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec end -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.html#notFollowedBy"><span class="hs-identifier hs-var">notFollowedBy</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235265"><span class="hs-identifier hs-var">end</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec [a] -&gt; Parsec [a]
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235264"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec end -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-var">manyTill</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235264"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235265"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-557"></span><span>
</span><span id="line-558"></span><span id="local-6989586621679235062"><span id="local-6989586621679235063"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipManyTill"><span class="hs-identifier hs-type">skipManyTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235062"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235063"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-559"></span><span id="skipManyTill"><span class="annot"><span class="annottext">skipManyTill :: forall a end. Parsec a -&gt; Parsec end -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipManyTill"><span class="hs-identifier hs-var hs-var">skipManyTill</span></a></span></span><span> </span><span id="local-6989586621679235267"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235267"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235268"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235268"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec end -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#manyTill"><span class="hs-identifier hs-var">manyTill</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235267"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235268"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-560"></span><span>
</span><span id="line-561"></span><span id="local-6989586621679235269"><span id="local-6989586621679235270"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#skipSomeTill"><span class="hs-identifier hs-type">skipSomeTill</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235269"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235270"><span class="hs-identifier hs-type">end</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-562"></span><span id="skipSomeTill"><span class="annot"><span class="annottext">skipSomeTill :: forall a end. Parsec a -&gt; Parsec end -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#skipSomeTill"><span class="hs-identifier hs-var hs-var">skipSomeTill</span></a></span></span><span> </span><span id="local-6989586621679235272"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235272"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679235273"><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235273"><span class="hs-identifier hs-var">end</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec ()
forall (f :: * -&gt; *) a. Functor f =&gt; f a -&gt; f ()
</span><span class="hs-identifier hs-var">void</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec end -&gt; Parsec [a]
forall a sep. Parsec a -&gt; Parsec sep -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#someTill"><span class="hs-identifier hs-var">someTill</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235272"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec end
</span><a href="#local-6989586621679235273"><span class="hs-identifier hs-var">end</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-563"></span><span>
</span><span id="line-564"></span><span class="hs-comment">-- this is ifP</span><span>
</span><span id="line-565"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses one of @thenP@ or @elseP@ depending on the result of parsing @condP@.

This is a lifted @if@-statement. First, parse @condP@: if it is successful and returns
@True@, then parse @thenP@; else, if it returned @False@, parse @elseP@; or, if @condP@ failed
then fail. If either of @thenP@ or @elseP@ fail, then this combinator also fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state.

==== __Examples__
&gt;&gt;&gt; ifP (pure True) p _ == p
&gt;&gt;&gt; ifP (pure False) _ p == p

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-581"></span><span id="local-6989586621679235070"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-type">ifS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @condP@, the parser that yields the condition value.</span></span><span>
</span><span id="line-582"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235070"><span class="hs-identifier hs-type">a</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @thenP@, the parser to execute if the condition is @True@.</span></span><span>
</span><span id="line-583"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235070"><span class="hs-identifier hs-type">a</span></a></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ @elseP@, the parser to execute if the condition is @False@.</span></span><span>
</span><span id="line-584"></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235070"><span class="hs-identifier hs-type">a</span></a></span></span><span>    </span><span class="annot"><span class="hs-comment">-- ^ a parser that conditionally parses @thenP@ or @elseP@ after @condP@.</span></span><span>
</span><span id="line-585"></span><span id="ifS"><span class="annot"><span class="annottext">ifS :: forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var hs-var">ifS</span></a></span></span><span> </span><span id="local-6989586621679235278"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679235278"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span id="local-6989586621679235279"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235279"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679235280"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235280"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec (Either () ())
-&gt; Parsec (() -&gt; a) -&gt; Parsec (() -&gt; a) -&gt; Parsec a
forall (f :: * -&gt; *) a b c.
Selective f =&gt;
f (Either a b) -&gt; f (a -&gt; c) -&gt; f (b -&gt; c) -&gt; f c
</span><span class="hs-identifier hs-var">branch</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Either () ()
</span><a href="#local-6989586621679235281"><span class="hs-identifier hs-var">bool</span></a></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Either () ()) -&gt; Parsec Bool -&gt; Parsec (Either () ())
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679235278"><span class="hs-identifier hs-var">cond</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235280"><span class="hs-identifier hs-var">e</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; () -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; () -&gt; a) -&gt; Parsec a -&gt; Parsec (() -&gt; a)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235279"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-586"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679235281"><span class="annot"><span class="annottext">bool :: Bool -&gt; Either () ()
</span><a href="#local-6989586621679235281"><span class="hs-identifier hs-var hs-var">bool</span></a></span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Either () ()
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-587"></span><span>        </span><span class="annot"><a href="#local-6989586621679235281"><span class="hs-identifier hs-var">bool</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">() -&gt; Either () ()
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-588"></span><span>
</span><span id="line-589"></span><span class="hs-comment">-- this is when</span><span>
</span><span id="line-590"></span><span class="annot"><span class="hs-comment">{-|
This combinator conditionally parses @thenP@ depending on the result of parsing @condP@.

This is a lifted @if@-statement. First, parse @condP@: if it is successful and returns
@True@, then parse @thenP@; else, if it returned @False@ do nothing; or, if @condP@ failed
then fail. If @thenP@ fails, then this combinator also fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state.

==== __Examples__
&gt;&gt;&gt; when (pure True) p == p
&gt;&gt;&gt; when (pure False) _ == unit

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-606"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-type">whenS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @condP@, the parser that yields the condition value.</span></span><span>
</span><span id="line-607"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @thenP@, the parser to execute if the condition is @True@.</span></span><span>
</span><span id="line-608"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that conditionally parses @thenP@ after @condP@.</span></span><span>
</span><span id="line-609"></span><span id="whenS"><span class="annot"><span class="annottext">whenS :: Parsec Bool -&gt; Parsec () -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-var hs-var">whenS</span></a></span></span><span> </span><span id="local-6989586621679235282"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679235282"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span id="local-6989586621679235283"><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679235283"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var">ifS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679235282"><span class="hs-identifier hs-var">cond</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679235283"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-610"></span><span>
</span><span id="line-611"></span><span class="hs-comment">-- this is guard</span><span>
</span><span id="line-612"></span><span class="annot"><span class="hs-comment">{-|
This combinator verfies that the given parser returns @True@, or else fails.

First, parse @p@; if it succeeds then, so long at returns @True@, this @guard p@ succeeds. Otherwise,
if @p@ either fails, or returns @False@, @guard p@ will fail.

==== __Examples__
&gt;&gt;&gt; guard (pure True) == unit
&gt;&gt;&gt; guard (pure False) == empty
&gt;&gt;&gt; when (not &lt;$&gt; p) empty == guard p

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-625"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier hs-type">guardS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser that yields the condition value.</span></span><span>
</span><span id="line-626"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><span id="line-627"></span><span id="guardS"><span class="annot"><span class="annottext">guardS :: Parsec Bool -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#guardS"><span class="hs-identifier hs-var hs-var">guardS</span></a></span></span><span> </span><span id="local-6989586621679235284"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679235284"><span class="hs-identifier hs-var">cond</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec () -&gt; Parsec ()
forall a. Parsec Bool -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
</span><a href="Text.Gigaparsec.Combinator.html#ifS"><span class="hs-identifier hs-var">ifS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679235284"><span class="hs-identifier hs-var">cond</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
forall a. Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a
</span><span class="hs-identifier hs-var">empty</span></span><span>
</span><span id="line-628"></span><span>
</span><span id="line-629"></span><span class="hs-comment">-- this is whileP</span><span>
</span><span id="line-630"></span><span class="annot"><span class="hs-comment">{-|
This combinator repeatedly parses @p@ so long as it returns @True@.

This is a lifted @while@-loop. First, parse @p@: if it is successful and
returns @True@, then repeat; else if it returned @False@ stop; or, if it
failed then this combinator fails.

Most useful in conjunction with /Registers/, as this allows for decisions to be made
based on state. In particular, this can be used to define the @forP@ combinator.

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-642"></span><span class="annot"><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier hs-type">whileS</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeatedly parse.</span></span><span>
</span><span id="line-643"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-comment">-- ^ a parser that continues to parse @p@ until it returns @False@.</span></span><span>
</span><span id="line-644"></span><span id="whileS"><span class="annot"><span class="annottext">whileS :: Parsec Bool -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whileS"><span class="hs-identifier hs-var hs-var">whileS</span></a></span></span><span> </span><span id="local-6989586621679235285"><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679235285"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679235286"><span class="annot"><span class="annottext">go :: Parsec ()
</span><a href="#local-6989586621679235286"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec Bool -&gt; Parsec () -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#whenS"><span class="hs-identifier hs-var">whenS</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec Bool
</span><a href="#local-6989586621679235285"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679235286"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="#local-6989586621679235286"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-645"></span><span>
</span><span id="line-646"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses exactly @n@ occurrences of @p@, returning these @n@ results in a list.

Parses @p@ repeatedly up to @n@ times. If @p@ fails before @n@ is reached, then this combinator
fails. It is not required for @p@ to fail after the @n@th parse. The results produced by
@p@, @x1@ through @xn@, are returned as @[x1, .., xn]@.

==== __Examples__
&gt;&gt;&gt; let p = exactly 3 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ['a', 'b', 'c']
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ['a', 'b', 'c']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-664"></span><span id="local-6989586621679235287"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier hs-type">exactly</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @n@, the number of times to repeat @p@.</span></span><span>
</span><span id="line-665"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235287"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-666"></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235287"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ a parser that parses @p@ exactly @n@ times, returning a list of the results.</span></span><span>
</span><span id="line-667"></span><span id="exactly"><span class="annot"><span class="annottext">exactly :: forall a. Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#exactly"><span class="hs-identifier hs-var hs-var">exactly</span></a></span></span><span> </span><span id="local-6989586621679235288"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235288"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-var">range</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235288"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235288"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-668"></span><span>
</span><span id="line-669"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@, returning these @n@ results in a list.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@^th^ parse.
The results produced by @p@, @xmin@ through @xmax@, are returned as @[xmin, .., xmax]@.

==== __Examples__
&gt;&gt;&gt; let p = range 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ['a', 'b', 'c']
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ['a', 'b', 'c', 'd']
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success ['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success ['a', 'b', 'c', 'd', 'e']

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-691"></span><span id="local-6989586621679235077"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-type">range</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-692"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-693"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235077"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-694"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679235077"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the results of the successful parses of @p@.</span></span><span>
</span><span id="line-695"></span><span id="range"><span class="annot"><span class="annottext">range :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.Combinator.html#range"><span class="hs-identifier hs-var hs-var">range</span></a></span></span><span> </span><span id="local-6989586621679235298"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235298"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679235299"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235299"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679235300"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235300"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-696"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235298"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235299"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235298"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-697"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec [a]
forall {t} {t}. (Eq t, Eq t, Num t, Num t) =&gt; t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679235303"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235298"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235299"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-698"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-699"></span><span>    </span><span id="local-6989586621679235303"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679235303"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-700"></span><span>    </span><span class="annot"><a href="#local-6989586621679235303"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679235324"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235324"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235300"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679235303"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235324"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec [a] -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">[a] -&gt; Parsec [a]
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-701"></span><span>    </span><span class="annot"><a href="#local-6989586621679235303"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679235325"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235325"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679235326"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235326"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235300"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
forall a. Parsec a -&gt; Parsec [a] -&gt; Parsec [a]
</span><a href="Text.Gigaparsec.html#%3C%3A%3E"><span class="hs-operator hs-var">&lt;:&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec [a]
</span><a href="#local-6989586621679235303"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235325"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235326"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-702"></span><span>
</span><span id="line-703"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@ but ignoring the results.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@th parse.
The results are discarded and @()@ is returned instead.

==== __Examples__
&gt;&gt;&gt; let p = range_ 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success ()
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success ()

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-725"></span><span id="local-6989586621679235082"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier hs-type">range_</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-726"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>       </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-727"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235082"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-728"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span></span><span>
</span><span id="line-729"></span><span id="range_"><span class="annot"><span class="annottext">range_ :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#range_"><span class="hs-identifier hs-var hs-var">range_</span></a></span></span><span> </span><span id="local-6989586621679235334"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235334"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679235335"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235335"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679235336"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235336"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-730"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235334"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235335"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235334"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-731"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec ()
forall {t} {t}. (Eq t, Eq t, Num t, Num t) =&gt; t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679235337"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235334"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235335"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-732"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-733"></span><span>    </span><span id="local-6989586621679235337"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679235337"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec ()
</span><a href="Text.Gigaparsec.html#unit"><span class="hs-keyword hs-var">unit</span></a></span><span>
</span><span id="line-734"></span><span>    </span><span class="annot"><a href="#local-6989586621679235337"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679235357"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235357"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec () -&gt; Parsec ()
forall a. Parsec a -&gt; Parsec ()
</span><a href="Text.Gigaparsec.Combinator.html#optional"><span class="hs-identifier hs-var">optional</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235336"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679235337"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235357"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-735"></span><span>    </span><span class="annot"><a href="#local-6989586621679235337"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679235358"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235358"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679235359"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235359"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235336"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec () -&gt; Parsec ()
forall a b. Parsec a -&gt; Parsec b -&gt; Parsec b
forall (f :: * -&gt; *) a b. Applicative f =&gt; f a -&gt; f b -&gt; f b
</span><span class="hs-operator hs-var">*&gt;</span></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec ()
</span><a href="#local-6989586621679235337"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235358"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235359"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span>
</span><span id="line-736"></span><span>
</span><span id="line-737"></span><span class="hs-comment">-- this is count overloading</span><span>
</span><span id="line-738"></span><span class="annot"><span class="hs-comment">{-|
This combinator parses between @min@ and @max@ occurrences of @p@, returning the number of successes.

Parses @p@ repeatedly a minimum of @min@ times and up to @max@ times both inclusive. If @p@ fails before
@min@ is reached, then this combinator fails. It is not required for @p@ to fail after the @max@th parse.
The results are discarded and the number of successful parses of @p@, @n@, is returned instead, such that
@min &lt;= n &lt;= max@.

==== __Examples__
&gt;&gt;&gt; let p = count 3 5 item
&gt;&gt;&gt; parse @String p &quot;ab&quot;
Failure ..
&gt;&gt;&gt; parse @String p &quot;abc&quot;
Success 3
&gt;&gt;&gt; parse @String p &quot;abcd&quot;
Success 4
&gt;&gt;&gt; parse @String p &quot;abcde&quot;
Success 5
&gt;&gt;&gt; parse @String p &quot;abcdef&quot;
Success 5

@since 0.1.0.0
-}</span></span><span>
</span><span id="line-761"></span><span id="local-6989586621679235086"><span class="annot"><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier hs-type">countRange</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @min@, the minimum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-762"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>        </span><span class="annot"><span class="hs-comment">-- ^ @max@, the maximum number of times to repeat @p@, inclusive.</span></span><span>
</span><span id="line-763"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679235086"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ @p@, the parser to repeat.</span></span><span>
</span><span id="line-764"></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span></span><span> </span><span class="annot"><span class="hs-comment">-- ^ the number of times @p@ parsed successfully.</span></span><span>
</span><span id="line-765"></span><span id="countRange"><span class="annot"><span class="annottext">countRange :: forall a. Int -&gt; Int -&gt; Parsec a -&gt; Parsec Int
</span><a href="Text.Gigaparsec.Combinator.html#countRange"><span class="hs-identifier hs-var hs-var">countRange</span></a></span></span><span> </span><span id="local-6989586621679235370"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235370"><span class="hs-identifier hs-var">mn</span></a></span></span><span> </span><span id="local-6989586621679235371"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235371"><span class="hs-identifier hs-var">mx</span></a></span></span><span> </span><span id="local-6989586621679235372"><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235372"><span class="hs-identifier hs-var">p</span></a></span></span><span>
</span><span id="line-766"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235370"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235371"><span class="hs-identifier hs-var">mx</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&lt;</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235370"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Parsec Int
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span>
</span><span id="line-767"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Parsec Int
forall {t} {t} {a}.
(Eq t, Eq t, Num t, Num t, Num a) =&gt;
t -&gt; t -&gt; Parsec a
</span><a href="#local-6989586621679235373"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235370"><span class="hs-identifier hs-var">mn</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679235371"><span class="hs-identifier hs-var">mx</span></a></span><span>
</span><span id="line-768"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-769"></span><span>    </span><span id="local-6989586621679235373"><span class="annot"><span class="annottext">go :: t -&gt; t -&gt; Parsec a
</span><a href="#local-6989586621679235373"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">a -&gt; Parsec a
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">0</span></span><span>
</span><span id="line-770"></span><span>    </span><span class="annot"><a href="#local-6989586621679235373"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span id="local-6989586621679235403"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235403"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; a) -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
forall a b c. (a -&gt; b -&gt; c) -&gt; Parsec a -&gt; Parsec b -&gt; Parsec c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; a -&gt; a -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235372"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec a
</span><a href="#local-6989586621679235373"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">0</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235403"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a -&gt; Parsec a -&gt; Parsec a
forall a. Parsec a -&gt; Parsec a -&gt; Parsec a
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; Parsec a
forall a. a -&gt; Parsec a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">0</span></span><span>
</span><span id="line-771"></span><span>    </span><span class="annot"><a href="#local-6989586621679235373"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679235404"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235404"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span id="local-6989586621679235405"><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235405"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a -&gt; a) -&gt; Parsec a -&gt; Parsec a -&gt; Parsec a
forall a b c. (a -&gt; b -&gt; c) -&gt; Parsec a -&gt; Parsec b -&gt; Parsec c
forall (f :: * -&gt; *) a b c.
Applicative f =&gt;
(a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
</span><span class="hs-identifier hs-var">liftA2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; a -&gt; a -&gt; a
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">+</span></span><span> </span><span class="annot"><span class="annottext">a
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Parsec a
</span><a href="#local-6989586621679235372"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t -&gt; t -&gt; Parsec a
</span><a href="#local-6989586621679235373"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235404"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">t
</span><a href="#local-6989586621679235405"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">t -&gt; t -&gt; t
forall a. Num a =&gt; a -&gt; a -&gt; a
</span><span class="hs-glyph hs-var">-</span></span><span> </span><span class="annot"><span class="annottext">t
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-772"></span></pre></body></html>