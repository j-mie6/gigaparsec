<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE Trustworthy #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE TemplateHaskell, TypeOperators #-}</span><span>
</span><span id="line-3"></span><span class="annot"><span class="hs-comment">{-|
Module      : Text.Gigaparsec.Token.Patterns
Description : Template Haskell generators to help with patterns
License     : BSD-3-Clause
Maintainer  : Jamie Willis, Gigaparsec Maintainers
Stability   : experimental

This module is currently experimental, and may have bugs depending on the version
of Haskell, or the extensions enabled. Please report any issues to the maintainers.

@since 0.2.2.0
-}</span></span><span>
</span><span id="line-15"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Text.Gigaparsec.Token.Patterns</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Token.Patterns.html#overloadedStrings"><span class="hs-identifier">overloadedStrings</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.html"><span class="hs-identifier">Text.Gigaparsec</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier">Parsec</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Token.Lexer.html"><span class="hs-identifier">Text.Gigaparsec.Token.Lexer</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#lexeme"><span class="hs-identifier">lexeme</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#sym"><span class="hs-identifier">sym</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.String</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">IsString</span></span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fromString</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Syntax</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Q</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Dec</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Exp</span></span><span class="hs-special">)</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="annot"><span class="hs-comment">{-|
When given a quoted reference to a 'Text.Gigaparsec.Token.Lexer', for example
@[|lexer|]@, this function will synthesise an `IsString` instance that will
allow string literals to serve as @Parsec ()@. These literals will parse symbols
in the language associated with the lexer, followed by consuming valid whitespace.

@since 0.2.2.0
-}</span></span><span>
</span><span id="line-31"></span><span class="annot"><a href="Text.Gigaparsec.Token.Patterns.html#overloadedStrings"><span class="hs-identifier hs-type">overloadedStrings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Exp</span></span><span>   </span><span class="annot"><span class="hs-comment">-- ^ the quoted 'Text.Gigaparsec.Token.Lexer'</span></span><span>
</span><span id="line-32"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="hs-comment">-- ^ a synthesised `IsString` instance.</span></span><span>
</span><span id="line-33"></span><span id="overloadedStrings"><span class="annot"><span class="annottext">overloadedStrings :: Q Exp -&gt; Q [Dec]
</span><a href="Text.Gigaparsec.Token.Patterns.html#overloadedStrings"><span class="hs-identifier hs-var hs-var">overloadedStrings</span></a></span></span><span> </span><span id="local-6989586621679204548"><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679204548"><span class="hs-identifier hs-var">qlexer</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[d|</span><span>
</span><span id="line-34"></span><span>    </span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621679204549"><span class="annot"><a href="#local-6989586621679204549"><span class="hs-identifier hs-type">u</span></a></span><span> </span><span class="annot"><span class="hs-operator hs-type">~</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">IsString</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.html#Parsec"><span class="hs-identifier hs-type">Parsec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679204549"><span class="hs-identifier hs-type">u</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-35"></span><span>      </span><span class="annot"><span class="hs-identifier hs-var hs-var">fromString</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#sym"><span class="hs-identifier hs-var">sym</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Text.Gigaparsec.Internal.Token.Lexer.html#lexeme"><span class="hs-identifier hs-var">lexeme</span></a></span><span> </span><span class="hs-special">$</span><span class="annot"><span class="annottext">Q Exp
</span><a href="#local-6989586621679204548"><span class="hs-identifier hs-var">qlexer</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- TODO: one day, $qlexer.lexeme.sym</span><span>
</span><span id="line-36"></span><span>  </span><span class="hs-special">|]</span><span>
</span><span id="line-37"></span></pre></body></html>